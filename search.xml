<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/homework/vlsi/vlsi%20%E7%AC%AC%E5%9B%9B%E6%AC%A1%E4%BD%9C%E4%B8%9A/"/>
      <url>/homework/vlsi/vlsi%20%E7%AC%AC%E5%9B%9B%E6%AC%A1%E4%BD%9C%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[<h1>vlsi 第四次作业</h1><p>郭高旭 <a href="mailto:ggx21@mails.tsinghua.edu.cn">ggx21@mails.tsinghua.edu.cn</a> 2021010803</p><ol><li class="lvl-3"><p>即在某种输入下，等效导电因子最小的工作情况。</p></li><li class="lvl-3"><p>N 个管子串联使用时，其等效导电因子为<br>$$<br>\beta_{\text{串}} = \frac{1}{\sum_{i} \frac{1}{\beta_i}}<br>$$​N 个管子并联使用时，其等效导电因子为<br>$$<br>\beta_{\text{并}} = \sum_{i} \beta_i题<br>$$</p></li><li class="lvl-3"><p>最坏工作情况</p><ul class="lvl-2"><li class="lvl-5"><p>三输入与非门工作情况如下</p><ol><li class="lvl-8">当A,B,C=1,1,1时，下拉管的等效导电因子$\beta=\beta _ {n}/3$</li><li class="lvl-8">当A,B,C其中$n$个为0时，上拉管的等效导电因子为$\beta=\beta _ {p}\times n,n=1,2,3$</li></ol><p>综上，下拉路径导通时，N型晶体管必须全部导通。上拉路径导通时，最坏的工作情况下，只有一个P型管导通。<br>$$<br>\beta_{neff}=\beta _ {n}/3\<br>\beta_{peff}=\beta _ {p}<br>$$</p></li><li class="lvl-5"><p>三输入或非门工作情况如下</p><ol><li class="lvl-8">当A,B,C=0，0，0时，上拉管的等效导电因子$\beta=\beta _ {p}/3$</li><li class="lvl-8">当A,B,C其中$n$个为1时，下拉管的等效导电因子为$\beta=\beta _ {n}\times n,n=1,2,3$</li></ol><p>综上，上拉路径导通时，P型晶体管必须全部导通。下拉路径导通时，最坏的工作情况下，只有一个N型管导通。</p></li></ul></li></ol><p>$$<br>\beta_{peff}=\beta _ {p}/3\<br>\beta_{neff}=\beta _ {n}<br>$$</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/homework/computer_orgnization/cod-hw2/"/>
      <url>/homework/computer_orgnization/cod-hw2/</url>
      
        <content type="html"><![CDATA[<h1>cod-hw2</h1><p>郭高旭 <a href="mailto:ggx21@mails.tsinghua.edu.cn">ggx21@mails.tsinghua.edu.cn</a> 2021010803</p><ol><li class="lvl-3"><p>C</p></li><li class="lvl-3"><p>A</p></li><li class="lvl-3"><p>是的，在<strong>相同的cpu频率下</strong>，CPI 越低，每条指令的平均执行时间就越短，吞吐量较高，cpu响应速度也越快，整体执行效率越高。但是，单纯追求低 CPI 并不总是最终目标，因为在一些情况下，需要权衡执行效率、能效、成本以及<strong>时钟频率</strong>等因素。</p></li><li class="lvl-3"><p>不一定，如果后面的指令需要数据但此时数据还没有产生，那么数据旁路也不能解决这种数据冲突。比如load类指令在mem段将数据存入寄存器，如果下一条指令id段要读取这个寄存器，那么数据旁路不能解决。</p></li><li class="lvl-3"><p>不<em>支持</em>。 对于<em>RISC</em>-<em>V</em>架构而言，进入异常之后，mstatus<em>寄存器</em>中的MIE域将会被硬件自动更新成0（意味着<em>中断</em>全局被关闭，从而无法响应新的<em>中断</em>）</p></li><li class="lvl-3"><p>题</p><ol><li class="lvl-6">FEC7 96E3</li><li class="lvl-6">当前pc的前4096到后4094（偶数，如果要求合法，则应该对齐为四的倍数）</li><li class="lvl-6"><img src="https://gitlab.com/ggx-blog/imglab/uploads/5cfd4bde2a22061266aad73a125e30a8/202311262336501.png" alt="image-20231126233637425"></li><li class="lvl-6">89</li><li class="lvl-6">如果使用数据旁路，12 lw 和 14.中的a3否则会发生数据冲突的行号有（1.，2.）（11.，12.，14.）（14.，15.）（16.17）</li></ol></li><li class="lvl-3"><p>题</p><ul class="lvl-2"><li class="lvl-5"><p>DM@MEM/WB-&gt;DM</p></li><li class="lvl-5"><p>交换最后两行</p></li><li class="lvl-5"><p>a) IF: nop<br>ID: sw t1, (a0)<br>EXE: bne t3, x0, count<br>MEM: add t1, t1, t0<br>WB: add t3, t3, -1</p></li><li class="lvl-5"><p>DM@MEM/WB-&gt;DM</p></li><li class="lvl-5"><p>方案一不满足精确异常的定义。精确异常要求在产生异常时，不会对指令流水线中的指令状态造成任何影响，即异常应该在异常指令执行之前进行处理。而方案一中，异常信号被存入ID/EXE流水寄存器，会在下一个周期由EXE段的异常处理模块处理，这就导致了异常信号的处理不是在异常指令执行之前完成的。</p></li><li class="lvl-5"><pre><code class="language-assembly">RV.X   // 引发异常的指令ADDI a0,1    // 普通指令SUBI a0,1    // 普通指令</code></pre></li><li class="lvl-5"><p>这里第一条指令 <code>RV.X</code> 是会引发异常的指令。在方案一中，异常信号会被存入ID/EXE流水寄存器，并在下一个周期被EXE段的异常处理模块处理。但问题在于，由于流水线中已经有了 ADD 和 SUB 两条指令，它们在当前周期内会继续执行。</p></li></ul></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/homework/database_intro/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B0%8F%E4%BD%9C%E4%B8%9A/"/>
      <url>/homework/database_intro/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B0%8F%E4%BD%9C%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[<h1>数据库小作业</h1><p>郭高旭 <a href="mailto:ggx21@mails.tsinghua.edu.cn">ggx21@mails.tsinghua.edu.cn</a> 2021010803</p><h4 id="作业1">作业1</h4><p>创建测试样例如下表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sql</span><span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> lab1.person LIMIT <span class="number">0</span>, <span class="number">1001</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">------+-----+</span></span><br><span class="line"><span class="operator">|</span> NAME <span class="operator">|</span> AGE <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+-----+</span></span><br><span class="line"><span class="operator">|</span> A    <span class="operator">|</span>  <span class="number">10</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> B    <span class="operator">|</span>  <span class="number">20</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> C    <span class="operator">|</span>  <span class="number">30</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> D    <span class="operator">|</span>  <span class="number">40</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> E    <span class="operator">|</span>  <span class="number">50</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> F    <span class="operator">|</span>  <span class="number">60</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> G    <span class="operator">|</span>  <span class="number">70</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> H    <span class="operator">|</span>  <span class="number">80</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> I    <span class="operator">|</span>  <span class="number">90</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> J    <span class="operator">|</span> <span class="number">100</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> K    <span class="operator">|</span> <span class="number">110</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> L    <span class="operator">|</span> <span class="number">110</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> M    <span class="operator">|</span> <span class="number">110</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> L    <span class="operator">|</span> <span class="number">110</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> M    <span class="operator">|</span> <span class="number">110</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> L    <span class="operator">|</span> <span class="number">110</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> M    <span class="operator">|</span> <span class="number">110</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">------+-----+</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sql</span><span class="operator">&gt;</span> <span class="comment">-- 方法一,直接使用DISTINCT关键字</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> NAME, AGE) <span class="keyword">FROM</span> PERSON LIMIT <span class="number">0</span>, <span class="number">1001</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> NAME, AGE) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+</span></span><br><span class="line"><span class="operator">|</span>                        <span class="number">13</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------+</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sql</span><span class="operator">&gt;</span> <span class="comment">-- 方法二,使用子查询和GROUP BY</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> NAME, AGE</span><br><span class="line">    <span class="keyword">FROM</span> PERSON</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> NAME, AGE</span><br><span class="line">) <span class="keyword">AS</span> UniqueTuples LIMIT <span class="number">0</span>, <span class="number">1001</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">13</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sql</span><span class="operator">&gt;</span> <span class="comment">-- 方法三,使用GROUP BY和HAVING</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> NAME, AGE <span class="keyword">FROM</span> PERSON) <span class="keyword">AS</span> UniqueTuples LIMIT <span class="number">0</span>, <span class="number">1001</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="operator">|</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">13</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+</span></span><br></pre></td></tr></table></figure><h4 id="作业2">作业2</h4><p>实现一trigger，使得在向department添加行时复制内容到student3表中，代码如下</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> IF <span class="keyword">EXISTS</span> copy_to_std3;</span><br><span class="line">DELIMITER $$</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> copy_to_std3 </span><br><span class="line">AFTER <span class="keyword">INSERT</span> </span><br><span class="line"><span class="keyword">ON</span> department</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">DECLARE</span> DL <span class="type">varchar</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">DECLARE</span> DN <span class="type">varchar</span>(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">SET</span> DL <span class="operator">=</span> NEW.department_leader;</span><br><span class="line">    <span class="keyword">SET</span> DN <span class="operator">=</span> NEW.department_name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> student3</span><br><span class="line">    <span class="keyword">VALUES</span> (<span class="string">&#x27;名誉生&#x27;</span>, DL, DN);</span><br><span class="line"><span class="keyword">END</span>$$</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p>结果展示</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sql</span><span class="operator">&gt;</span> <span class="keyword">insert</span> <span class="keyword">into</span> department <span class="keyword">values</span>(<span class="string">&#x27;雅典大学&#x27;</span>,<span class="string">&#x27;中央主楼&#x27;</span>,<span class="string">&#x27;吴院士&#x27;</span>);</span><br><span class="line"><span class="keyword">sql</span><span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> student3 LIMIT <span class="number">0</span>, <span class="number">1001</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+--------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> student_number <span class="operator">|</span> student_name <span class="operator">|</span> department_name <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+--------------+-----------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="number">861317</span>         <span class="operator">|</span> 孙大帅          <span class="operator">|</span> 网络学院            <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> 名誉生            <span class="operator">|</span> 吴院士          <span class="operator">|</span> 雅典大学            <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------+--------------+-----------------+</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/homework/flower_identification/%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
      <url>/homework/flower_identification/%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1>课程总结</h1><p>郭高旭 <a href="mailto:ggx21@mails.tsinghua.edu.cn">ggx21@mails.tsinghua.edu.cn</a> 2021010803</p><h2 id="课程收获">课程收获</h2><p>首先是知识的获得。我还记得第一节课有两位男同学答着答着题就背起书包和老师说了拜拜，那次答题我大概和他们一样对花卉一无所知。但现在至少我可以认出学校里不少常见植物，看着自己网站上收集鉴定的几十种花卉满满成就感；而更重要的是我拥有了一些识别花卉的方法论，以后看到不认识的花也能凭借此认出个七七八八。</p><p>这些知识也是很好的谈资，和小朋友漫步于校园中的时候，我也可以为他们指认一些植物，给他们讲些跟这些花草树木有关的各种奇怪小知识。</p><p>但是最根本上的来说，我认为学习的过程就是认识世界的过程。比如学习物理可以认识到宇宙运转的规律，学习心理学可以认识自己。而这门课确实补上了五谷不分的我认识中的一块很重要的拼图——对世间万物的认识。我现在有些遗憾，多少次和这些植物擦肩而过却从未真正“见过”它们——它们原本不存在我的世界里。直到这学期我才真正欣赏校园的美丽。</p><h2 id="课程相关建议">课程相关建议</h2><ul class="lvl-0"><li class="lvl-2"><p>希望实验课可以多一些，每次都玩得挺开心的</p></li><li class="lvl-2"><p>自我评估和反馈机制：建议课程设置一些自我评估和反馈的环节，让学生有机会反思自己的学习过程和结果，从而更好地调整学习方法。</p></li><li class="lvl-2"><p>希望课堂互动能多些，每次不确定自己是否能鉴定出来。</p></li><li class="lvl-2"><p>希望能看到更多花卉实物</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/homework/network_security/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C%E4%B8%80/"/>
      <url>/homework/network_security/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%8A%80%E6%9C%AF%E5%AE%9E%E9%AA%8C%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h1>计算机网络安全技术实验一</h1><p>郭高旭 <a href="mailto:ggx21@mails.tsinghua.edu.cn">ggx21@mails.tsinghua.edu.cn</a> 2021010803</p><h2 id="Task1">Task1</h2><h3 id="补全：">补全：</h3><ul class="lvl-0"><li class="lvl-2"><p>Router3-Port1-ip：10.0.2.1</p></li><li class="lvl-2"><p>PC3-Port1-ip：192.168.3.2</p></li><li class="lvl-2"><p>labtop2-gateway:192.168.2.2</p></li></ul><h3 id="纰漏：">纰漏：</h3><ul class="lvl-0"><li class="lvl-2"><p>Router2-Port2-ip改为10.0.2.2</p></li></ul><h2 id="Task2">Task2</h2><h3 id="网络拓扑">网络拓扑</h3><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/5ee48dd19a4eae04fbd52b7579c3662e/202311091039437.png" alt="image-20231109103903327"></p><h3 id="网络配置（以router1为例）">网络配置（以router1为例）</h3><h4 id="端口ip">端口ip</h4><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/d8077117f3d142b02bf6a6a788a9f624/202311091040608.png" alt="image-20231109104003578"></p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/a333701806282d79357b313c98164701/202311091040350.png" alt="image-20231109104046328"></p><h4 id="子网中设备网关">子网中设备网关</h4><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/23ca84de7b737229155b615fb4693ec0/202311091041162.png" alt="image-20231109104120128"></p><h2 id="Task3">Task3</h2><h3 id="password设置">password设置</h3><p>YHQL, YLGL, YLFL是凯撒码加密后的Veni, Vidi, Vici。每个字母向后移3位得到。</p><h3 id="password1">password1</h3><p>通过console口进入用户模式的口令password1：veni</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/105936e35c952ecb91285b83c6687284/202311091111515.png" alt="image-20231109111125491"></p><h3 id="password2">password2</h3><p>用户模式进入特权模式的口令password2：vidi</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/630c32367c1e9f06598baf49f6142e54/202311091115044.png" alt="image-20231109111543016"></p><h3 id="password3">password3</h3><p>通过telnet方式登录路由器的口令password3：vici</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/e02b73a222014cc84b0cbec5aed9c500/202311091116324.png" alt="image-20231109111648304"></p><h3 id="show-running-config">show running-config</h3><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/8dbfea9977c245aa2cf0448a353a82ba/202311091114100.png" alt="image-20231109111459084"></p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/19563d547219a60165792019572f727d/202311091117179.png" alt="image-20231109111725156"></p><h3 id="如果配置文件可能泄露，作如下变化">如果配置文件可能泄露，作如下变化</h3><p>使用复杂度更高的密码</p><h4 id="特权模式密码用secret存储">特权模式密码用secret存储</h4><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/e8ba3ef0364d69e428eb8d3d19e4ae46/202311091127324.png" alt="image-20231109112756302"></p><h4 id="开启password加密">开启password加密</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Router(config)<span class="comment">#service password-encryption</span></span><br></pre></td></tr></table></figure><h4 id="show-running-config-2">show running-config</h4><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/26f8bbf4883a39c632a6cf0efa3724cf/202311091130893.png" alt="image-20231109113011871"></p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/ecfae80d99cd56ec8b83886125bdd81e/202311091130260.png" alt="image-20231109113030240"></p><h3 id="检查：在pc1终端尝试用vici连接router，成功">检查：在pc1终端尝试用vici连接router，成功</h3><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/4f1adb51dd39102ff7319e3a31b4099e/202311091132557.png" alt="image-20231109112328709"></p><h3 id="暴力破解">暴力破解</h3><p>工牌背后用rsa公钥解密后得到提示：容斥原理</p><ol><li class="lvl-4"><p>$10^6$</p></li><li class="lvl-3"><p>$36<sup>6-10</sup>6-26<sup>6=1.87\times10</sup>9$</p></li><li class="lvl-3"><p>$62<sup>6+10</sup>6+2\times 26^6 -2\times36<sup>6-52</sup>6=3.3\times10^{10}$</p></li><li class="lvl-3"><p>$62<sup>8+10</sup>8+2\times 26^8 -2\times36<sup>8-52</sup>8=1.6\times10^{14}$</p></li></ol><h3 id="Task4">Task4</h3><h3 id="router1">router1</h3><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/4601b0ec235bef20fee211dbd20bb5f6/202311091157911.png" alt="image-20231109115730886"></p><h3 id="router2">router2</h3><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/12d44b3bd1e4b0adb0e32efd501674a5/202311091157536.png" alt="image-20231109115745505"></p><h3 id="router3">router3</h3><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/08f6ecf5275ab0df8e2fe9ca7315baf0/202311091158273.png" alt="image-20231109115803236"></p><h3 id="检查：pc1-ping-pc3，成功">检查：pc1 ping pc3，成功</h3><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/791512aff0d7ab78af971283bd149e23/202311091136178.png" alt="image-20231109113607151"></p><h2 id="Task5（满足布鲁图的要求）">Task5（满足布鲁图的要求）</h2><p>在元老院和部族会议所之间新建链路（使用带宽较小的串口，并使用ospf路由协议）</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/41dec00d7a2d69f77c13facd37c10c77/202311091225429.png" alt="image-20231109122543372"></p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/24d4478c01e302ed5fcbef2b89ad713c/202311091227598.png" alt="image-20231109122755569"></p><p>使用仿真功能可以发现，元老院和部族会议的通信（pc1 ping pc3）实际上并没有走新的串口链路，而是仍然经过了执政官首府（router2）</p><h4 id="ospf配置部分展示">ospf配置部分展示</h4><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/b9e0d4ff09f5d9f14dcf1f871d1584e1/202311091229737.png" alt="image-20231109122956705"></p><h3 id="凯撒的问题">凯撒的问题</h3><p>RIP协议针对的是较小的网络，但较小的意思是网络中最大跳数小于16而不是所有的终端小于16.</p><p>当前能使用rip作为路由协议，但是这不能满足布鲁图的要求，因为rip选取下一跳是根据路径长度（跳数多少）决定的，所以会经过串口直达router3</p><h2 id="secret加密方式">secret加密方式</h2><p>md5</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>note_database</title>
      <link href="/notes/database_intro/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/"/>
      <url>/notes/database_intro/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1>数据库笔记</h1><h2 id="什么是数据库">什么是数据库</h2><p>数据抽象：数据的定义与应用程序相分离。</p><h3 id="ER图：实体与属性">ER图：实体与属性</h3><p>可以用ER图表示数据库，包括：</p><ol><li class="lvl-3"><p>实体</p></li><li class="lvl-3"><p>联系</p></li><li class="lvl-3"><p>属性</p></li></ol><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/7bbd854b09125295dd310fef19a83f80/202310281537772.png" alt="image-20231028153746706"></p><h3 id="视图机制">视图机制</h3><blockquote><p>一个<code>视图</code>实际上是数据库的一个<strong>子集</strong></p></blockquote><p>不是所有人都想/应该看到数据的全部，视图机制提供：</p><ul class="lvl-0"><li class="lvl-2"><p>保密级别</p></li><li class="lvl-2"><p>自定义数据库外观</p></li><li class="lvl-2"><p>程序数据独立性：数据库已经被改变，但外观仍保持一致</p></li></ul><h3 id="数据库的结构">数据库的结构</h3><ol><li class="lvl-3"><p>数据表（Tables）：数据表是数据库中的主要组成部分，用于存储数据。每个数据表包含多个列，用于定义数据的结构。</p></li><li class="lvl-3"><p>列（Columns）：列是数据表中的字段，用于存储特定类型的数据。每列都有一个数据类型和约束，以定义它可以存储的数据内容。</p></li><li class="lvl-3"><p>数据行（Rows）：数据行是实际存储在数据表中的数据记录。每一行包含了表中各列的具体数据值。</p></li><li class="lvl-3"><p>主键（Primary Key）：主键是一个唯一标识数据表中每行数据的列。它确保每行都有唯一的标识符，用于快速检索和关联数据。</p></li><li class="lvl-3"><p>外键（Foreign Key）：外键是一个列或一组列，用于建立不同数据表之间的关系。它们用于维护表之间的引用完整性，确保关联的数据的一致性。</p></li><li class="lvl-3"><p>索引（Indexes）：索引是一种优化数据库性能的结构，它加速了数据的检索操作。索引可以建立在一个或多个列上，允许快速查找数据。</p></li><li class="lvl-3"><p>视图（Views）：视图是一个虚拟表，它是基于一个或多个实际数据表的查询结果。视图可以简化数据访问，并提供安全性和数据抽象。</p></li><li class="lvl-3"><p>存储过程（Stored Procedures）：存储过程是一组SQL语句的集合，可以被数据库执行。它们可以用于实现业务逻辑、数据转换和数据验证。</p></li><li class="lvl-3"><p>触发器（Triggers）：触发器是与数据表相关联的一段代码，它会在表上的特定事件发生时自动触发。触发器用于实现自动化操作和数据约束。</p></li><li class="lvl-4"><p>索引（Functions）：函数是数据库中可重复使用的程序代码块，用于执行特定操作或计算。数据库可以提供内置函数，也可以创建用户自定义函数。</p></li></ol><h2 id="chap2-数据库环境">chap2 数据库环境</h2><h3 id="ANSI-SPARC三层体系结构">ANSI-SPARC三层体系结构</h3><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/778345fba766af2c76773023cc04a8ef/202310281808982.png" alt="image-20231028180833931"></p><h3 id="数据库语言">数据库语言</h3><ul class="lvl-0"><li class="lvl-2"><p>数据定义语言（DDL）</p></li><li class="lvl-2"><p>数据操作语言（DML）</p><ul class="lvl-2"><li class="lvl-4">过程化DML：检索嵌套依赖</li><li class="lvl-4">非过程化DML：一步得出结果</li></ul></li></ul><h3 id="数据模型">数据模型</h3><ul class="lvl-0"><li class="lvl-2"><h4 id="基于对象的数据模型">基于对象的数据模型</h4><ul class="lvl-2"><li class="lvl-4">实体<ul class="lvl-4"><li class="lvl-6">属性</li><li class="lvl-6">行为</li></ul></li></ul></li><li class="lvl-2"><p>基于记录的数据模型</p><ul class="lvl-2"><li class="lvl-4"><p>关系数据模型</p><p>数据按照表格组织，每个表格有Unique的列，表格间通过相同的内容可以建立间接连接，但没有显示连接。</p><p>关系数据模型只适用于外部层和概念层</p></li><li class="lvl-4"><p>网状数据模型</p><p>数据被表示为一组<code>record</code>成为图的节点,联系通常用指针实现被表示为<code>set</code>成为图的边</p></li><li class="lvl-4"><p>层次数据模型</p><p>一个节点只能有一个父节点,成为树形结构</p></li></ul><h3 id="chap3-数据库的结构与web">chap3 数据库的结构与web</h3><h3 id="DBMS的组件">DBMS的组件</h3><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/cdc864d6403c57ce452f6235c49fcea0/202310281857138.png" alt="image-20231028185718067"></p></li></ul><blockquote><p>系统目录（System Catalog）是数据库管理系统（DBMS）内部的元数据（metadata）存储区域，用于描述和记录数据库中的对象、结构、关系和属性等信息。系统目录是DBMS的内部数据库，其中存储了有关数据库自身的信息，以便DBMS能够有效地管理和操作数据库。</p></blockquote><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/958312d55d7d09ea025588a74cd18829/202310281906662.png" alt="image-20231028190649606"></p><h2 id="chap5：关系代数与关系演算">chap5：关系代数与关系演算</h2><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/011919b0a47656ed0be3dbe74daa59b9/202310291454124.png" alt="image-20231029145403952"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -t -p 10002 2021010803@166.111.121.61 mysql -hdb -u2021010803 -p</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h166.111.121.61 -P10001 -u2021010803 -p fde4dbf05ccfc9234b0bf26f853fa051</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lab3</title>
      <link href="/homework/computer_orgnization/lab3/"/>
      <url>/homework/computer_orgnization/lab3/</url>
      
        <content type="html"><![CDATA[<h1>实验三</h1><p>郭高旭 <a href="mailto:ggx21@mails.tsinghua.edu.cn">ggx21@mails.tsinghua.edu.cn</a> 2021010803</p><h2 id="实验报告">实验报告</h2><ul class="lvl-0"><li class="lvl-2"><h4 id="仿真截图">仿真截图</h4><ul class="lvl-2"><li class="lvl-4"><p>设计了验证ALU功能与展示结果的测试，随机测试各种运算操作。主要是通过观察寄存器堆读出的运算数、alu计算后的运算数是否和预期一致。</p></li><li class="lvl-4"><p>assert(alu_a==rdata_a),assert(alu_b==rdata_b)，assert(alu_y==wdata)</p></li><li class="lvl-4"><pre><code class="language-cpp">    //验证ALU功能    for (int i = 1; i &lt; 32; i = i + 1) begin      #100;      rd = i;   // only lower 5 bits      rs1 = $urandom_range(0, 32);      rs2 = $urandom_range(0, 32);      opcode = $urandom_range(1, 11);      dip_sw = `inst_rtype(rd, rs1, rs2, opcode);      push_btn = 1;      #100;      push_btn = 0;      // 展示结果      #100;      rd = i;   // only lower 5 bits      dip_sw = `inst_peek(rd, 0);      push_btn = 1;      #100;      push_btn = 0;      #1000;</code></pre></li></ul><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/fd7871b4f346101be0ede9ad0b158017/202310220004076.png" alt="image-20231022000429920"></p><p>此外还设计了peek指令验证每个寄存器存储值正确</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/ad0d2595c95aff2c8cce6e6c7d34fead/202310220029373.png" alt="image-20231022002957251"></p></li><li class="lvl-2"><h3 id="在线实验平台">在线实验平台</h3><ul class="lvl-2"><li class="lvl-4">POKE imm<strong>7</strong> into r1 then PEEK r1，正常显示7</li></ul><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/cd1c6d956c33c3f816d015c6bf525d43/202310220012085.png" alt="image-20231022001257034"></p><ul class="lvl-2"><li class="lvl-4"><p>poke 8 into r2 ,  add r1 r2 to r3 ,then peek r3:正常得到15</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/676384fae5030febd0fd5a8430233424/202310220023249.png" alt="image-20231022002321205"></p></li><li class="lvl-4"><p>not r1 to r3,peek r3结果正确</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/9ac791ff3e687d394b9520177a185b76/202310220025884.png" alt="image-20231022002505841"></p></li><li class="lvl-4"><p>r1逻辑左移r2位的结果，正确</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/e99b6bad399a40e9627c590be68de676/202310220026873.png" alt="image-20231022002630826"></p></li><li class="lvl-4"><p>循环左移结果</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/5b800c361a2c964994c438d5d7a44787/202310220027990.png" alt="image-20231022002728947"></p></li><li class="lvl-4"><p>所有操作在板子上均得到正确结果</p></li></ul></li></ul><h2 id="思考题">思考题</h2><p>如果读取到乘除法运算，则在decode时根据操作数的位数计算出需要的时钟周期，给CALC过程添加一个自环，每次操作CLK_CNT–，直到得0（所有位数计算完成）退出自环，进入WRITE模式</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/57198dc24172f3ca34d2c0960996325e/202310220043661.png" alt="image-20231022004352614"></p>]]></content>
      
      
      <categories>
          
          <category> homework </category>
          
          <category> cod </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cod </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lab4_5</title>
      <link href="/homework/computer_orgnization/lab4_5/"/>
      <url>/homework/computer_orgnization/lab4_5/</url>
      
        <content type="html"><![CDATA[<h1>实验四 SRAM控制器实验</h1><p>郭高旭 <a href="mailto:ggx21@mails.tsinghua.edu.cn">ggx21@mails.tsinghua.edu.cn</a> 2021010803</p><h2 id="实验报告">实验报告</h2><ul class="lvl-0"><li class="lvl-2"><h3 id="实验过程">实验过程</h3><h4 id="sram状态机设计">sram状态机设计</h4><pre class="mermaid">  flowchart LRidle-->|stb_i&&cyc_i&&we_i|write-->write_2-->write_3-->done-->idleidle-->|stb_i&&cyc_i&&!we_i|read-->read_2-->done</li></ul><p>各个状态的功能如下：</p><ul class="lvl-0"><li class="lvl-2"><p>idle：空闲状态，等待读写请求,当接受到master的cyce和stb信号时，根据we信号判断是读还是写</p></li><li class="lvl-2"><p>read：准备读取数据，按照要求输出 addr, oe_n=0, ce_n=0, we_n=1，根据sel信号选择输出的数据<code>be_n</code></p></li><li class="lvl-2"><p>read_2:把数据存到寄存器中</p></li><li class="lvl-2"><p>write：准备写入数据，按照要求输出 addr, data, oe_n=1, ce_n=0, we_n=1，根据sel信号选择输出的数据<code>be_n</code></p></li><li class="lvl-2"><p>write_2:输出写使能信号we_n=0</p></li><li class="lvl-2"><p>write_3:关闭写使能信号</p></li><li class="lvl-2"><p>done:输出ack信号，表示读写完成,关闭所有使能信号</p></li><li class="lvl-2"><h3 id="波形仿真">波形仿真</h3><p>修改 lab4_tb.sv ，设置 dip_sw 随机种子，进行波形仿真，结果如下</p></li></ul><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/d6c618512f8132fcfdfa92c76cc2c760/202311042145892.png" alt="cd30d22dfb3645585a31116b6e1f8eb"></p><ul class="lvl-0"><li class="lvl-2"><h3 id="在线平台测试">在线平台测试</h3><p>在线平台上使用和仿真相同的种子（32`h2）进行测试，数据地址结果和仿真一致</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/8cb1c6908a93fa71daf6aefa93e0c210/202311042151517.png" alt="image-20231104215127477"></p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/5986d204e51962f1521452d1c096b132/202311042240933.png" alt="image-20231104224025904"></p></li></ul><h2 id="思考题">思考题</h2><ul class="lvl-0"><li class="lvl-2"><h4 id="静态存储器的读和写各有什么特点">静态存储器的读和写各有什么特点</h4></li></ul><p>一般来说，sram需要两周期读，三周期写，因为数据可以直接从存储单元中读取，而写入操作需要额外的周期来准备和执行写入操作。</p><p>两周期读：</p><ul class="lvl-0"><li class="lvl-2"><p>第一个周期：地址传递，选择要读取的存储单元。</p></li><li class="lvl-2"><p>第二个周期：直接从存储单元中读取数据。</p></li></ul><p>三周期写：</p><ul class="lvl-0"><li class="lvl-2"><p>第一个周期：地址传递，确定数据要存储的位置。</p></li><li class="lvl-2"><p>第二个周期：数据准备，将数据加载到内部的写入寄存器。</p></li><li class="lvl-2"><p>第三个周期：执行实际的写入操作，将数据写入存储单元。</p></li><li class="lvl-2"><h4 id="什么是ram芯片输出的高阻态，它的作用是什么？">什么是ram芯片输出的高阻态，它的作用是什么？</h4><p>输出为高阻态表示ram接受fpga的输入而屏蔽自身输出，处于read状态。这样一根引线即可实现输入输出，并且避免了一线两端同时输出导致短接。</p></li><li class="lvl-2"><h4 id="如何实现统一的64位存储器">如何实现统一的64位存储器</h4><p>改变wb_mux实现，不再根据地址选择sram。写入时分别将高低32位和相同地址写入ext和base。读取时从相同地址读取高低32位</p></li></ul><h1>实验五  内存串口实验</h1><pre><code class="language-mermaid">flowchart TBIDLE --&gt;read_wait_acktionsubgraph read_data    read_wait_acktion --&gt;|ack|read_wait_check --&gt;|read_checked|read_data_action --&gt;|ack|read_data_doneendread_data_done --&gt; read_sram_action read_sram_done--&gt;write_wait_acktionread_wait_check --&gt;|!read_checked|read_wait_acktionsubgraph write_sramread_sram_action --&gt;|ack|read_sram_doneendsubgraph write_data    write_wait_acktion --&gt;|ack|write_wait_check --&gt;|write_checked|write_data_action --&gt;|ack|write_data_doneendwrite_data_done --&gt; |cnt&lt;10:cnt++|IDLEwrite_data_done --&gt; |cnt&gt;=10|DONEwrite_wait_check --&gt;|!write_checked|write_wait_acktion&lt;/pre&gt;# 状态描述1. **IDLE状态**：   - 在IDLE状态下，它等待启动信号。   - 如果启动信号有效，状态机将转移到`READ_WAIT_ACTION`状态以开始串口读写。2. **READ_WAIT_ACTION状态**：   - 这个状态是为了向串口发送读取请求。   - 等待串口ACK信号的确认请求已发送。   - 如果确认，状态机将进入`READ_WAIT_CHECK`状态。3. **READ_WAIT_CHECK状态**：   - 这个状态用于检查串口的读状态位。   - 如果读状态位表明串口空闲，状态机将进入`READ_DATA_ACTION`状态。   - 否则，状态机将保持在`READ_WAIT_ACTION`状态，以等待串口变为可用状态。4. **READ_DATA_ACTION状态**：   - 在这里，状态机向串口发送读取数据请求。   - 等待串口ACK信号以确认请求已发送。   - 一旦确认，状态机将进入`READ_DATA_DONE`状态。5. **READ_DATA_DONE状态**：   - 在这个状态，状态机从串口接收数据，并将数据存储在`uart_data`寄存器中。   - 然后，状态机准备将数据写入SRAM，进入`READ_SRAM_ACTION`状态。6. **READ_SRAM_ACTION状态**：   - 这个状态用于将`uart_data`写入到SRAM的地址`temp_sram_addr`中。   - 等待SRAM的ACK信号以确认数据已写入。   - 一旦确认，状态机将进入`READ_SRAM_DONE`状态。7. **READ_SRAM_DONE状态**：   - 在这个状态，状态机向SRAM发送数据，并等待SRAM的ACK信号以确认写入已完成。   - 一旦确认，状态机将进入`WRITE_WAIT_ACTION`状态。8. **WRITE_WAIT_ACTION状态**：   - 这个状态用于向串口发送写入数据请求。   - 等待串口ACK信号以确认请求已发送。   - 一旦确认，状态机将进入`WRITE_WAIT_CHECK`状态。9. **WRITE_WAIT_CHECK状态**：   - 这个状态用于检查串口的写状态位。   - 如果写状态位表明串口空闲，状态机将进入`WRITE_DATA_ACTION`状态。   - 否则，状态机将保持在`WRITE_WAIT_ACTION`状态，以等待串口变为可用状态。10. **WRITE_DATA_ACTION状态**：    - 这个状态用于将`uart_data`写入串口的数据位。    - 等待串口ACK信号以确认数据已发送。    - 一旦确认，状态机将进入`WRITE_DATA_DONE`状态。11. **WRITE_DATA_DONE状态**：    - 在这个状态，状态机完成了一轮的读串口、写SRAM、写串口操作。    - 记录操作轮数的变量`count`加1。    - 更新SRAM地址`temp_sram_addr`以准备下一轮操作。    - 如果`count`超过了4'b1000，状态机将进入`DONE`状态，否则返回到`IDLE`状态。12. **DONE状态**：    - 在这个状态下，状态机停留在DONE状态，表示操作已经完成。- ### 波形仿真  #### 仿真波形  主要关注了向sram写数据的波形，开始时因为we信号错位导致没有正确结果  ![image-20231104222753428](https://gitlab.com/ggx-blog/imglab/uploads/9bca8dd6b3ebb678eb5dfd38294522df/202311042227492.png)  #### 仿真输出  向串口正确输出十个且仅十个字节  ![image-20231104222705082](https://gitlab.com/ggx-blog/imglab/uploads/7cc6c3b7db2e173fd953e0b74fd84dad/202311042227108.png)- ### 云平台实验  拨码开关设为0x80000000（baseram地址）向串口发送10个字节数据，串口输出与内存内容均符合预期  ![image-20231104223728319](https://gitlab.com/ggx-blog/imglab/uploads/875d92f901d2e283e2f40264f46e7d41/202311042237345.png)![image-20231104223718164](https://gitlab.com/ggx-blog/imglab/uploads/fccc834e2876655f3906be9e129d8d61/202311042237192.png)### 思考题不一定`uart-controller`有两个主要的MMIO寄存器：1. **REG_DATA（地址0x00）**：这个是由Master控制的，这个寄存器用于将数据写入UART控制器的发送缓冲区，以便进行串口通信。2. **REG_STATUS（地址0x05）**：这个寄存器用于查询UART控制器的状态信息。通过读取该寄存器，Master可以获取`txd_busy`和`rxd_data_ready`等状态信息，以确定发送和接收是否就绪。这个是由controller自己控制与修改的Q2：为数码管和拨码开关设置与现有映射不重复的地址，并修改wb-mux使其能识别并选择数码管与拨码开关的地址，使得向wb-master中传入内存地址时，wb-master可以根据其选择数码管或拨码开关。</code></pre>]]></content>
      
      
      <categories>
          
          <category> homework </category>
          
          <category> cod </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cod </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/notes/signal_processing/%E4%BA%B2%E7%88%B1%E7%9A%84%E4%B8%81%E5%A5%B3%E5%A3%AB/"/>
      <url>/notes/signal_processing/%E4%BA%B2%E7%88%B1%E7%9A%84%E4%B8%81%E5%A5%B3%E5%A3%AB/</url>
      
        <content type="html"><![CDATA[<h5 id="亲爱的丁女士：">亲爱的丁女士：</h5><p>​我现在一边吃着您送来的糕点，一边写下这些文字。您对我的关怀就像这三角形面包里的巧克力液，柔顺而不甜腻;您对我的支持就像这茶杯蛋糕的花生碎,坚定而不犹豫;我对您的敬仰就像这肉松球里的奶油,热烈而不保留;我对您的感激就像这蛋挞外的酥皮，真挚而不言而不语。</p><p>​如今秋风瑟瑟，但是您温暖的糕点让我的心充满了幸福，愿这个秋天带来更多美好的时刻。</p><p>​     <strong>最幸福的小孩</strong></p><p>​2023/10/21</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/notes/signal_processing/%E4%BF%A1%E6%81%AF%E8%AE%BF%E8%B0%88%E6%8A%A5%E5%91%8A/"/>
      <url>/notes/signal_processing/%E4%BF%A1%E6%81%AF%E8%AE%BF%E8%B0%88%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<h1>信息访谈报告</h1><p>郭高旭 <a href="mailto:ggx21@mails.tsinghua.edu.cn">ggx21@mails.tsinghua.edu.cn</a> 2021010803</p><h2 id="受访者基本信息">受访者基本信息</h2><p>受访人：王国辉</p><p>单位：普天信息技术研究院</p><p>研究方向：机电一体化方面，芯片工艺相关</p><p>联系渠道：职业发展中心校友导师</p><h2 id="面谈方式">面谈方式</h2><p>日期：2023年10月21日</p><p>方式：线上腾讯会议</p><p>时长：16：00 - 17：00 ， 1小时</p><h2 id="面谈内容总结">面谈内容总结</h2><h5 id="问题：-您当初为什么选择了信息技术领域，为此做了哪些准备？"><strong>问题：</strong> 您当初为什么选择了信息技术领域，为此做了哪些准备？</h5><p><strong>回答：</strong> 我选择信息技术领域的原因是因为我在2003年毕业时，主修了机电一体化和芯片工艺相关的专业，但我对信息技术领域有浓厚的兴趣，特别是手机制造领域当时非常热门。</p><h5 id="问题：-您在入职时主要负责的项目与工作内容是什么，当时满意自己的工作吗？"><strong>问题：</strong> 您在入职时主要负责的项目与工作内容是什么，当时满意自己的工作吗？</h5><p><strong>回答：</strong> 我非常乐意进入信息技术行业，因为我一直对这个领域充满兴趣。入职时，我主要负责了与诺基亚合作的项目，我们开发了一款世界上最小的手机。虽然这个项目需要学习国外技术，加班辛苦，但我感到非常满足。</p><h5 id="问题：-有没有令您印象最深的项目或成就，这给您带来了什么影响？"><strong>问题：</strong> 有没有令您印象最深的项目或成就，这给您带来了什么影响？</h5><p><strong>回答：</strong> 最令我印象深刻的项目是与诺基亚合作，为其进入国内市场开发世界上最小的手机。当时国内通信技术水平有限，大部分技术受国外掌握。我们不仅自主开发了软硬件，还学习了国外技术。这个项目让我体验到了挑战与快乐，也展示了我的技术能力。</p><h5 id="问题：-新入职的年轻人薪资待遇如何？"><strong>问题：</strong> 新入职的年轻人薪资待遇如何？</h5><p><strong>回答：</strong> 新入职的年轻人在信息通信行业薪资相对较好，因为这是一个实业领域，相对于金融等其他领域来说更稳定。薪资待遇会根据企业类型有所不同。国企央企薪资可能有一些限制，但依然可以达到<strong>三五十万</strong>。民企的薪资则不受太多限制，但会根据企业的具体情况而异。初入职场时不要一开始就过于追求高薪，要先打好职业基础，薪资会逐渐增长。</p><h5 id="问题：-薪资构成可能是什么样的？"><strong>问题：</strong> 薪资构成可能是什么样的？</h5><p><strong>回答：</strong> 薪资构成取决于所在企业的性质。大多数国企没有股票激励计划，因为国企上市较为谨慎。但在民企特别是科创企业，如果企业业绩出色，可能会提供股票激励计划。这意味着在创业中，你可能会取得成功并获得财务自由，或者可能会面临失败。因此，薪资构成会因企业和个人情况而异。</p><h5 id="问题：-从我的专业来说，我有哪些可能的职业选择？"><strong>问题：</strong> 从我的专业来说，我有哪些可能的职业选择？</h5><p><strong>回答：</strong> 根据你的专业背景，有多种职业选择。本科生通常会更容易进入企业，而研究所和大专院校则可能需要更多的时间来晋升到重要职位。在信息技术领域，你可以选择进入企业、研究所，如中科院电子所，或从事政府部门工作。不过，政府部门可能无法充分体现你的专业优势。</p><h5 id="问题：-读研与否对我的就业又哪些影响呢？"><strong>问题：</strong> 读研与否对我的就业又哪些影响呢？</h5><p><strong>回答：</strong> 读研可以提高你的竞争力，尤其是在信息技术领域，因为本科生数量众多。拥有硕士或博士学历将为你提供更多职业选择，以及更高的职业晋升机会。</p><h5 id="问题：-如果我想进入大厂的开发岗，我的主要工作内容会是什么，为此我应该进行哪些准备？"><strong>问题：</strong> 如果我想进入大厂的开发岗，我的主要工作内容会是什么，为此我应该进行哪些准备？</h5><p><strong>回答：</strong> 如果你想进入大厂的开发岗位，你可能会面临两种主要方向，即软件开发和硬件开发（例如微型计算机电路板）。对于本科生来说，你可以在专业上保持相对广泛的学习，稍后再在硕士研究中选择特定领域。在计算机领域，可以学习操作系统、计算机架构和汇编编程等内容，这将有助于你理解不同系统的通用逻辑。</p><h5 id="问题：-进入公司的过程是怎样的？"><strong>问题：</strong> 进入公司的过程是怎样的？</h5><p><strong>回答：</strong> 进入公司的过程通常包括以下步骤：（以普天为例）</p><ol><li class="lvl-3"><p>投简历：首先需要向公司投递个人简历。</p></li><li class="lvl-3"><p>面试邀请：如果人力资源部门看中了你的简历，他们会邀请你参加面试。</p></li><li class="lvl-3"><p>面试内容一：第一轮面试通常涵盖以下内容：</p><ul class="lvl-2"><li class="lvl-5">你曾经参与过哪些项目？</li><li class="lvl-5">你学习过哪些课程？</li><li class="lvl-5">你的毕业课题是什么？</li><li class="lvl-5">面试官也会考察你的诚实度和工作扎实度。</li></ul></li><li class="lvl-3"><p>面试内容二：第二轮面试可能会更深入，测试你的专业知识和技能。</p></li><li class="lvl-3"><p>面试内容三：最后可能会谈论合同和入职细节。</p></li></ol><h5 id="问题：-我应如何保持自己在科技行业的竞争力？"><strong>问题：</strong> 我应如何保持自己在科技行业的竞争力？</h5><p><strong>回答：</strong> 保持竞争力的关键在于以下几点：</p><ul class="lvl-0"><li class="lvl-2"><p>大三或研究生阶段可能会感到迷茫，但不要低估本科阶段学到的东西。将计算机技术视为工具，而不是行业，有助于更好地理解其应用领域。</p></li><li class="lvl-2"><p>学习是一个不断进行的过程。在工作中学到的知识通常会证明本科学的东西都有用处。不断更新技能，关注行业趋势，参加培训和课程，以保持竞争力。</p></li></ul><h5 id="问题：-对于可能即将步入工作的年轻人，您有什么想说的？"><strong>问题：</strong> 对于可能即将步入工作的年轻人，您有什么想说的？</h5><p><strong>回答：</strong> 针对即将进入职场的年轻人，以下是一些建议：</p><ul class="lvl-0"><li class="lvl-2"><p>根据家庭背景、社会情况和国家发展趋势，培养一定的社会责任感。</p></li><li class="lvl-2"><p>打好基本功是非常重要的。计算机技术可以与各行各业结合，因此扎实的基础知识至关重要。</p></li><li class="lvl-2"><p>自信也是成功的关键。相信自己的能力，踏实地工作，保持正确的价值观，会帮助你在职业生涯中取得成功。</p></li></ul><h5 id="问题：-企业如此众多，如何选择适合自己的？"><strong>问题：</strong> 企业如此众多，如何选择适合自己的？</h5><p><strong>回答：</strong> 选择适合自己的企业需要仔细考虑，以下是一些指导建议：</p><ul class="lvl-0"><li class="lvl-2"><p>首先，确定是要去国企还是民企。对于国企，最后选择的企业可能会与你研究生阶段的课题和研究方向相关。</p></li><li class="lvl-2"><p>在研究生阶段，包括现在开始，了解不同企业，制定长远的规划，并深入了解相关信息，然后再做选择。</p></li><li class="lvl-2"><p>一些知名的技术类企业包括中电科、普天、大唐和烽火。</p></li><li class="lvl-2"><p>移动、联通和电信也有自己的研究院，提供技术相关的工作。</p></li><li class="lvl-2"><p>一些金融行业也需要计算机专业的人才，但进入四大行等大型金融机构可能会让你感觉专业技能用处不大，因为这些机构更注重学历。</p></li><li class="lvl-2"><p>航天等领域的部门也需要计算机专业人才，这是另一个可能的选择。</p></li></ul><h2 id="个人感受">个人感受</h2><p>本次交流让我收获良多。我本人其实在过去的两年没有进行过什么职业探索，对未来也比较迷茫。校友导师非常真诚，也考虑到了我的经验比较少，非常耐心地回答我的各类问题。</p><p>令我印象最深刻的是校友导师分享自己的职业选择经历，他从高中开始就对电子通信领域比较感兴趣，大学研究生时期也对自己研究的方向比较认同。毕业后顺利进入了和自己研究方向匹配的行业，因而有较高的职业满意度。我认为我的经历可能和他比较相似。了解了校友导师的求职经历也减轻了我的焦虑与迷茫。</p><p>校友导师总体上还是非常推荐我继续深造，一方面可以提高我的就业竞争力，另一方面也让我有一个专精的领域。我们的交流基本上建立在继续深造的前提上。我也很受校友导师在人生观方面的触动，比如校友导师从他在国企的工作的社会意义也得到了许多获得感。</p><p>但是我还有一些问题没有得到解决，期待下次与校友导师的交流。比如校友导师谈到具体的职业方向可以根据研究生的研究方向决定，但是我会希望通过具体的职业方向指导我研究生方向的选择。还有一些具体的求职准备。</p><p>总体上非常感谢校友导师以及这次机会，以后肯定会再次使用这个平台。</p><ul class="lvl-0"><li class="lvl-2"><p>您当初为什么选择了信息技术领域， 为此做了哪些准备？</p><p>2003年毕业，在学校作机电一体化方面，芯片工艺相关。对信息行业比较感兴趣。做手机。当时做手机还是比较火的</p></li><li class="lvl-2"><p>您在入职时主要负责的项目与工作内容是什么， 当时满意自己的工作吗？</p><p>很乐意进入这个行业，对这个很感兴趣。从高中起就很干兴趣</p></li><li class="lvl-2"><p>有没有令您印象最深的项目或成就， 这给您带来了什么影响？</p><p>当时诺基亚要进入国内，跟诺基亚进行合作。当时国内通信技术能力比较差，许多技术被国外掌握。在守信做了一款世界上最小的手机。一边学习国外，一边开发研究，所有的软硬件都是自己开发的。当时也加班。累并快乐着。</p></li><li class="lvl-2"><p>新入职的年轻人薪资待遇如何？</p><p>至少信息通信行业还是属于头部行业，以前金融很火，但是现在不行了，因为不是实业。但是通信电子计算机是实业。而且至少比其他传统行业好很多。还在中年，没到老年，没到没落的时候</p><p>待遇分企业：</p><p>国企央企不会太高，但三五十万肯定会有。（国企央企有一些限制）</p><p>民企不受限制，但是也分企业。</p><p>不要一开始就想着工资很好，开始打好基础，后期会慢慢的调。</p><p>国企受一点限制，但是胜在比较稳定。福利待遇也比较好。</p><p>进入了不好的民企肯能不稳定，刚进去有高工资，但是行业不太好的时候可能降工资或者裁员。</p><p>如果比较喜欢挑战，可以选择民企。</p><p>比较喜欢按部就班的生活，可以选择国企。国企</p></li><li class="lvl-2"><p>薪资构成？</p><p>看进的企业：大多数国企没有股票激励，国企上市比较谨慎。</p><p>但是民企尤其是科创企业，如果是做的很好（奔着上市“圈钱”的目的），可能发股票激励。可能创业成功，财富自由，也可能创业失败。</p><p>还是看人，如果喜欢风险，加上家庭兜底，可能选择民企。</p></li><li class="lvl-2"><p>从我的专业来说， 我有哪些可能的职业选择？</p><p>本科生进企业多一些，进研究所或大专院校比较吃亏。到一个企业可能不会立马做一些重要的活</p><p>研究所，大专院校。中科院电子所，自动化，航天搞通信与计算等的研究所等。</p><p>进企业的流程：工程师-高级工程师-资深工程师-项目、部门经理-主管技术的经历</p><p>开发或者研究</p><p>政府部门：比较吃亏，专业优势体现不出来</p></li><li class="lvl-2"><p>读研与否对我的就业又哪些影响呢？</p><p>本科生很多，读研可以提高自己的竞争力。有一个硕博的学历会有更多的选择，台阶更高。</p></li><li class="lvl-2"><p>如果我想进入大厂的开发岗， 我的主要工作内容会是什么， 为此我应该进行哪些准备？</p><p>以普天为例：</p><p>计算机系同学面临两种方式：偏软件coding还有偏硬件（微型计算机的电路板）。</p><p>研究生以后，专业的分类比较细，比如偏硬件还是偏软件。</p><p>如何应对呢？对于本科生来说，可以不用那么专，可以广泛学一点，到了硕士再选择某一个行业。计算机系可以多学一点操作系统，计算机架构，汇编编程等。</p><p>学习汇编编程可以理解不同系统的统一的逻辑。</p></li><li class="lvl-2"><p>进入公司的过程</p><p>投简历-人力看到简历邀请面试-面试内容：</p><p>一面</p><ul class="lvl-2"><li class="lvl-4"><p>做过什么项目</p></li><li class="lvl-4"><p>学过什么课程</p></li><li class="lvl-4"><p>做的课题是什么</p></li><li class="lvl-4"><p>看这个人诚不诚实，扎不扎实</p></li></ul><p>二面：</p><p>三面：谈合同</p></li><li class="lvl-2"><p>我应如何保持自己在科技行业的竞争力？</p><p>大三或者研究生会比较迷茫。许多同学认为本科阶段学的东西没什么用。只有研究生或者真正到了工作岗位才能真正知道本科学的东西有什么用。</p><p>把计算机当成一个工具，而不是一个行业。这样就不会感觉学了的东西没有用。</p></li><li class="lvl-2"><p>对于可能即将步入工作的年轻人， 您有什么想说的？</p></li></ul><p>​根据自己的家庭背景、社会情况，国家的动向，为国家做事有一些社会责任感。</p><p>基本功打好了比较要紧，计算机可以跟各种行业结合。</p><p>本科孩子一定要好好打基础，而且一定要自信。</p><p>只要踏踏实实地做，三观比较正，一直走下去肯定会有一个比较好的状态。</p><ul class="lvl-0"><li class="lvl-2"><p>企业这么多，如何做出选择，看哪些方面。</p><p>自己首先要想好是去国企还是民企。对于国企来说，没有哪个企业专门做计算机，看最后研究生的时候研究的课题与研究的方向。</p><p>在研究生阶段包括现在就开始摸索，了解企业。做长远的规划，把信息摸透了再做规划</p><p>中电科，普天，大唐，烽火：纯技术类的</p><p>移动，联通，电信也有设研究院，做技术一类的工作。</p><p>一些金融型行业也要求计算机行业。但是进入四大行之类的有点亏，学了的东西用不上，虽然工作很低级，但是由于学历水涨船高，也要求高水平人才。</p><p>航天一类的部门</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>课程论文</title>
      <link href="/homework/flower_identification/%E6%A4%8D%E7%89%A9%E4%B9%9F%E4%BC%9A%E8%AF%B4%E8%AF%9D%E6%B5%85%E8%B0%88%E6%A4%8D%E7%89%A9%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BA%A4%E6%B5%81/"/>
      <url>/homework/flower_identification/%E6%A4%8D%E7%89%A9%E4%B9%9F%E4%BC%9A%E8%AF%B4%E8%AF%9D%E6%B5%85%E8%B0%88%E6%A4%8D%E7%89%A9%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BA%A4%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h1>植物也会说话？浅谈植物之间的交流</h1><p>交流是人类乃至动物日常生活中不可缺少的一部分。通过交流，动物与周遭世界进行互动：分享思想、交配求偶、宣告领地、报告危险······动物之间的交流是生态系统中不可或缺的一部分，它有助于维持物种的生存和生态平衡。但是，看似安安静静的植物，其实也在通过这样或那样的方式与它的邻居们产生着精彩纷呈的交流互动。</p><p>下面将深入探讨几种典型的植物间交流方式，令我们更加深刻地理解这个神奇的植物世界。不同植物之间的交流并不同于动物的语言，但它们通过挥发性有机化合物、根系互动、甚至寄生植物等方式，建立其自己的“通讯网络”，以自己独特的方式传递信息、合作共生，甚至进行竞争。这种微妙的植物交流对于生态系统的平衡和植物自身的生存至关重要。让我们一起探索这个植物王国中隐藏的奇妙交流世界。</p><h2 id="VOCs">VOCs</h2><p>释放挥发性气体 （volatile organic compounds VOCs）是植物间进行交流的重要方式。有些挥发性气体可能是植物生长发育过程中产生的代谢废物，但也有许多挥发性气体具有重要的信号功能作用。<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>这些气体分子通常承担重要的角色，其中一种用途是作为警告信号，告知其他植物有潜在的威胁。它们还可以起到吸引天敌昆虫的作用，以保护自身免受害虫的侵害。此外，这些气体分子还可以用来驱避食草昆虫或病原菌，帮助植物保持健康。<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p><h4 id="vocs信号在植物间的传递过程">vocs信号在植物间的传递过程</h4><p>vocs信号在植物间的传递包括以下4个步骤：首先，植物会释放VOCS，这些化合物散发到周围的空气中。VOCS的释放分为两种方式：组成型化合物在植物受到机械损伤后被动释放，而诱导型化合物在植物受到昆虫为害（包括由昆虫为害导致的病原体侵染）后主动释放。<sup class="footnote-ref"><a href="#fn1" id="fnref1:1">[1:1]</a></sup>随后，这些挥发性有机化合物在大气中传输，随风飘荡，或者通过水流在地表或地下传播，将植物的信息携带到远处。然后，这些气体在其他植物表面进行吸附，落在叶片和茎上，等待着下一步的事件。在光照条件下，接受植物气孔增大，气体进入植物体过程中浓度降低很少，促进了信号传播。最后，接收植株会感知这些VOCS，解读它们所携带的信息，以在基因表达或者代谢层面采取适当的响应措施。这一过程展示了植物之间复杂而微妙的交流方式，通过挥发性有机化合物在大自然中传递信息和互动。</p><h4 id="vocs信号的作用机制">vocs信号的作用机制</h4><p>一些植物在受到胁迫时（创伤，植食性昆虫捕食，或环境胁迫等），释放创伤诱导型挥发物（wound-inducible volatiles WIVs）如茉莉酸甲酯以及水杨酸甲酯等。这些挥发物可帮助植物防御昆虫，提高抗病性，并传递信息给健康植株，诱导它们对未来可能到来的侵害及时做好准备。<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup> 另一类挥发性气体是绿色植物叶片气孔释放的绿叶挥发物（Green leaf volatiles，GLVs）。茉莉酸和乙烯可以通过作用于植物抗病性基因，提高植物抗病性。$H_2S$也是重要的一类挥发性物质，在提高应对多种胁迫能力以及加速某些植物种子萌发，根形态建成， 幼苗叶绿素含量和光合作用相关基因表达方面有重要作用。<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup><sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup></p><p>有趣的是，VOCs的释放还具有特异性。同一种昆虫取食不同类群的植物时，VOCs的成分构成与释放浓度不同。不同种昆虫乃至同种昆虫不同龄期的幼虫取食同种植物时，植物的反应也不同，如菜豆被成年潜叶蝇与其二龄幼虫为害后诱导释放的 VOCs有明显的不同。接受信号的植物可以分辨出不同的VOCs信号，进而采取特异性的防御策略。</p><h3 id="丛枝菌根">丛枝菌根</h3><p>在植物世界中，还有一种非常重要的互动方式，涉及到根系、分泌物和微小的土壤生物。这种互动方式被认为在植物相互交流中扮演着重要的角色。首先，要了解这个过程，我们需要认识一下菌根真菌，它们是一类特殊的微生物，存在于土壤中。其中一种叫做丛枝菌根真菌（Arbuscular mycorrhizal fungi，AMF）的微生物在陆地生态系统中非常常见。这个有趣的事实是，绝大多数陆地上的植物都可以与这种丛枝菌根真菌建立一种合作关系，这种合作关系被称为互惠共生关系。这种互惠共生关系是怎么运作的呢？首先，植物的根系与这些菌根真菌的细长丝状结构相互交织在一起，就像植物的根和真菌之间建立了一种由菌丝网络微小的桥梁。这种微小桥梁不仅可以供营养物质的转运，比如丛枝菌根真菌可以促进植物磷和氮的吸收，植物为真菌提供糖和脂质营养物质等。</p><p>由于AMF可以无性繁殖且不具备宿主特异性，它们可以与不同种植物建立互惠共生关系，而同种或不同种植物之间的AMF菌丝可以相互连接，形成公共菌丝网络（CMNs）<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>。CMNs在植物间的竞争、养分资源的再分配以及地下化学信号传递等方面扮演着不可替代的角色。因此，CMNs已经引起了科学家的广泛研究兴趣。<sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup></p><h4 id="CMNs的形成">CMNs的形成</h4><p>CMNs是一种复杂的菌丝网络，由AMF（丛枝菌根真菌）的外生菌丝与植物根系形成。在自然生态系统中，植物和AMF之间没有特异性的互相识别，因此，当AMF的外生菌丝接触到其他植物根系时，它们可以再次侵染并形成植物之间的菌丝联系。这样，每棵植物就像一个供给站，AMF的菌丝不断向外延伸，最终形成密集的菌丝网络。<sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup></p><h4 id="CMNs作用机制的例子">CMNs作用机制的例子</h4><h5 id="1-CMNs-在植物间取食预警信号交流中的作用机制">1.CMNs 在植物间取食预警信号交流中的作用机制</h5><p>CMNs作为信号传导通道，参与植物间的取食预警信号传递。Babikova 等<sup class="footnote-ref"><a href="#fn9" id="fnref9">[9]</a></sup>发现，当植物被蚜虫啃食时，通过CMNs相连的，未被啃食的植物也能够释放出前面提到的一些具有抗虫作用的VOCs。此外，Song 等<sup class="footnote-ref"><a href="#fn10" id="fnref10">[10]</a></sup>研究发现，仅仅移植丛枝菌根真菌并不能增强系统防御反应，但是CMNs的存在可以激活叶片中的系统反应区，这说明CMNs具备在植物之间传递防御信号的作用。</p><h5 id="2-CMNs在植物间竞争信号交流中的作用机制">2.CMNs在植物间竞争信号交流中的作用机制</h5><p>不同的植物之间存在竞争，往往通过化感物质（ allelochemicals）干扰其他植物的生长。通常情况下土壤会阻拦化感物质的扩散，而CMNs可以穿过土壤，防止化感物质在土壤中被稀释，这突出了 CMNs 在植物间竞争信号物质运输的重要性。Barto等研究了一种名为万寿菊的植物释放的一种名为噻吩的化感物质。他们发现这种化感物质能够通过地下的菌丝网络，也就是CMNs，传输到附近的莴苣植物。这导致了莴苣植物的死亡率明显增加。在自然环境中，CMNs的存在也在促进另一种名为胡桃醌的化感物质的传播方面发挥了重要作用。胡桃醌对目标植物的生长产生了抑制作用。这意味着CMNs可以在植物间传输化感物质，改变周围植物的生长状况，甚至导致某些植物的死亡。</p><h5 id="3-CMNs-在植物间病害预警信号交流中的作用机制">3.CMNs 在植物间病害预警信号交流中的作用机制</h5><p>CMNs还可以激活在邻近的未受感染的植物防御系统。Alaux等的研究表明，当一株马铃薯患上了某种病原菌感染，例如晚疫病原菌，它会通过CMNs释放一种信号，这个信号可以在短短的24小时内传递给周围的未受感染的马铃薯植株。这个信号激活了健康植物内部的一些特殊基因，这些基因与VOCs途径相关。这个过程使未受感染的植物准备好，以防备病原菌的攻击。此外，其他研究还发现，CMNs不仅可以增强受到特定病原菌（比如Alternaria solani）侵染的植株的抵抗力，还可以提高附近健康植物中一些重要酶的活性，如3-葡聚糖酶、苯丙氨酸氨解酶和脂氧合酶，同时激活相关的防御系统基因的表达。这意味着CMNs可以帮助植物增强其免疫系统，使它们更有能力对抗病原菌的入侵，从而保护整个植物群体的健康。</p><h3 id="寄生植物与寄主植物的信息交流">寄生植物与寄主植物的信息交流</h3><p>大多数植物都是自养植物。它们通过光合作用将大气中的CO2固定为它们的生长和发育的唯一碳源。然而，一些自养植物已经进化成寄生植物，这些寄生植物从其他植物获取水和养分。一些寄生植物，被称为全寄生植物，不再能够进行光合作用，因此不含叶绿素，而另一些被称为半寄生植物，是绿色的且仍能够进行光合作用。菟丝子属（Cuscuta，旋花科），它们几乎没有或没有光合活动，通常被认为是全寄生植物，通过吸器（haustorium），来附着并侵入寄主组织。在单个植物中，韧皮部在运输信号分子方面起着重要作用<sup class="footnote-ref"><a href="#fn11" id="fnref11">[11]</a></sup>，菟丝子会在它们的吸器和寄主茎或根之间形成韧皮部融合。因此，非常有可能在吸器-寄主界面之间发生植物间系统信号传递，影响寄生植物及其寄主的生理和生态。<sup class="footnote-ref"><a href="#fn12" id="fnref12">[12]</a></sup></p><h4 id="3-2-寄主与寄生植物之间的植物间信号传递">3.2. 寄主与寄生植物之间的植物间信号传递</h4><p>食草动物在菟丝子上的取食可以激活寄主植物中的防御性反应。Zhuang等人<sup class="footnote-ref"><a href="#fn13" id="fnref13">[13]</a></sup>发现，绿桃蚜（Myzus persicae）在菟丝子上的侵害导致大豆寄主中超过1,000个差异表达基因（DEGs），当随后受到蚜虫或毛虫的侵害时，大豆寄主表现出增强的抵抗力。有趣的是，寄主表达抵抗力基因对菟丝子对昆虫取食的正常反应是必需的，这表明在昆虫取食期间，菟丝子和它的寄主植物可能存在双向信号传递，也就是说，不仅受胁迫的植物不仅向其他植物发送信号，而且其他植物也向受胁迫的植物发送信号，这种信号的双向交换被认为是连续和动态的。</p><h4 id="3-3通过寄生植物连接的不同寄主植物间的信号传递">3.3通过寄生植物连接的不同寄主植物间的信号传递</h4><p>在一株菟丝子生长期间，如果距离足够近，它的茎上会形成许多分枝，这些分枝可以寄生到附近的植物上。因此，很多时候，一株菟丝子可以同时寄生多个寄主，形成菟丝子连接的植物群。通过菟丝子连接，植物被虫害诱发的系统信号被发现可以从受虫害的植物传播到其他寄主。Hettenhausen等人<sup class="footnote-ref"><a href="#fn14" id="fnref14">[14]</a></sup>使用一株菟丝子（Cuscuta australis）将两株大豆植物连接起来，当斑潜蝇（Spodoptera litura）昆虫袭扰其中一株大豆植物时，这种袭扰导致另一株完好的大豆植物中有550多个差异表达的基因（DEGs），表明来自受虫害的大豆植物的系统信号能够传播到未受虫害的大豆植物。Lei等人创建了由植物对组成的菟丝子连接的植物群，这些植物对在系统发育上差异很大。这些内容都说明菟丝子可以在不同寄主之间传递生态上有意义的移动信号。</p><h3 id="总结与展望">总结与展望</h3><p>挥发性有机化合物（VOCs）在植物间起到了多种作用，包括警告信号、吸引天敌昆虫、防御昆虫和病原菌等。VOCs的传递过程包括释放、传输、吸附和感知，这一复杂的过程展示了植物之间微妙的交流方式。不同种类的植物可以分辨出不同的VOCs信号，采取特异性的防御策略，这有助于它们在生态系统中适应和竞争。丛枝菌根真菌（AMF）在植物根系中建立的互惠共生关系通过形成菌丝网络促进了养分交换和信号传递。这种网络可以在植物间传递取食预警信号、竞争信号和病害预警信号。它有助于植物增强抵抗力，保护植物群体的健康。寄生植物与寄主植物之间也存在复杂的信息交流。受虫害的植物可以通过菟丝子与其他寄主植物共享系统信号，这种双向信号传递在植物群体中是连续和动态的。这种信号传递还可以跨越不同寄主植物之间的连接，影响生态系统中的多个植物。</p><p>在未来，这些研究对农业生产和生态系统管理可能具有重大帮助。例如，了解植物之间的交流方式可以帮助优化植物的防御机制，提高抗病虫害的能力，从而减少农业化学农药的使用。此外，利用丛枝菌根真菌的合作关系，可以改善植物的养分吸收效率，提高作物产量。对寄生植物与寄主植物之间的信息交流的深入了解，有望帮助管理寄生植物的传播和影响。</p><p>总之，植物之间的交流研究为农业、生态系统保护和可持续农业生产提供了重要的见解和展望，有望在未来的农业和环境管理中发挥关键作用。</p><h3 id="交流的不同方式：">交流的不同方式：</h3><p>VOCs，根系分泌物，地下菌群，菟丝子。</p><h3 id="交流的目的">交流的目的</h3><p>防御虫害，抵抗异种植物入侵，</p><p>作用，通过研究植物之间的交流来促进农业生产：Root ethylene mediates rhizosphere microbial community reconstruction when chemically detecting cyanide produced by neighbouring plants</p><p>空气中挥发性有机物(VOCs)与植物根系分泌物之间的化学相互作用在植物之间的相互作用中起着重要作用。对这些化学信号的反应，一株植物可以表现出多种适应性反应。豚草(Ambrosia artemesiifolia L.)是当今农业生产中最为棘手的外来入侵物种之一，给各种作物造成了严重的产量损失。鉴于对这种入侵者的化学线索如何促进其入侵性知之甚少，我们研究了普通豚草释放的空气中 VOCs 和根分泌物对小麦、大豆和玉米生长和分配模式的影响，以及这些作物对普通豚草的影响。豚草释放的挥发性有机物使大豆和小麦的地上干物质显著减少，而玉米的生物量产量没有变化。相比之下，豚草本身在接触作物或同种植物时完全不受影响。结果表明，豚草的挥发性有机物(VOCs)对植物的生物量、比叶面积、叶绿素含量等性状有显著影响，这些性状的变化可能与逆境胁迫的增加有关。根系选择试验表明，所有作物和豚草均显著避免了普通豚草根系的分泌物，表明根系分泌物作为地下线索在豚草和作物化学反应中起着重要作用。本研究表明，植物对地上或地下化学线索的反应不仅高度依赖于存在，而且依赖于指出植物-植物交流复杂性的邻居的同一性。</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>植物挥发性气体研究进展 <a href="#fnref1" class="footnote-backref">↩︎</a> <a href="#fnref1:1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>植物创伤诱导的挥发物及其信号功能 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p>Tscharntke T， Thiessen S， Dolch Ｒ， et al． Herbivory， induced resistance， and interplant signal transfer in Alnus <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p>Zhang H， Tang J， Liu X P， et al． Hydrogen sulfide promotes root organogenesis in Ipomoea batatas， Salix matsudana and Glycine max［J］ ． Journal of Integrative Plant Biology， 2009， 51( 12) : 1086 － 1094 <a href="#fnref4" class="footnote-backref">↩︎</a></p></li><li id="fn5" class="footnote-item"><p>H 2 S 作为植物个体间交流的气体信号分子 <a href="#fnref5" class="footnote-backref">↩︎</a></p></li><li id="fn6" class="footnote-item"><p>Steidinger BS， Crowther TW， Liang J， et al． Climatic controls of decomposition drive the global biogeography of forest-tree symbioses． Nature， 2019， 571: 404－408 <a href="#fnref6" class="footnote-backref">↩︎</a></p></li><li id="fn7" class="footnote-item"><p>丛枝菌根菌丝网络在植物互作中的 作用机制研究进展 <a href="#fnref7" class="footnote-backref">↩︎</a></p></li><li id="fn8" class="footnote-item"><p>Heijden MGAVD， Horton TＲ． Socialism in soil? The importance of mycorrhizal fungal networks for facilitation in natural ecosystems． Journal of Ecology， 2010， 97: 1139－1150 <a href="#fnref8" class="footnote-backref">↩︎</a></p></li><li id="fn9" class="footnote-item"><p>Babikova Z， Gilbert L， Bruce TJA， et al． Underground signals carried through common mycelial networks warn neighbouring plants of aphid attack． Ecology Letters， 2013， 16: 835－843 <a href="#fnref9" class="footnote-backref">↩︎</a></p></li><li id="fn10" class="footnote-item"><p>Song YY， Ye M， Li CY， et al． Hijacking commonmycorrhizal networks for herbivore-induced defence signal transfer between tomato plants． Scientific Ｒeports， 2014，4， doi: 10．1038/srep03915 <a href="#fnref10" class="footnote-backref">↩︎</a></p></li><li id="fn11" class="footnote-item"><p>Notaguchi M, Okamoto S. 2015. Dynamics of long-distance signaling via plant vascular tissues. Front. Plant Sci. 6:161 <a href="#fnref11" class="footnote-backref">↩︎</a></p></li><li id="fn12" class="footnote-item"><p>Between-Plant Signaling <a href="#fnref12" class="footnote-backref">↩︎</a></p></li><li id="fn13" class="footnote-item"><p>Zhuang H, Li J, Song J, Hettenhausen C, Schuman MC, et al. 2018. Aphid (Myzus persicae) feeding on the parasitic plant dodder (Cuscuta australis) activates defense responses in both the parasite and soybean host. New Phytol. 218:1586–96 <a href="#fnref13" class="footnote-backref">↩︎</a></p></li><li id="fn14" class="footnote-item"><p>Hettenhausen C, Li J, Zhuang H, Sun H, Xu Y, et al. 2017. Stem parasitic plant Cuscuta australis(dodder) transfers herbivory-induced signals among plants. PNAS 114:E6703–9 <a href="#fnref14" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> homework </category>
          
          <category> 花卉鉴赏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> homework </tag>
            
            <tag> 花卉鉴赏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组成原理笔记</title>
      <link href="/notes/computer_orgnization/bus/"/>
      <url>/notes/computer_orgnization/bus/</url>
      
        <content type="html"><![CDATA[<h1>总线协议</h1><p>用 Master 和 Slave 来表示总线上的发送方和接收方：</p><ul class="lvl-0"><li class="lvl-2"><p>Master 设置 valid_o=1，等待 Slave 设置 ready_i=1</p></li><li class="lvl-2"><p>Slave 完成操作后，设置 ready_i=1</p></li><li class="lvl-2"><p>valid_o=1 &amp;&amp; ready_i=1 表示完成了一次请求</p></li></ul><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/3ee8a59eb78d38c6f075225d00413dae/202310202053601.png" alt="RISC-V 指令格式"></p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
          <category> cod </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cod </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hw1</title>
      <link href="/homework/vlsi/hw1/"/>
      <url>/homework/vlsi/hw1/</url>
      
        <content type="html"><![CDATA[<h1>hw-1</h1><p>郭高旭 <a href="mailto:ggx21@mails.tsinghua.edu.cn">ggx21@mails.tsinghua.edu.cn</a> 2021010803</p><h3 id="vlsi的发展，vlsi设计的发展，EDA发展阶段、特点、三者之间的关系">vlsi的发展，vlsi设计的发展，EDA发展阶段、特点、三者之间的关系</h3><h5 id="vlsi的发展：">vlsi的发展：</h5><p>自1959年集成电路在TI和Fairchild诞生以来，经历了SSI，MSI，LSi，VLSI，ULSI的发展历程，目前已进入SOC时代。基本遵循摩尔定律，集成电路的集成度每3年翻一番，集成电路技术正在迅速地向着更高集成度、超小型化、高性能、高可靠性的方向发展。</p><h5 id="vlsi设计的发展：">vlsi设计的发展：</h5><ol><li class="lvl-3"><p>20 世纪 60 70 年代的初级集成电路硬件设计时期：针对SSI，MSI的，可设计各种逻辑门、触发器、计数器、寄存器和编译码器等</p></li><li class="lvl-3"><p>20 世纪 70 80 年代的集成电路的软件编程设计时期：集成电路设计主要是微处理器、随机存储器和只读存储器，使用由汇编语言或高级语言编制的程序去调试系统。</p></li><li class="lvl-3"><p>20世纪80 90年代的专用集成电路和系统集成设计时期。  借助于电子产品自动化设计工具</p></li></ol><h5 id="EDA的发展">EDA的发展</h5><ul class="lvl-0"><li class="lvl-2"><p>1970年代：最早的EDA工具出现，用于原理图设计和模拟。</p></li><li class="lvl-2"><p>1980年代：EDA工具开始支持综合、布局和时序分析。自动综合器的出现是EDA技术的第二次突破性进展</p></li><li class="lvl-2"><p>1990年代：EDA工具变得更加综合和集成，支持更复杂的设计流程。全面支持电子系统设计自动化.</p></li><li class="lvl-2"><p>2000年代以及之后：EDA工具不断进化，支持了深亚微米和纳米技术的设计挑战，如多核处理器和低功耗设计。</p></li></ul><h5 id="三者之间的关系：">三者之间的关系：</h5><ul class="lvl-0"><li class="lvl-2"><p>集成电路设计技术要适应工艺技术的发展，VLSI和VLSI设计的发展推动了EDA工具的不断演进。EDA工具为VLSI设计提供了必要的自动化和分析工具，使得设计更容易、更快速，同时也更可靠。</p></li><li class="lvl-2"><p>EDA工具在不同设计阶段提供支持，包括逻辑设计、综合、布局和时序分析。设计者使用这些工具来验证和优化其电路设计。</p></li><li class="lvl-2"><p>EDA工具还在VLSI设计和制造之间建立了桥梁，协助将设计转化为实际的硅片。</p></li></ul><h3 id="集成电路的层次设计步骤">集成电路的层次设计步骤</h3><p>集成电路的层次设计分为自顶向下的设计和自底向上的设计两种</p><p>自顶向下的设计可以分为下面6步</p><ol><li class="lvl-3"><p>行为级设计</p><p>将用户需求转换为系统设计说明的过程</p></li><li class="lvl-3"><p>算法描述</p><p>将系统功能借助于硬件描述语言进行算法设计和描述</p></li><li class="lvl-3"><p>寄存器传输级</p><p>将子系统或模块的算法描述转换成实现其功能所采用的实际硬件</p></li><li class="lvl-3"><p>门级</p><p>转换成只包含基本门与触发器的逻辑电路</p></li><li class="lvl-3"><p>电路级</p><p>转换成晶体管、电阻、电容等基本元件及连线</p></li><li class="lvl-3"><p>版图级</p><p>转换成物理版图</p></li></ol><p>自底向上是相反的过程</p><h3 id="vlsi的设计描述形式有几类？各自适合于哪个范畴？">vlsi的设计描述形式有几类？各自适合于哪个范畴？</h3><p>四类</p><ul class="lvl-0"><li class="lvl-2"><p>行为描述：适合于功能级，寄存器传输级，门级，晶体管级，版图级</p></li><li class="lvl-2"><p>结构描述：适合于功能级，寄存器传输级，门级，晶体管级，版图级</p></li><li class="lvl-2"><p>几何描述：适合于门级，晶体管级，版图级</p></li><li class="lvl-2"><p>计算机描述：适合于功能级，寄存器传输级，门级，晶体管级，版图级</p></li></ul><h3 id="自顶向下实现两位全加器">自顶向下实现两位全加器</h3><ol><li class="lvl-3"><p>系统级：</p><p>自然语言描述：输入两个2位二进制数，输出它们的和（2位），以及进位</p></li><li class="lvl-3"><p>算法级：</p><p>使用vhdl语言编写实现上述功能的算法,下面是伪代码</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">module TwoBitAdder(input A, B, Cin, output Sum, Cout);</span><br><span class="line">    Sum = (A <span class="keyword">XOR</span> B) <span class="keyword">XOR</span> Cin;</span><br><span class="line">    Cout = (A <span class="keyword">AND</span> B) <span class="keyword">OR</span> ((A <span class="keyword">XOR</span> B) <span class="keyword">AND</span> Cin);</span><br><span class="line"><span class="keyword">end</span> module;</span><br></pre></td></tr></table></figure></li><li class="lvl-3"><p>寄存器传输级</p><p>用组合逻辑电路翻译上述算法中的模块与接线</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/7103b4bc4b7554daa93b131e3ee42a37/202310171228530.png" alt="image-20231017122808415"></p></li></ol><pre class="mermaid">graph TB    A[开始] --> B[行为级设计]    B --> C[算法描述]    C --> D[寄存器传输级]    D --> E[门级设计]    E --> F[电路级设计]    F --> G[版图级设计]    G --> H[结束]</pre><h3 id="估算以下情况下一个芯片内能够集成的门数。">估算以下情况下一个芯片内能够集成的门数。</h3><ol><li class="lvl-3"><p>15625</p></li><li class="lvl-3"><p>140625</p></li><li class="lvl-3"><p>1150000</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> homework </category>
          
          <category> vlsi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> homework </tag>
            
            <tag> vlsi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hw1</title>
      <link href="/homework/vlsi/hw2/"/>
      <url>/homework/vlsi/hw2/</url>
      
        <content type="html"><![CDATA[<h1>hw-1</h1><p>郭高旭 <a href="mailto:ggx21@mails.tsinghua.edu.cn">ggx21@mails.tsinghua.edu.cn</a> 2021010803</p>]]></content>
      
      
      <categories>
          
          <category> homework </category>
          
          <category> vlsi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> homework </tag>
            
            <tag> vlsi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hw1</title>
      <link href="/homework/vlsi/hw3/"/>
      <url>/homework/vlsi/hw3/</url>
      
        <content type="html"><![CDATA[<h1>hw-1</h1><p>郭高旭 <a href="mailto:ggx21@mails.tsinghua.edu.cn">ggx21@mails.tsinghua.edu.cn</a> 2021010803</p>]]></content>
      
      
      <categories>
          
          <category> homework </category>
          
          <category> vlsi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> homework </tag>
            
            <tag> vlsi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hw1</title>
      <link href="/homework/vlsi/hw4/"/>
      <url>/homework/vlsi/hw4/</url>
      
        <content type="html"><![CDATA[<h1>hw-1</h1><p>郭高旭 <a href="mailto:ggx21@mails.tsinghua.edu.cn">ggx21@mails.tsinghua.edu.cn</a> 2021010803</p>]]></content>
      
      
      <categories>
          
          <category> homework </category>
          
          <category> vlsi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> homework </tag>
            
            <tag> vlsi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内容预览</title>
      <link href="/notes/compiler_construction/%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/"/>
      <url>/notes/compiler_construction/%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90/</url>
      
        <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><h3 id="词法分析">词法分析</h3><ul class="lvl-2"><li class="lvl-4"><h4 id="词法分析基础">词法分析基础</h4></li></ul></li><li class="lvl-2"><h3 id="符号表组织">符号表组织</h3><ul class="lvl-2"><li class="lvl-4"><h4 id="强调作用域及其组织方式">强调作用域及其组织方式</h4></li></ul></li><li class="lvl-2"><h3 id="语法分析">语法分析</h3><ul class="lvl-2"><li class="lvl-4"><h4 id="自顶向下语法分析">自顶向下语法分析</h4></li><li class="lvl-4"><h4 id="自底向上语法分析">自底向上语法分析</h4></li></ul></li><li class="lvl-2"><h3 id="语法制导的语义计算基础">语法制导的语义计算基础</h3><p>基于属性文法和翻译模式进行语义计算的基本原理及实现技术</p></li><li class="lvl-2"><h3 id="语义分析">语义分析</h3><p>以类型检查程序设计为重点</p></li><li class="lvl-2"><h3 id="中间代码生成">中间代码生成</h3><p>以常用语言机制的实现技术为主线</p></li><li class="lvl-2"><h3 id="运行时存储组织">运行时存储组织</h3><p>存储布局,存储分配策略,活动记录,过程实现,面向对象程序存储组织,</p></li><li class="lvl-2"><h3 id="代码优化">代码优化</h3></li><li class="lvl-2"><h3 id="目标代码生成">目标代码生成</h3></li></ul>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
          <category> compiler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> compiler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内容预览</title>
      <link href="/notes/compiler_construction/%E5%86%85%E5%AE%B9%E9%A2%84%E8%A7%88/"/>
      <url>/notes/compiler_construction/%E5%86%85%E5%AE%B9%E9%A2%84%E8%A7%88/</url>
      
        <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><h3 id="词法分析">词法分析</h3><ul class="lvl-2"><li class="lvl-4"><h4 id="词法分析基础">词法分析基础</h4></li></ul></li><li class="lvl-2"><h3 id="符号表组织">符号表组织</h3><ul class="lvl-2"><li class="lvl-4"><h4 id="强调作用域及其组织方式">强调作用域及其组织方式</h4></li></ul></li><li class="lvl-2"><h3 id="语法分析">语法分析</h3><ul class="lvl-2"><li class="lvl-4"><h4 id="自顶向下语法分析">自顶向下语法分析</h4></li><li class="lvl-4"><h4 id="自底向上语法分析">自底向上语法分析</h4></li></ul></li><li class="lvl-2"><h3 id="语法制导的语义计算基础">语法制导的语义计算基础</h3><p>基于属性文法和翻译模式进行语义计算的基本原理及实现技术</p></li><li class="lvl-2"><h3 id="语义分析">语义分析</h3><p>以类型检查程序设计为重点</p></li><li class="lvl-2"><h3 id="中间代码生成">中间代码生成</h3><p>以常用语言机制的实现技术为主线</p></li><li class="lvl-2"><h3 id="运行时存储组织">运行时存储组织</h3><p>存储布局,存储分配策略,活动记录,过程实现,面向对象程序存储组织,</p></li><li class="lvl-2"><h3 id="代码优化">代码优化</h3></li><li class="lvl-2"><h3 id="目标代码生成">目标代码生成</h3></li></ul>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
          <category> compiler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> compiler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内容预览</title>
      <link href="/notes/compiler_construction/%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90/"/>
      <url>/notes/compiler_construction/%E8%AF%AD%E4%B9%89%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><h3 id="词法分析">词法分析</h3><ul class="lvl-2"><li class="lvl-4"><h4 id="词法分析基础">词法分析基础</h4></li></ul></li><li class="lvl-2"><h3 id="符号表组织">符号表组织</h3><ul class="lvl-2"><li class="lvl-4"><h4 id="强调作用域及其组织方式">强调作用域及其组织方式</h4></li></ul></li><li class="lvl-2"><h3 id="语法分析">语法分析</h3><ul class="lvl-2"><li class="lvl-4"><h4 id="自顶向下语法分析">自顶向下语法分析</h4></li><li class="lvl-4"><h4 id="自底向上语法分析">自底向上语法分析</h4></li></ul></li><li class="lvl-2"><h3 id="语法制导的语义计算基础">语法制导的语义计算基础</h3><p>基于属性文法和翻译模式进行语义计算的基本原理及实现技术</p></li><li class="lvl-2"><h3 id="语义分析">语义分析</h3><p>以类型检查程序设计为重点</p></li><li class="lvl-2"><h3 id="中间代码生成">中间代码生成</h3><p>以常用语言机制的实现技术为主线</p></li><li class="lvl-2"><h3 id="运行时存储组织">运行时存储组织</h3><p>存储布局,存储分配策略,活动记录,过程实现,面向对象程序存储组织,</p></li><li class="lvl-2"><h3 id="代码优化">代码优化</h3></li><li class="lvl-2"><h3 id="目标代码生成">目标代码生成</h3></li></ul>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
          <category> compiler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> compiler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内容预览</title>
      <link href="/notes/compiler_construction/%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%9A%84%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97%E5%9F%BA%E7%A1%80/"/>
      <url>/notes/compiler_construction/%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%9A%84%E8%AF%AD%E4%B9%89%E8%AE%A1%E7%AE%97%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><h3 id="词法分析">词法分析</h3><ul class="lvl-2"><li class="lvl-4"><h4 id="词法分析基础">词法分析基础</h4></li></ul></li><li class="lvl-2"><h3 id="符号表组织">符号表组织</h3><ul class="lvl-2"><li class="lvl-4"><h4 id="强调作用域及其组织方式">强调作用域及其组织方式</h4></li></ul></li><li class="lvl-2"><h3 id="语法分析">语法分析</h3><ul class="lvl-2"><li class="lvl-4"><h4 id="自顶向下语法分析">自顶向下语法分析</h4></li><li class="lvl-4"><h4 id="自底向上语法分析">自底向上语法分析</h4></li></ul></li><li class="lvl-2"><h3 id="语法制导的语义计算基础">语法制导的语义计算基础</h3><p>基于属性文法和翻译模式进行语义计算的基本原理及实现技术</p></li><li class="lvl-2"><h3 id="语义分析">语义分析</h3><p>以类型检查程序设计为重点</p></li><li class="lvl-2"><h3 id="中间代码生成">中间代码生成</h3><p>以常用语言机制的实现技术为主线</p></li><li class="lvl-2"><h3 id="运行时存储组织">运行时存储组织</h3><p>存储布局,存储分配策略,活动记录,过程实现,面向对象程序存储组织,</p></li><li class="lvl-2"><h3 id="代码优化">代码优化</h3></li><li class="lvl-2"><h3 id="目标代码生成">目标代码生成</h3></li></ul>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
          <category> compiler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> compiler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内容预览</title>
      <link href="/notes/compiler_construction/%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9/"/>
      <url>/notes/compiler_construction/%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><h3 id="词法分析">词法分析</h3><ul class="lvl-2"><li class="lvl-4"><h4 id="词法分析基础">词法分析基础</h4></li></ul></li><li class="lvl-2"><h3 id="符号表组织">符号表组织</h3><ul class="lvl-2"><li class="lvl-4"><h4 id="强调作用域及其组织方式">强调作用域及其组织方式</h4></li></ul></li><li class="lvl-2"><h3 id="语法分析">语法分析</h3><ul class="lvl-2"><li class="lvl-4"><h4 id="自顶向下语法分析">自顶向下语法分析</h4></li><li class="lvl-4"><h4 id="自底向上语法分析">自底向上语法分析</h4></li></ul></li><li class="lvl-2"><h3 id="语法制导的语义计算基础">语法制导的语义计算基础</h3><p>基于属性文法和翻译模式进行语义计算的基本原理及实现技术</p></li><li class="lvl-2"><h3 id="语义分析">语义分析</h3><p>以类型检查程序设计为重点</p></li><li class="lvl-2"><h3 id="中间代码生成">中间代码生成</h3><p>以常用语言机制的实现技术为主线</p></li><li class="lvl-2"><h3 id="运行时存储组织">运行时存储组织</h3><p>存储布局,存储分配策略,活动记录,过程实现,面向对象程序存储组织,</p></li><li class="lvl-2"><h3 id="代码优化">代码优化</h3></li><li class="lvl-2"><h3 id="目标代码生成">目标代码生成</h3></li></ul>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
          <category> compiler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> compiler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>词法分析与符号表</title>
      <link href="/notes/compiler_construction/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E7%AC%A6%E5%8F%B7%E8%A1%A8%E7%BB%84%E7%BB%87/"/>
      <url>/notes/compiler_construction/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E7%AC%A6%E5%8F%B7%E8%A1%A8%E7%BB%84%E7%BB%87/</url>
      
        <content type="html"><![CDATA[<h1>词法分析</h1><p>识别单词<code>Lexemes </code> ，返回单词记录<code>tokens&amp;attrs</code></p><h3 id="常用工具">常用工具</h3><ul class="lvl-0"><li class="lvl-2"><p>EBNF</p></li><li class="lvl-2"><p>状态转移图</p></li><li class="lvl-2"><p>正规表达式</p></li><li class="lvl-2"><p>有限状态自动机</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
          <category> compiler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> compiler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>语法分析</title>
      <link href="/notes/compiler_construction/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"/>
      <url>/notes/compiler_construction/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1>语法分析</h1><p>核心问题是<strong>识别</strong>，<strong>解析</strong>上下文无关文法G = (V ， T ， P， S )</p><h3 id="两种实现途径">两种实现途径</h3><ul class="lvl-0"><li class="lvl-2"><p>自顶向下（从S到句子）</p></li><li class="lvl-2"><p>自底向上</p></li></ul><h2 id="自顶向下的语法分析">自顶向下的语法分析</h2><p>问题是容易出现回溯</p><h4 id="两类非确定性">两类非确定性</h4><ul class="lvl-0"><li class="lvl-2"><p>非终结符的的选择是非确定的（这个简单，最左产生和原有文法等价）</p></li><li class="lvl-2"><p>仅有产生式选择是非确定的</p></li></ul><h4 id="解决产生式选择的不确定性：lookahead">解决产生式选择的不确定性：lookahead</h4><p>唯一目的就是避免回溯，所以要看得足够多</p><h4 id="一个不太好的例子">一个不太好的例子</h4><p>考虑下列文法识别 $ba^n$ 的分析过程,  <code>S → Sa  ,S → b  </code></p><div class="tips"><p>看到下一个是a,然后选择<code>S → Sa</code>是不够的,因为a后可能还有a,要确定还要不要a只能继续向后看,所以无论向前看多远,这个句子后面总可能还是有a,所以还是不能确定.</p></div><blockquote><p>这启发我们lookahead的表现需要依赖于文法</p></blockquote><h3 id="LL-1-文法">LL(1)文法</h3><p>文法 G 是 LL（1）文法，当且仅当下面的条件成立：</p><div class="warning"><p>对于每一个生成符,其所有产生式的预测集合不相交</p></div><p>First集合与Follow集合,$G =（V_T， V_N， P， S）$ 是上下文无关文法</p><h4 id="First集合">First集合</h4><p>first集合是求下述符号可能产生的<strong>首终结符</strong></p><p>first集合针对的是在LL推导中可能出现的三类符号的并集</p><ol><li class="lvl-3"><p>终结符与$\epsilon$</p></li><li class="lvl-3"><p>生成符</p></li><li class="lvl-3"><p>文法右边的符号串</p></li></ol><h5 id="计算方法">计算方法</h5><ol><li class="lvl-3"><p>1类集合元素为本身,剩下的是空集</p></li><li class="lvl-3"><p>如果生成符能生成$\epsilon$,则其集合加入$\epsilon$</p></li><li class="lvl-3"><p>对于3类符号串,首先加入串首符号对应集合元素</p></li><li class="lvl-3"><p>从左向右分析,如果first集合中有$\epsilon$,则集合并上此处符号的后继符号的first集合</p></li><li class="lvl-3"><p>如果停止,则3类符号串first集中删去$\epsilon$</p></li><li class="lvl-3"><p>如果生成符能生成3,则集合取并</p></li><li class="lvl-3"><p>重复3-6,直到所有集合不变</p></li></ol><h4 id="Follow集合">Follow集合</h4><p>follow集合是在求$V_N$的直接后继终结符</p><h5 id="计算-Follow-集合">计算 Follow 集合</h5><ol><li class="lvl-3"><p>置 Follow(S) =</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
          <category> compiler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> compiler </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stage5</title>
      <link href="/homework/compiler_construction/stage5/"/>
      <url>/homework/compiler_construction/stage5/</url>
      
        <content type="html"><![CDATA[<h1>stage-5</h1><p>郭高旭 <a href="mailto:ggx21@mails.tsinghua.edu.cn">ggx21@mails.tsinghua.edu.cn</a> 2021010803</p><h2 id="实验内容">实验内容</h2><p>支持多函数，支持函数的声明和定义（functionDef），支持函数调用（fuctionCall），本次实验基本上完整地走了一遍编译器的前端中端后端过程，真是收获满满呢😄😄</p><h3 id="前端：">前端：</h3><p>lex：</p><p>增加了comma<code>,</code></p><p>parse：</p><p>​重新设计AST树结点</p><ul class="lvl-0"><li class="lvl-2"><p>function：添加<code>params: ParameterList</code>属性</p></li><li class="lvl-2"><p>ParameterList：新增结点，实际上是declaration的列表</p></li><li class="lvl-2"><p>functionCall：函数调用结点</p></li><li class="lvl-2"><p>expressionList:函数参数结点</p></li></ul><p>​按照规范对新增结点添加parser</p><p>namer:</p><ol><li class="lvl-3"><p><strong>visitFunctionDef</strong>:这个一方面基本可以参考变量定义的实现(检查是否重定义),另一方面需要注意函数的参数列表和body实际上位于同一个Scope,在依次访问这两处时,要保证ScopeStack里只开了一个Scope,因此我修改了visitBlock的逻辑,在发现上一个Scope是函数参数列表时,不另开scope</p></li><li class="lvl-3"><p>ParameterList,ExpressionList:依次visit其children即可</p></li><li class="lvl-3"><p>visitFunctionCall:</p><p>使用 <code>ctx.lookupGlobalScope</code> 来检查是否已经声明了一个同名的函数。如果没有声明，则引发 <code>DecafUndefinedFuncError</code>。设置 <code>expr.visit</code> 的参数列表的 ‘symbol’ 属性。</p><p>此外还添加了对<code>var shadow function</code>的检查以及对参数不匹配的检查</p></li></ol><h3 id="中端">中端</h3><p>设计functionCall语句的表示方法,</p><p>简单而言就是新建一个temp作为functionCall的目的,遍历访问callee的ExpressionList求得函数调用的srcTemps</p><p>还有需要注意的是在Tacgen.transform,开始生成tac树时(每个函数开始生成tac时),需要采用真实的参数计数,以及首先访问函数的参数列表.</p><h3 id="后端">后端</h3><p>这一部分是项目目前为之比较复杂的部分</p><ul class="lvl-0"><li class="lvl-2"><p><code>utils/riscv.py</code>:新增了Call指令和Addi指令的翻译</p></li><li class="lvl-2"><p><code>backend/riscv/riscvasmemitter.py</code></p><ul class="lvl-2"><li class="lvl-4"><p>class <strong>RiscvInstrSelector</strong>(<strong>TACVisitor</strong>):</p><p>这个类是将tac码翻译为介于tac和asm码之间的类,指令类似于asm但是操作数是tac的temp,在这里增加了对Call指令的支持,实际上就是将<code>T0 = CALL foo(T1, T2)</code>翻译成<code>call foo</code>与<code>move A0 to T0</code>两句(e.g.)</p></li><li class="lvl-4"><p>class RiscvSubroutineEmitter(SubroutineEmitter):</p><p>这个类是最终输出asm码的类,已经由bruteregalloc将上面类生成的中间代码中的temp转换成了reg.</p><ul class="lvl-4"><li class="lvl-6"><p>修改了压栈入栈逻辑,由于框架代码的栈分配比较暴力,而且暂时不需要考虑性能,所以我的实现方法是:将ra,fp存到栈底,将中间变量从栈顶开始向栈底分配(而不是原来的相反实现,这样不会影响ra</p></li><li class="lvl-6"><p>prologue:新增存ra,fp</p></li><li class="lvl-6"><p>body:主要是在遇到函数调用时:存储caller-saved寄存器,执行函数调用(函数传参部分在emit之前我放在下面<code>bruteregalloc.py</code>寄存器分配时处理),恢复caller-saved寄存器</p></li><li class="lvl-6"><p>epilogue:恢复ra,fp,calleesaved寄存器</p></li></ul></li></ul></li><li class="lvl-2"><p><code>backend/reg/bruteregalloc.py</code></p><ul class="lvl-2"><li class="lvl-4"><p>localAlloc：根据数据流对一个 BasicBlock 内的指令进行寄存器分配,</p><p>在这里对callee的参数列表里的temp进行reg的绑定(传参),具体而言就是按照调用约定,按照顺序从寄存器或者栈上取出参数,move到参数列表中声明的temp</p></li><li class="lvl-4"><p>allocForLoc：每一条指令进行寄存器分配</p><p>在这里如果发现指令为Call,就和上面的localAlloc执行相反操作,把函数srcs中的temp绑定到reg然后再按照调用约定存入寄存器或者栈</p></li></ul></li></ul><h2 id="思考题">思考题</h2><h4 id="Q1：">Q1：</h4><p>你更倾向采纳哪一种中间表示中的函数调用指令的设计（一整条函数调用 vs 传参和调用分离）？写一些你认为两种设计方案各自的优劣之处。</p><h4 id="A1：">A1：</h4><p>我实际上两种中间表示都尝试了，最终还是选择了一整条函数调用。这主要是一些操作上的问题，我在尝试传参调用分离的时候感觉没有必要，反而会增加传参时寄存器与栈分配的代码逻辑复杂度。</p><ol><li class="lvl-3"><p>一整条函数调用：</p><p>优势</p><ul class="lvl-2"><li class="lvl-5"><p>更贴近源语言，便于生成</p></li><li class="lvl-5"><p>代码更加简洁直观</p></li><li class="lvl-5"><p>紧凑性：一整条指令可以将参数传递和函数调用合并在一起，减少了指令的数量，节省了内存和提高了缓存性能。</p></li><li class="lvl-5"><p>有利于集中计算分配函数调用中函数参数的分配</p></li><li class="lvl-5"><p>节省指令解码时间：一整条指令可以在解码阶段一次性解析，而不需要分别解析传参和调用指令。</p></li></ul><p>劣势</p><ol><li class="lvl-6"><p><strong>限制性</strong>：一整条指令可能会限制编译器的优化机会，因为它需要在单条指令中包含参数传递和调用信息，这可能使得某些优化更加复杂。</p></li><li class="lvl-6"><p><strong>可维护性</strong>：一整条指令的可读性和可维护性可能较低，因为它需要一次性表达多个概念，不容易理解和调试。</p></li></ol></li><li class="lvl-3"><p>传参和调用分离</p><p>优势</p><ul class="lvl-2"><li class="lvl-5"><p>更贴目标语言（riscv），便于生成目标语言</p></li><li class="lvl-5"><p>灵活性：将参数传递和函数调用分离可以允许编译器更自由地进行优化。它可以根据具体情况选择不同的策略来传递参数，以获得更好的性能,适应不同的后端</p></li><li class="lvl-5"><p>可读性：分离的设计可以提高代码的可读性和可维护性，因为每个步骤都以清晰的方式表达，易于理解和调试。</p></li></ul><p>劣势</p><ul class="lvl-2"><li class="lvl-5"><p>指令数量增加：分离参数传递和函数调用通常需要更多的指令，因此可能会导致更多的代码大小和执行时间开销。</p></li><li class="lvl-5"><p>增加传参时寄存器与栈分配的代码逻辑复杂度</p></li></ul></li></ol><h4 id="Q2：">Q2：</h4><p>为何 RISC-V 标准调用约定中要引入 callee-saved 和 caller-saved 两类寄存器，而不是要求所有寄存器完全由 caller/callee 中的一方保存？为何保存返回地址的 ra 寄存器是 caller-saved 寄存器？</p><h4 id="A2：">A2：</h4><ol><li class="lvl-3"><p>这保证了寄存器分配的灵活性，主要是尽可能减少寄存器压栈出栈的次数。caller-saved和calllee-saved实际上规定了caller和callee对寄存器保护的责任。这样每一subroutine在自己的作用域里总是有一些寄存器可以随意更改，也有另一些寄存器负责保护。</p><p>而全部caller/callee-saved,尽管实际上确实可以work但是</p><ul class="lvl-2"><li class="lvl-5"><p>如果全部callersaved，考虑到一个caller可能有大量callee，那么调用callee前后会大量入栈出栈</p></li><li class="lvl-5"><p>如果全部calleesaved，参见下一问的回答多个callee都需要存储恢复caller本应保持的寄存器，也会造成浪费。</p></li></ul></li><li class="lvl-3"><p>一个caller可能有多个callee，反之则不可能。那么多个callee储存/恢复caller的ra，会造成浪费。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> homework </category>
          
          <category> 编原 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lab </tag>
            
            <tag> 编原 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stage4</title>
      <link href="/homework/compiler_construction/stage4/"/>
      <url>/homework/compiler_construction/stage4/</url>
      
        <content type="html"><![CDATA[<h1>stage-4</h1><p>郭高旭 <a href="mailto:ggx21@mails.tsinghua.edu.cn">ggx21@mails.tsinghua.edu.cn</a> 2021010803</p><h2 id="实验内容">实验内容</h2><h3 id="step7">step7</h3><p>支持条件语句，包括 if 语句和条件表达式（又称三元/三目表达式，ternary expression）。</p><p>由于if代码和条件表达式的前后端代码在框架中均已提供，所以这里只需要考虑条件表达式的tacgen。</p><p>由于这也是一个expression，所以模拟二元表达式以及if语句，代码内容如下</p><p>这段代码是一个Python函数，用于将条件表达式转换为TAC（Three-Address Code）。它的主要步骤如下：</p><ol><li class="lvl-3"><p>创建一个临时变量<code>tempVal</code>来存储条件表达式的结果。</p></li><li class="lvl-3"><p>生成条件部分的TAC代码，并将结果存储在<code>tempVal</code>中。</p></li><li class="lvl-3"><p>创建两个标签，<code>skipLabel</code>和<code>exitLabel</code>，用于控制流跳转。</p></li><li class="lvl-3"><p>如果条件成立，执行<code>expr.then</code>的TAC代码，然后将结果赋给<code>tempVal</code>。</p></li><li class="lvl-3"><p>跳转到<code>exitLabel</code>以避免执行<code>expr.otherwise</code>的TAC代码。</p></li><li class="lvl-3"><p>如果条件不成立，执行<code>expr.otherwise</code>的TAC代码，然后将结果赋给<code>tempVal</code>。</p></li><li class="lvl-3"><p>最后，将<code>tempVal</code>存储在<code>expr</code>中以表示条件表达式的结果。</p></li></ol><h3 id="step8">step8</h3><p>step8可以看作是对step9的准备，让我们上手整个编译流程，包括之前没有太修改过的lex&amp;parse，增加对循环语句，以及 break/continue 的支持。</p><h4 id="前端">前端</h4><p>按照语法规范给出for，while，continue的实现，如下例（while，break已给出，continue简单）</p><h5 id="lex">lex</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Reserved keywords</span></span><br><span class="line">reserved = &#123;</span><br><span class="line">    <span class="string">&quot;return&quot;</span>: <span class="string">&quot;Return&quot;</span>,</span><br><span class="line">    <span class="string">&quot;int&quot;</span>: <span class="string">&quot;Int&quot;</span>,</span><br><span class="line">    <span class="string">&quot;if&quot;</span>: <span class="string">&quot;If&quot;</span>,</span><br><span class="line">    <span class="string">&quot;else&quot;</span>: <span class="string">&quot;Else&quot;</span>,</span><br><span class="line">    <span class="string">&quot;while&quot;</span>: <span class="string">&quot;While&quot;</span>,</span><br><span class="line">    <span class="string">&quot;break&quot;</span>: <span class="string">&quot;Break&quot;</span>,</span><br><span class="line">    <span class="string">&quot;continue&quot;</span>: <span class="string">&quot;Continue&quot;</span>,</span><br><span class="line">    <span class="string">&quot;for&quot;</span>: <span class="string">&quot;For&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="parse">parse</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">p_for</span>(<span class="params">p</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    statement_matched : For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_matched</span></span><br><span class="line"><span class="string">                        | For LParen declaration Semi opt_expression Semi opt_expression RParen statement_matched</span></span><br><span class="line"><span class="string">    statement_unmatched : For LParen opt_expression Semi opt_expression Semi opt_expression RParen statement_unmatched</span></span><br><span class="line"><span class="string">                        | For LParen declaration Semi opt_expression Semi opt_expression RParen statement_unmatched</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    p[<span class="number">0</span>] = For(p[<span class="number">3</span>], p[<span class="number">5</span>], p[<span class="number">7</span>], p[<span class="number">9</span>])</span><br></pre></td></tr></table></figure><p>并在<strong>tree</strong>中相应设置好上述语法结点</p><h4 id="语义检查">语义检查</h4><p>完成 <a href="http://namer.py">namer.py</a> 中的 visitFor ， visitWhile ， visitContinue 和 visitBreak 方法</p><ul class="lvl-0"><li class="lvl-2"><p>对于visitContinue 和 visitBreak，要确定其位于的scope在循环内，这可以通过在visitFor和while中进入循环体前标记此Scope类型为LOOP实现</p></li><li class="lvl-3"><p>visitFor:</p></li></ul><p>按照提示,生成代码如下</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">visitFor</span>(<span class="params">self, stmt: For, ctx: ScopeStack</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 1. Open a local scope for stmt.init.</span></span><br><span class="line"><span class="comment"># 2. Visit stmt.init, stmt.cond, stmt.update.</span></span><br><span class="line"><span class="comment"># 3. Open a loop in ctx (for validity checking of break/continue)</span></span><br><span class="line"><span class="comment"># 4. Visit body of the loop.</span></span><br><span class="line"><span class="comment"># 5. Close the loop and the local scope.</span></span><br><span class="line">  </span><br><span class="line">    new_scope = Scope(ScopeKind.LOCAL)</span><br><span class="line">    ctx.push(new_scope)</span><br><span class="line">    stmt.init.accept(self, ctx)</span><br><span class="line">    stmt.cond.accept(self, ctx)</span><br><span class="line">    stmt.update.accept(self, ctx)</span><br><span class="line">    loop_scope = Scope(ScopeKind.LOOP)</span><br><span class="line">    loop_scope.inLoop = <span class="literal">True</span></span><br><span class="line">    ctx.push(loop_scope)</span><br><span class="line">    stmt.body.accept(self, ctx)</span><br><span class="line">    ctx.pop()</span><br><span class="line">    ctx.pop()</span><br></pre></td></tr></table></figure><h4 id="中端-后端">中端,后端</h4><p>框架均已提供</p><h2 id="思考题">思考题</h2><h4 id="step7-2">step7</h4><h4 id="Q1">Q1:</h4><p>实验框架与你使用语言的框架里是如何处理悬吊 else 问题的?</p><h4 id="A1">A1:</h4><h4 id="实验框架">实验框架</h4><p>ply在处理移入-归约冲突时，默认移入：具体来说没有 else分支的 if 语句只能由 statement unmatched 产生，而statement unmatched 只能出现在if的else 分支里。</p><p>通过这样的设计，悬挂 else 问题得以解决。当遇到没有 else 分支的 if 语句时，它会被解释为 <code>If</code> 对象，其中 <code>Else</code> 分支为 None。在 AST 中，这种情况明确地表示了这个 if 语句是没有 else 分支的。</p><p>在使用这个 AST 进行后续处理时，你可以检查 <code>If</code> 对象的 <code>else_branch</code> 是否为 None，从而确定是否存在 else 分支。这种明确的表示方式有助于避免悬挂 else 问题。</p><p><strong>Python:</strong></p><p>Python使用缩进来表示代码块，因此在Python中，<code>if</code>和<code>else</code>语句的匹配是根据缩进来实现的。Python的规则如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition:</span><br><span class="line">    <span class="comment"># if块</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># else块</span></span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p>在Python中，<code>else</code>语句与最近的未匹配的<strong>相同缩进</strong>的<code>if</code>语句相关联，而不是通过括号或其他方式。这确保了<code>else</code>与最近的<code>if</code>一起使用。</p><p><strong>C语言:</strong></p><p>在C语言中，<code>else</code>与最近的<code>if</code>语句相关联，这是通过花括号来实现的，它们定义了代码块的范围。通常，C语言的规则如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// if块</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// else块</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在C语言中，花括号<code>&#123;&#125;</code>用于明确定义代码块的开始和结束，因此<code>else</code>会与最近的<code>if</code>语句匹配，这就避免了悬挂else问题。</p><h4 id="Q2">Q2:</h4><p>如果要求条件表达式不短路，在你的实现中该做何种修改？</p><h4 id="A2">A2</h4><p>在tacgen的def <strong>visitCondExpr</strong>函数中:</p><p>将 then.accept 与 otherwise.accept 放在mv.visitCondBranch之前,(此时不能再给then和otherwise的值设置到同一个temp里)</p><h3 id="step8-2">step8</h3><h4 id="Q1-2">Q1:</h4><p>将循环语句翻译成 IR 有许多可行的翻译方法，例如 while 循环可以有以下两种翻译方式：</p><p>第一种（即实验指导中的翻译方式）：</p><ul class="lvl-0"><li class="lvl-2"><p><code>label BEGINLOOP_LABEL</code>：开始下一轮迭代</p></li><li class="lvl-2"><p><code>cond 的 IR</code></p></li><li class="lvl-2"><p><code>beqz BREAK_LABEL</code>：条件不满足就终止循环</p></li><li class="lvl-2"><p><code>body 的 IR</code></p></li><li class="lvl-2"><p><code>label CONTINUE_LABEL</code>：continue 跳到这</p></li><li class="lvl-2"><p><code>br BEGINLOOP_LABEL</code>：本轮迭代完成</p></li><li class="lvl-2"><p><code>label BREAK_LABEL</code>：条件不满足，或者 break 语句都会跳到这儿</p></li></ul><p>第二种：</p><ul class="lvl-0"><li class="lvl-2"><p><code>cond 的 IR</code></p></li><li class="lvl-2"><p><code>beqz BREAK_LABEL</code>：条件不满足就终止循环</p></li><li class="lvl-2"><p><code>label BEGINLOOP_LABEL</code>：开始下一轮迭代</p></li><li class="lvl-2"><p><code>body 的 IR</code></p></li><li class="lvl-2"><p><code>label CONTINUE_LABEL</code>：continue 跳到这</p></li><li class="lvl-2"><p><code>cond 的 IR</code></p></li><li class="lvl-2"><p><code>bnez BEGINLOOP_LABEL</code>：本轮迭代完成，条件满足时进行下一次迭代</p></li><li class="lvl-2"><p><code>label BREAK_LABEL</code>：条件不满足，或者 break 语句都会跳到这儿</p></li></ul><p>从执行的指令的条数这个角度（<code>label</code> 不算做指令，假设循环体至少执行了一次），请评价这两种翻译方式哪一种更好？</p><h4 id="A1-2">A1:</h4><p>第二种翻译方式更好</p><p>循环体执行了一次都是经历了相同的<code>body 的 IR</code>与<code>cond 的 IR</code>.但第一种方式循环体执行了一次后判断是否终止时总是需要两条指令:<code>br BEGINLOOP_LABEL</code>与<code>beqz BREAK_LABEL</code>;但是第二种方式<code>bnez BEGINLOOP_LABEL</code>在条件不满足时直接退出循环,只需要一条指令;而条件满足时<code>beqz BREAK_LABEL</code>,<code>bnez BEGINLOOP_LABEL</code>需要两条指令.</p><p>故第二种方式的指令数总是较小</p><h4 id="Q2-2">Q2:</h4><p>我们目前的 TAC IR 中条件分支指令采用了单分支目标（标签）的设计，即该指令的操作数中只有一个是标签；如果相应的分支条件不满足，则执行流会继续向下执行。在其它 IR 中存在双目标分支（标签）的条件分支指令，其形式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">br cond, false_target, true_target</span><br></pre></td></tr></table></figure><p>其中<code>cond</code>是一个临时变量，<code>false_target</code>和<code>true_target</code>是标签。其语义为：如果<code>cond</code>的值为0（假），则跳转到<code>false_target</code>处；若<code>cond</code>非0（真），则跳转到<code>true_target</code>处。它与我们的条件分支指令的区别在于执行流总是会跳转到两个标签中的一个。</p><p>你认为中间表示的哪种条件分支指令设计（单目标 vs 双目标）更合理？为什么？（言之有理即可）</p><h4 id="A2-2">A2:</h4><p>我认为单目标指令更合理,原因如下</p><ol><li class="lvl-3"><p>更贴近目标语言(riscvasm)</p></li><li class="lvl-3"><p>减少悬挂else问题:不需要担心其中一个target不存在</p></li><li class="lvl-3"><p>简化了控制流：单目标条件分支指令可以更简单地表示控制流的分支，减少了语义上的复杂性。这使得中间表示更容易理解和优化。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> homework </category>
          
          <category> 编原 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lab </tag>
            
            <tag> 编原 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stage3</title>
      <link href="/homework/compiler_construction/stage3/"/>
      <url>/homework/compiler_construction/stage3/</url>
      
        <content type="html"><![CDATA[<h1>stage-3</h1><p>郭高旭 <a href="mailto:ggx21@mails.tsinghua.edu.cn">ggx21@mails.tsinghua.edu.cn</a> 2021010803</p><h2 id="实验内容">实验内容</h2><p>增加块语句的支持。</p><h3 id="前端">前端</h3><p>主要是修改了重复声明的检查。只有在同一个作用域里，变量才不能重复声明</p><p>具体而言，定义了ScopeStack替换原有的单一scope，重新实现lookup，declare，使得它们仅仅在当前ScopeStack的栈顶生效</p><ul class="lvl-0"><li class="lvl-2"><p>lookupCurrent:在Declaration时,只在当前(栈顶)查找符号表</p></li><li class="lvl-2"><p>lookup:在visitIdentifier等中,从栈顶反向查找,直至查找到声明或者失败,这样保证查找到最近的声明</p></li><li class="lvl-2"><p>declare:在栈顶scope(当前scope)scope</p></li><li class="lvl-2"><p>namer语义检查时的visitBlock中,新作用域入栈,访问结束后,此作用域出栈</p></li></ul><h3 id="中端">中端</h3><p>本步骤中无须新增新的 TAC 指令。</p><h3 id="后端">后端</h3><p>数据流分析：新增了判断基本块是否可达的代码，为每一个BasicBlock添加reachable属性,通过dfs找到所有可达块,并更新reachable</p><p>在寄存器分配函数<code>bruteregalloc.py</code>中   ，仅仅为可达的基本块分配寄存器.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> bb <span class="keyword">in</span> graph.iterator():</span><br><span class="line">    <span class="keyword">if</span> bb.label <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        subEmitter.emitLabel(bb.label)</span><br><span class="line">    <span class="keyword">if</span> bb.reachable:</span><br><span class="line">        self.localAlloc(bb, subEmitter)</span><br></pre></td></tr></table></figure><h2 id="思考题">思考题</h2><p>请画出下面 MiniDecaf 代码的控制流图。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line"> <span class="keyword">if</span> (a &lt; <span class="number">3</span>) &#123;</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line">         <span class="keyword">return</span> a;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> a;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于控制流图是根据TACinstr构造的,所以这里先给出上述代码的TAC表示(bb为含注释行到上一注释行后)</p><figure class="highlight tcl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FUNCTION&lt;main&gt;:</span><br><span class="line">    _T1 = <span class="number">2</span></span><br><span class="line">    _T0 = _T1</span><br><span class="line">    _T2 = <span class="number">3</span></span><br><span class="line">    _T3 = (_T0 &lt; _T2)</span><br><span class="line">    <span class="keyword">if</span> (_T3 == <span class="number">0</span>) branch _L1 #---------------bb1</span><br><span class="line">    _T5 = <span class="number">3</span></span><br><span class="line">    _T4 = _T5</span><br><span class="line">    <span class="keyword">return</span> _T4#---------------bb2</span><br><span class="line">    <span class="keyword">return</span> _T0#---------------bb3</span><br><span class="line">_L1:</span><br><span class="line">    <span class="keyword">return</span>#---------------bb4</span><br></pre></td></tr></table></figure><p>则上述4个基本块构造的控制流图如下</p><pre class="mermaid">graph TDA[bb1]-->B[bb2]A[bb1]-->C[bb4]D[bb3:不可达]</pre>]]></content>
      
      
      <categories>
          
          <category> homework </category>
          
          <category> 编原 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lab </tag>
            
            <tag> 编原 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stage2</title>
      <link href="/homework/compiler_construction/stage2/"/>
      <url>/homework/compiler_construction/stage2/</url>
      
        <content type="html"><![CDATA[<h1>stage-2</h1><p>郭高旭 <a href="mailto:ggx21@mails.tsinghua.edu.cn">ggx21@mails.tsinghua.edu.cn</a> 2021010803</p><h2 id="实验内容">实验内容</h2><p>增加变量，实现对变量的声明和赋值。同时增加变量相关的语义检查，不能重复声明变量，不能使用未声明的变量</p><h3 id="前端">前端</h3><ul class="lvl-0"><li class="lvl-2"><h4 id="lex-parser">lex&amp;parser</h4><p>此部分内容框架已经提供，通过这里表达出ast树</p></li><li class="lvl-2"><h4 id="语义分析">语义分析</h4><p>修改namer中 <code>visitDeclaration</code>,<code>visitAssignment</code>,<code>visitIdentifier</code>三个函数</p><ul class="lvl-2"><li class="lvl-4"><p>visitDeclaration</p><ol><li class="lvl-7">使用 <code>ctx.lookup</code> 来查找是否已经声明了具有相同名称的变量。</li><li class="lvl-7">如果有，报错。如果没有，创建一个新的 <code>VarSymbol</code>，并使用 <code>ctx.declare</code> 将其放入当前作用域。</li><li class="lvl-7">设置 <code>decl</code> 的 ‘symbol’ 属性。</li><li class="lvl-7">如果存在初始值，对其进行访问。</li></ol></li><li class="lvl-4"><p>visitIdentifier</p><ol><li class="lvl-7">使用 <code>ctx.lookup</code> 来查找是否已经声明了具有相同名称的变量。</li><li class="lvl-7">如果没有，报错。否则将该标识符同样标记为已存在的变量</li></ol></li><li class="lvl-4"><p>visitAssignment</p><ol><li class="lvl-7">visit赋值语句的lhs（ident）</li><li class="lvl-7">visit赋值语句的rhs （expression）</li></ol></li></ul></li></ul><h3 id="中端">中端</h3><p>补充tacgen中的类似上述三个函数，由于已经通过了语义检查，这里的工作相对较少，基本上是tac寄存器的分配。</p><ul class="lvl-0"><li class="lvl-2"><p>visitDeclaration</p><ol><li class="lvl-5">获取 <code>decl</code> 的 ‘symbol’ 属性。</li><li class="lvl-5">使用 <code>mv.freshTemp</code> 获取一个新的临时变量用于该符号。</li><li class="lvl-5">如果声明具有初始值，使用 <code>mv.visitAssignment</code> 来设置它。</li></ol></li><li class="lvl-2"><p>visitIdentifier</p><p>将标识符 <code>ident</code> 的 ‘val’ 属性设置为标识符 <code>ident</code> 的 ‘symbol’ 属性的临时变量。</p></li><li class="lvl-2"><p>visitAssignment</p><ol><li class="lvl-5">访问表达式 <code>expr</code> 的右值，并获取左侧的临时变量。</li><li class="lvl-5">使用 <code>mv.visitAssignment</code> 发出一个赋值指令。</li><li class="lvl-5">将表达式 <code>expr</code> 的 ‘val’ 属性设置为赋值指令的值。</li></ol></li></ul><h3 id="后端">后端</h3><ul class="lvl-0"><li class="lvl-2"><p>assign语句实际上是特殊的binary操作，所以在riscvasmemitter中补充visitAssign即可，其他内容后端代码均已提供</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">visitAssign</span>(<span class="params">self, instr: Assign</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    self.seq.append(Riscv.Move(instr.dst, instr.src))</span><br></pre></td></tr></table></figure></li></ul><h2 id="思考题">思考题</h2><h3 id="1-写出一段-risc-v-汇编代码，将栈帧空间扩大-16-字节">1.写出一段 <strong>risc-v 汇编代码</strong>，将栈帧空间扩大 16 字节</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addi sp, sp, -16</span><br></pre></td></tr></table></figure><h3 id="2-如何修改以允许多次定义同名变量">2.如何修改以允许多次定义同名变量</h3><ul class="lvl-0"><li class="lvl-2"><p>目前declaration实现</p><ul class="lvl-2"><li class="lvl-4">语义检查（namer）中</li></ul><p>​    1. Use ctx.lookup to find if a variable with the same name has been declared.</p><p>​    2. If not, build a new VarSymbol, and put it into the current scope using ctx.declare.</p><p>​    3. Set the ‘symbol’ attribute of decl.</p><pre><code>   4. If there is an initial value, visit it</code></pre></li><li class="lvl-2"><p>修改方法</p><ol><li class="lvl-5">去掉开始对同名变量的检查</li><li class="lvl-5">首先visit赋值语句的init部分</li><li class="lvl-5">总是定义新的varSymbol</li></ol><p>在tacgen中，首先visit赋值语句的init部分，然后再进行定义。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> homework </category>
          
          <category> 编原 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lab </tag>
            
            <tag> 编原 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码学基础</title>
      <link href="/notes/network_security/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
      <url>/notes/network_security/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1>密码学基础</h1><h2 id="基本概念">基本概念</h2><ul class="lvl-0"><li class="lvl-2"><p>明文</p></li><li class="lvl-2"><p>密文</p></li><li class="lvl-2"><p>加密</p></li><li class="lvl-2"><p>解密</p></li><li class="lvl-2"><p>密码编码学</p></li><li class="lvl-2"><p>密码破译学</p></li><li class="lvl-2"><p>无条件安全</p></li><li class="lvl-2"><p>计算安全</p></li><li class="lvl-2"><p><mark>s-DES</mark>:<strong>必考内容</strong></p></li></ul><h2 id="密码编码学">密码编码学</h2><h3 id="密码编码学的三个特征">密码编码学的三个特征</h3><ol><li class="lvl-3"><p>转换明文为密文的运算类型：加密的两个原理</p><ul class="lvl-2"><li class="lvl-5">置换 (transposition)</li><li class="lvl-5">代换 (substitution)</li></ul></li><li class="lvl-3"><p>所用密钥数</p><ul class="lvl-2"><li class="lvl-5">对称加密</li><li class="lvl-5">非对称加密</li></ul></li><li class="lvl-3"><p>处理明文的方法</p><ul class="lvl-2"><li class="lvl-5">分组密码/块密码（block cipher）</li><li class="lvl-5">流密码 (stream cipher)</li></ul></li></ol><h3 id="密码编码学的历史">密码编码学的历史</h3><ul class="lvl-0"><li class="lvl-2"><p>古典密码：~1949</p><p>1949：香农论文</p></li><li class="lvl-2"><p>近代密码：~1976</p><p>1976：公钥出现</p><p>1977：RSA</p></li><li class="lvl-2"><p>现代密码</p></li></ul><h2 id="古典密码：代换">古典密码：代换</h2><blockquote><p>古典密码都是自然语言编码</p></blockquote><ul class="lvl-0"><li class="lvl-2"><h3 id="单表代换">单表代换</h3><ul class="lvl-2"><li class="lvl-4">恺撒码（+3）</li></ul></li><li class="lvl-2"><h3 id="多表代换">多表代换</h3><ul class="lvl-2"><li class="lvl-4"><p>playFair：</p><blockquote><p>5x5码表，I/J等价，同时编码两字母，同行右移，同列下移，对角线切换</p></blockquote></li><li class="lvl-4"><p>Hill</p><blockquote><p>C=KP mod26，K是nxn矩阵，同时对n个字母组成的向量加密</p></blockquote></li><li class="lvl-4"><p>Vigenere</p><p>多层凯撒，</p></li></ul></li></ul><h2 id="古典密码：置换">古典密码：置换</h2><p>转轮机</p><h2 id="s-DES">s-DES</h2><ul class="lvl-0"><li class="lvl-3"><p>S-DES加密算法的输入为一个8位明文组和一个10位的密钥，输出为8位的密文组。</p></li><li class="lvl-3"><p>S-DES解密算法的输入为一个8位密文组和一个10位的密钥，输出为8位的明文组。</p></li></ul><h3 id="核心思想：">核心思想：</h3><ol><li class="lvl-3"><p>明文拆成两个部分，各加密一次，相互参与对方的加密</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
          <category> network_security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> network_security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LabSignal01</title>
      <link href="/homework/signal_processing/%E4%BF%A1%E5%8F%B7%E5%8E%9F%E7%90%86Lab1/"/>
      <url>/homework/signal_processing/%E4%BF%A1%E5%8F%B7%E5%8E%9F%E7%90%86Lab1/</url>
      
        <content type="html"><![CDATA[<h1>信号原理Lab1</h1><p>郭高旭 <a href="mailto:ggx21@mails.tsinghua.edu.cn">ggx21@mails.tsinghua.edu.cn</a> 2021010803</p><h2 id="实验目的">实验目的</h2><p>通过对傅里叶级数的可视化，建立起对里叶级数如何近似周期函数的直观感受，同时练习傅里叶级数参数$a_0,a_n,b_n$的计算</p><h2 id="实验内容">实验内容</h2><p>补充程序内容,实现对<code>方波信号</code>和<code>半圆波信号</code>的可视化</p><h2 id="实验步骤">实验步骤</h2><ol><li class="lvl-3"><p>实现信号函数：</p><p>实现信号函数f(t)，传入自变量，返回函数值</p></li><li class="lvl-3"><p>计算傅里叶级数的系数<br>$$<br>a_n = \frac{2}{T} \int_{0}^{T} f(x) \cos\left(\frac{2\pi n x}{T}\right) dx\<br>b_n = \frac{2}{T} \int_{0}^{T} f(x) \sin\left(\frac{2\pi n x}{T}\right) dx\<br>a_0 = \frac{1}{T} \int_{0}^{T} f(x) dx<br>$$</p><ul class="lvl-2"><li class="lvl-5"><p>对于方波信号来说，傅里叶级数的计算比较简单即<br>$$<br>a_0=0.5;a_n=0;b_n=\frac {2}{n\pi},n\in奇，=0，n\in 偶<br>$$</p></li><li class="lvl-5"><p>对于半圆波来说，除了$a_0=\frac {\pi^2}{4}$易得外，系数不太好得出解析解，故采用了<code>scipy.integrate</code>包带入公式求解,具体内容见代码.</p></li></ul></li><li class="lvl-3"><p>将N_Fourier改为2,4,8,16,32,64,128，得到不同傅里叶级数的可视化结果</p><p>建立一个数组，遍历执行visualize即可</p></li></ol><h2 id="实验现象">实验现象</h2><ul class="lvl-0"><li class="lvl-2"><p>视频中的红线基本上平行于x轴</p></li><li class="lvl-2"><p>随着N_Fourier取值增加，红线更加平行</p></li></ul><h2 id="实验结论">实验结论</h2><ul class="lvl-0"><li class="lvl-2"><p>傅里叶级数确实可以近似周期函数，随着n的增加，近似程度更高。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> homework </category>
          
      </categories>
      
      
        <tags>
            
            <tag> homework </tag>
            
            <tag> signal_processing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/notes/flower_identification/%E5%A6%82%E4%BD%95%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%AA%E8%A1%8C%E4%B8%9A/"/>
      <url>/notes/flower_identification/%E5%A6%82%E4%BD%95%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%AA%E8%A1%8C%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[<h1>如何了解一个行业</h1><ul class="lvl-0"><li class="lvl-2"><p>商品分类</p><ul class="lvl-2"><li class="lvl-4"><p>周期品:上游大宗,价格是核心驱动因素</p><p>回报率比较低,回报周期比较长</p><blockquote><p>回报周期比较长,难以停止生产,产能过剩</p></blockquote></li><li class="lvl-4"><p>非周期品:下游消费品</p><p>消费品:看不见的手控制</p><p>具备差异化–&gt;来源于xx因素</p></li><li class="lvl-4"><p>其他:金融\科技等</p></li></ul></li><li class="lvl-2"><p>重资产,后发优势(产品无差异性?)–&gt;垃圾</p><p>后面的容易通过更重资产拍死前浪</p></li><li class="lvl-2"><p>关注行业成长的不同时期,行业的位置并不固定</p></li></ul><p>制造业和科技业的差异是很大的</p><ul class="lvl-0"><li class="lvl-2"><p>制造业在于证实</p></li><li class="lvl-2"><p>非制造业在于不能证伪</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>deadlines</title>
      <link href="/homework/ddls-2023%E7%A7%8B/"/>
      <url>/homework/ddls-2023%E7%A7%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>日拱一卒未有尽，​      功不唐捐终到海。</p></blockquote><details> <summary><b>图例</summary><div class="danger"><p>时间紧，任务重，I’m f**ked up</p></div><div class="warning"><p>时间不多了,under pressure</p></div><div class="tips"><p>时间还早,totally under control</p></div><div class="success"><p>写完了😄</p></div></details><h2 id="发现红框没有被check，可以来压力我😄">发现红框没有被check，可以来压力我😄</h2><div class="danger"><ul class="lvl-1"><li class="lvl-2"><p><input type="checkbox" id="checkbox0"><label for="checkbox0">bug</label></p></li></ul></div><hr><div class="warning"><ul class="lvl-1"><li class="lvl-2"><p><input type="checkbox" id="checkbox1"><label for="checkbox1">计原大实验——12/15</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox2"><label for="checkbox2">计原lab3——10/24</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox3"><label for="checkbox3">计原lab4——11/7</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox4"><label for="checkbox4">计原lab5——11/7</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox5"><label for="checkbox5">计原lab6——11/21</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox6"><label for="checkbox6">编原stage2实验报告——10/29</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox7"><label for="checkbox7">编原stage3实验报告——11/12</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox8"><label for="checkbox8">编原stage4实验报告——11/26</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox9"><label for="checkbox9">编原stage5——12/24</label></p></li></ul></div><hr><div class="tips"><ul class="lvl-1"><li class="lvl-2"><p><input type="checkbox" id="checkbox10"><label for="checkbox10">花卉调查报告——11/05</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox11"><label for="checkbox11">课程论文——10/22</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox12"><label for="checkbox12">每日花卉赏析——10/19</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox13"><label for="checkbox13">鹅掌楸的果实–C楼附近</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox14"><label for="checkbox14">拍点清楚的紫荆</label></p></li></ul></div><hr><div class="success"><ul class="lvl-1"><li class="lvl-2"><p>[ ]</p></li></ul></div>]]></content>
      
      
      <categories>
          
          <category> homework </category>
          
      </categories>
      
      
        <tags>
            
            <tag> homework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随机掉落</title>
      <link href="/articles/%E8%AF%BB%E5%90%8E%E6%84%9F%E6%9D%90%E6%96%99/"/>
      <url>/articles/%E8%AF%BB%E5%90%8E%E6%84%9F%E6%9D%90%E6%96%99/</url>
      
        <content type="html"><![CDATA[<h1>读后感材料</h1><p>在这篇读后感中，包括但不限于以下内容：为何这5个“故事”让你最受触动？从你的视角看，影响学长学姐们职业选择结果的因素有哪些？影响一个人追随“大多数人走的路”或者采取“少有人走的路”的因素是什么？他们是如何面对职业选择中的不确定性的？他们职业探索的经历，大学生活的安排，让刚刚开始职业探索的你，产生了怎样的收获与思考？你是否设想过自己会以怎样的方式离开清华呢？请将读后感控制在2000字以内（每个小故事的感受平均400字）。</p><p>很幸运我在大三上这一节点选择了“职业规划与发展”这门课。这学期一开学，明显感受到自己与身边同学的变化：大家更加为未来而焦虑，为“如何离开清华”而焦虑。上周一课后大家围住老师激烈讨论就很能证明这一点。浏览过《离开清华的110种方式》后，选出了5个最让我触动的5个代表性的故事。</p><h2 id="姚颂，电子系-毕业后与大学导师和同学联合创立人工智能芯片公司深鉴科技">姚颂，电子系,毕业后与大学导师和同学联合创立人工智能芯片公司深鉴科技</h2><p>从学生视角看，姚颂的清华生活不得不说是比较成功的。学习上成绩位于年级前5%，科研上也早早发了多篇paper，社工、体育、音乐等领域也同样发光发热。</p><p>但是他这样的成功者也一样曾经迷茫，可能遇到挫折与失败。促使他毕业后选择创业这条“少有人走的路”的原因，除了他个人能力与对创业的准备，很大的因素来源于外部——他的standford的offer被拒了。</p><p>从各个角度看，能得到Standford的offer真是大多同学（包括我）心中“继续深造”这条“大多数人走的路”中最成功的一条。但是正如姚颂谈及他在大一C++课程上学习到的“贪婪算法”一样“步步为了当前最优来选择，却往往是局部最优解，不是一个全局最优解”。他说：“大家都希望自己是那个出类拔萃的人，却在人生的各个阶段都是按部就班，只为了眼前，都和大家一样，这样出类拔萃也就更难了。”</p><p>我当然很羡慕这样的校园生活，也会常常这样想“我刚上大学时也这样努努力就好了”。实际上,同样大一C++课程中接触到&quot;贪婪算法&quot;时,我也产生了许多感悟。一方面我认同步步为了当前最优来选择，不能达到全局最优解。但另一方面，“贪婪算法”同时也告诉我们，在面对一个相当复杂的问题时，找到全局最优的代价往往是不能接受的。我想，或许人生就是一个相当复杂的问题。</p><p>没有拿到Stanford的offer在当时让他绝望，可是回头看看这给他打开了另一扇大门，可能让他有了更好的未来。他总结到积极地分析，谨慎地探索，去把路走对。</p><p>这在当时让他一度绝望，但是姚颂说塞翁失马焉知非福，很多情况下你觉得正确的那条道路只不过是随着惯性走下去性价比最高的一条（局部最优）。没有拿到Stanford的offer在当时让他绝望，可是回头看看这给他打开了另一扇大门，可能让他有了更好的未来。积极地分析，谨慎地探索，去把路走对。</p><h3 id="为长远准备-不只为眼前准备">为长远准备,不只为眼前准备</h3><p>在创业后，再回到清华做报告或者和一些同学交流，发现大多数同学也依旧还是只关注眼前，只关注成绩、保研、找工作，每次都只能考虑最近一两年的事情。确实学业的压力很大，同时同学们接触外部信息又不够，我在大一、大二时对于未来工作是什么同样毫无概念。这让我想到了大一C++课程上讲的“贪婪算法”，步步为了当前最优来选择，却往往是局部最优解，不是一个全局最优解。而从另一个角度说，大家都希望自己是那个出类拔萃的人，却在人生的各个阶段都是按部就班，只为了眼前，都和大家一样，这样出类拔萃也就更难了。</p><blockquote><p>实际上,同样大一C++课程中接触到&quot;贪婪算法&quot;时,我也产生了许多感悟。一方面我认同步步为了当前最优来选择，却往往是局部最优解，不是一个全局最优解。但另一方面，“贪婪算法”同时也告诉我们，在面对一个相当复杂的问题时，找到全局最优的代价往往是不能接受的。我想，或许人生就是一个相当复杂的问题。</p></blockquote><h3 id="由于没有拿到Stanford的offer转而创业">由于没有拿到Stanford的offer转而创业</h3><p>姚颂说塞翁失马焉知非福，很多情况下你觉得正确的那条道路只不过是随着惯性走下去性价比最高的一条（局部最优）。没有拿到Stanford的offer在当时让他绝望，可是回头看看这给他打开了另一扇大门，可能让他有了更好的未来。积极地分析，谨慎地探索，去把路走对。</p><h2 id="林声巧-p121">林声巧 p121</h2><p>毕业后前往德州大学奥斯汀分校攻读博士学位</p><p>在一种“富贵非吾愿，帝乡不可期”的情结里，整个大三下到大四上都陷入了“胡为乎遑遑欲何之”的迷茫里。</p><p>身边有一些“人生方向感”十足的朋友，从大一开始就很清楚地知道，自己想做什么，以及每一年应该如何规划。这种对人生十足掌握背后是个人的努力、家庭成长环境培养的眼界以及前辈提供的信息和指引。</p><blockquote><p>林为了offer焦虑，到最后依然焦虑，为焦虑前程而脱发。</p></blockquote><h2 id="沈晓东-P128-做“小三毛们”的校长，只要是自己的选择，我就能坚定地走下去">沈晓东 P128 做“小三毛们”的校长，只要是自己的选择，我就能坚定地走下去</h2><p>毕业后任教于乡村小学。</p><p>我相信的从始至终就只有我自己。对我来说，什么是正确的，是由我自己决定的。我愿意相信的事我会全力去相信这跟其他因素没有一点关系。能否相信一个人，说到底就是你能不能相信自己，就这么简单。</p><blockquote><p>他的最终选择，除了从小受《三毛流浪记》影响而产生的“办一所专门帮助运气不好但有志于学的孩子们的学校”志向，还来自于光爱学校创始人“石先生”的影响<mark>修改</mark>。最终迈向少有人走的路</p></blockquote><h2 id="陈超P111-到华为去——翻过那座山，他们就能听到我们的故事">陈超P111 到华为去——翻过那座山，他们就能听到我们的故事</h2><h3 id="求职：我只想去华为">求职：我只想去华为</h3><p>在求职季，只投出一份简历，因为他只想去华为。吸引他的有两方面：华为“勇敢新世界”的口号与华为老板任正非拥有的“韧性与不服输精神”的人格魅力。</p><h2 id="你是否设想过自己会以怎样的方式离开清华呢？">你是否设想过自己会以怎样的方式离开清华呢？</h2><p>大体翻了翻，大家都很成功。和同学们在紫操喝着酒聊起未来，我常常这样开玩笑“争取保研呗，保不上就找个班上得了”。大概已经忘记了小时候许下的“创造出改变世界的东西”一样的宏愿。</p>]]></content>
      
      
      <categories>
          
          <category> articles </category>
          
      </categories>
      
      
        <tags>
            
            <tag> THU </tag>
            
            <tag> THU-daily </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stage1</title>
      <link href="/homework/compiler_construction/stage1/"/>
      <url>/homework/compiler_construction/stage1/</url>
      
        <content type="html"><![CDATA[<h1>stage-1</h1><p>郭高旭 <a href="mailto:ggx21@mails.tsinghua.edu.cn">ggx21@mails.tsinghua.edu.cn</a> 2021010803</p><h2 id="实验内容">实验内容</h2><p>跟着文档阅读学习实验框架代码.</p><p><strong>实验步骤：通过例子学习编译全流程 - Step1</strong></p><ol><li class="lvl-3"><p>词法分析 &amp; 语法分析</p><ul class="lvl-2"><li class="lvl-5">使用lex/yacc库将C程序字符流转化为AST。</li></ul></li><li class="lvl-3"><p>语义分析</p><ul class="lvl-2"><li class="lvl-5">检查是否存在主函数。</li></ul></li><li class="lvl-3"><p>中间代码生成</p><ul class="lvl-2"><li class="lvl-5">将AST翻译为三地址码（TAC），提取返回语句的常量。</li></ul></li><li class="lvl-3"><p>目标代码生成</p><ul class="lvl-2"><li class="lvl-5">将TAC翻译为32位RISC-V汇编代码，设置返回值为2023。</li></ul></li></ol><h3 id="stage-1">stage-1</h3><p>整个stage-1的实验内容就是完成常量表达式<code>expression</code>的语法编译.具体而言包括</p><ul class="lvl-0"><li class="lvl-2"><p>一元表达式</p></li><li class="lvl-2"><p>二元表达式</p></li><li class="lvl-2"><p>比较和逻辑表达式</p></li></ul><h4 id="实验思路">实验思路</h4><ul class="lvl-0"><li class="lvl-2"><p>定义 新增的<code>Unary</code>、<code>TacUnaryOp</code>、<code>RvUnaryOp</code> (以及BinaryOp)三种不同的一元(二元)运算符类型,如下例所示</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/a8aab4e8ed73cb1ce1a702dc25b11452/202310051745547.png" alt="image-20231005174527404"></p></li><li class="lvl-2"><p>确定<code>astOp</code>–<code>tacOp</code>–<code>risvOp</code>的对应关系</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/5d7e1297e51785ef74e93b6690eb618a/202310051747958.png" alt="image-20231005174712927"></p></li><li class="lvl-2"><p>frontend/tacgen时设计中间代码(TAC)表示</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/6ed25b55c0bcb0d24882d849e49a9230/202310051752123.png" alt="image-20231005175230094"></p></li><li class="lvl-2"><p>后端代码生成:</p><p>我将 riscv和ast不能一一对应的语法提前在上一步TAC表示时处理好,所以TAC生成后端代码时只需要添加操作符并构建好操作符间一一对应关系即可.</p></li></ul><h2 id="step-1">step-1</h2><h4 id="1-没有namer-transform-typer-transform步骤，以下代码能正常编译吗">1.没有<code>namer.transform</code>, <code>typer.transform</code>步骤，以下代码能正常编译吗</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答：可以正常编译，<code>namer</code>和<code>typer</code>的作用分别是符号表构建和类型检查,而上述代码根本没有用到变量也没有额外<code>scope</code>,故不需要构建符号表,也不需要类型检查.所以仍然能正常编译出tac结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FUNCTION&lt;main&gt;:</span><br><span class="line">    _T0 = 233</span><br><span class="line">    return _T0</span><br></pre></td></tr></table></figure><h4 id="2-对于main函数没有返回值的情况是在哪一步处理的？报的是什么错？">2.对于main函数没有返回值的情况是在哪一步处理的？报的是什么错？</h4><p><code>main.py</code>，调用 <code>frontend.parser.parser</code>来完成语法分析的工作.<code>parser</code>模块中定义了return语句的语法结构,如下所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">p_return</span>(<span class="params">p</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    statement_matched : Return expression Semi</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    p[<span class="number">0</span>] = Return(p[<span class="number">2</span>])</span><br></pre></td></tr></table></figure><p>这一函数的docstring中定义了return的语法结构,要求<code>return+expression+&quot;;&quot;</code>缺失expression将报错Syntax error</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Syntax error: line 1, column 20</span><br><span class="line">int main() &#123; return; &#125;</span><br><span class="line">Syntax error: line 1, column 22</span><br><span class="line">int main() &#123; return; &#125;</span><br><span class="line">Syntax error: EOF</span><br></pre></td></tr></table></figure><h4 id="3-为什么框架定义了-Unary、TacUnaryOp、RvUnaryOp-三种不同的一元运算符类型？">3.为什么框架定义了 <code>Unary</code>、<code>TacUnaryOp</code>、<code>RvUnaryOp</code> 三种不同的一元运算符类型？</h4><p>这对应了MiniDecaf 编译器的三个部分：前端、中端、后端。每种运算符用来构造不同部分的语法树的结点.</p><ul class="lvl-0"><li class="lvl-2"><p><strong>Unary</strong>:通过编译器前端，可以读入 MiniDecaf 源程序，然后通过<strong>词法分析</strong>和<strong>语法分析</strong>将源程序转化为一个<strong>抽象语法树(AST)</strong></p></li><li class="lvl-2"><p><strong>TacUnaryOp</strong>:中端通过扫描 AST 生成中间代码 —— <strong>三地址码(TAC)</strong></p></li><li class="lvl-2"><p><strong>RvUnaryOp</strong>:后端将三地址码转换为 <strong>RISC-V 汇编代码</strong></p></li></ul><h2 id="step-2">step-2</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-(~2147483647)</span><br></pre></td></tr></table></figure><h2 id="step-3">step-3</h2><p>左操作数<code>-2147483648</code>,右操作数<code>-1</code>,此时RISCV-32 的 qemu 模拟器运行结果是</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2021010803@compiler-lab:~/lab/minidecaf-2021010803/test$ qemu-riscv32 a.out</span><br><span class="line">-2147483648</span><br></pre></td></tr></table></figure><p>在我x86-64的系统中报错</p><p><code>Floating point exception</code></p><h2 id="step-4">step-4</h2><ol><li class="lvl-3"><p><strong>性能优化</strong>：短路求值可以在某个条件已经确定的情况下避免不必要的计算。如果在逻辑表达式中的某个条件已经能够确定整个表达式的值，那么后续的条件将不会被计算，从而提高了程序的性能和效率。</p></li><li class="lvl-3"><p><strong>避免副作用</strong>：在某些情况下，逻辑表达式中的条件可能包含副作用，例如函数调用或变量修改。通过短路求值，可以确保只有在必要时才会执行这些副作用，避免不必要的操作，从而增强了程序的可维护性和可预测性。</p></li><li class="lvl-3"><p><strong>代码简洁性</strong>：使用短路求值可以编写更简洁、更具可读性的代码。程序员可以使用逻辑表达式来表达条件，而无需手动添加额外的控制结构，例如if语句。</p></li><li class="lvl-3"><p><strong>错误避免</strong>：通过短路求值，可以避免一些潜在的错误，例如除以零或访问未初始化的变量。如果某个条件可以确定表达式的结果，那么不会发生这些错误。</p></li><li class="lvl-3"><p><strong>逻辑简化</strong>：在某些情况下，短路求值可以使逻辑更简单和更直观。程序员可以使用短路求值来表达逻辑条件，而无需手动构建复杂的条件组合。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> homework </category>
          
          <category> 编原 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> lab </tag>
            
            <tag> 编原 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lab2</title>
      <link href="/homework/computer_orgnization/lab2/"/>
      <url>/homework/computer_orgnization/lab2/</url>
      
        <content type="html"><![CDATA[<h1>实验二</h1><p>郭高旭 <a href="mailto:ggx21@mails.tsinghua.edu.cn">ggx21@mails.tsinghua.edu.cn</a> 2021010803</p><h2 id="实验报告">实验报告</h2><ul class="lvl-0"><li class="lvl-2"><h4 id="仿真截图">仿真截图</h4><img src="https://gitlab.com/ggx-blog/imglab/uploads/c17e96e795aff020dcc4ea8c0d80ca73/202310021713613.png" alt="image-20231002145428181" style="zoom: 50%;" /></li><li class="lvl-2"><h3 id="在线实验平台">在线实验平台</h3><img src="https://gitlab.com/ggx-blog/imglab/uploads/51e50fc87612f90a9ae1c529704ffd0e/202310021458363.png" alt="image-20231002145843251" style="zoom: 50%;" /></li></ul><h2 id="思考题">思考题</h2><ul class="lvl-0"><li class="lvl-2"><h3 id="同步逻辑的电路原理图">同步逻辑的电路原理图</h3><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/913ac109bd94ea7abf17f78b9278a05b/202310021619164.png" alt=""></p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/a0c159e24a93fca321af418a21732ae1/202310021622970.png" alt="image-20231002162245902"></p></li><li class="lvl-2"><h3 id="异步逻辑的电路原理图">异步逻辑的电路原理图</h3><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/ba129e270f1b57944dc06edf1e90730a/202310021628504.png" alt="image-20231002162808433"></p></li><li class="lvl-2"><h3 id="异步逻辑和同步逻辑的异同">异步逻辑和同步逻辑的异同</h3><p>从图像中可以看出，两种逻辑实现经 Vivado 综合后的电路原理图有较大不同。同步逻辑实现中，counter模块和trigger模块<strong>并联</strong>同时接受clock_gen生成的clk信号驱动，这意味着它们在同一个时钟域中操作，所有的触发器在时钟的上升沿或下降沿触发，确保了时序一致性。；而异步实现中，则是类似于<strong>串联</strong>结构，clockgen并不直接接入counter模块，而是通过驱动trigger模块，再有trigger模块产生的trigger信号接入counter模块。</p><p><strong>异步逻辑设计</strong>，没有全局统一时钟驱动的逻辑设计。异步逻辑在复杂的项目中，会导致静态时序分析失败，造成在硬件上难以调试的时序问题，此外，在异步逻辑中，通常需要使用额外的逻辑电路（如触发器或者双边缘触发器）来协调计数器模块和触发器模块之间的时序关系。这可能导致电路结构更加复杂，需要特殊的电路设计技巧来解决时序问题。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> homework </category>
          
          <category> cod </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cod </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>week2-1</title>
      <link href="/notes/flower_identification/%E8%8A%B1%E5%8D%89%E9%89%B4%E8%B5%8F%E7%AC%94%E8%AE%B00/"/>
      <url>/notes/flower_identification/%E8%8A%B1%E5%8D%89%E9%89%B4%E8%B5%8F%E7%AC%94%E8%AE%B00/</url>
      
        <content type="html"><![CDATA[<h1>花卉鉴赏笔记</h1><h3 id="名词解释">名词解释</h3><ul class="lvl-0"><li class="lvl-2"><p>花序</p><blockquote><p>朵花按照一定次序排列的花枝，这段花枝顶生或侧生于茎上。相对的概念是单生花，是指一朵花单独顶生或侧生于茎上</p></blockquote></li><li class="lvl-2"><p>合瓣花（亚纲）&lt;–&gt;离瓣花</p></li><li class="lvl-2"><p>可育花–&gt;不育花</p></li><li class="lvl-2"><p>苞片</p><blockquote><p><em>苞片</em>指长在单生花或花序的柄梗处，且在花萼以下正常营养叶以上的变形特化叶</p></blockquote></li></ul><h3 id="知识点">知识点</h3><ul class="lvl-0"><li class="lvl-2"><p>花萼、雄蕊甚至雌蕊都可能特化成花瓣形状</p></li><li class="lvl-2"></li><li class="lvl-2"><p>绒球状的花如合欢,含羞草的花常常是豆科含羞草亚科,绒球是雄蕊</p></li></ul><h3 id="回去找找">回去找找</h3><ul class="lvl-0"><li class="lvl-2"><p>杜仲</p></li><li class="lvl-2"><p>蒙古栎（医学院东侧，果期9-10月）</p></li><li class="lvl-2"></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;aside epub:type=&quot;footnote&quot; id=&quot;footnote-4-95&quot;&gt;60华氏度≈15.6摄氏度。——编者注&lt;/aside&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
          <category> flowers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flowers </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>week2</title>
      <link href="/notes/database_intro/week2/"/>
      <url>/notes/database_intro/week2/</url>
      
        <content type="html"><![CDATA[<h1>week1-2</h1><ul class="lvl-0"><li class="lvl-2"><p>异步写（不得不写）</p></li><li class="lvl-2"><p>提交</p><p>跟数据有关的日志信息已经更新到磁盘上</p><p>日志是同步写的</p></li><li class="lvl-2"></li></ul>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> database </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>week1-2</title>
      <link href="/notes/artificial_network/week1/"/>
      <url>/notes/artificial_network/week1/</url>
      
        <content type="html"><![CDATA[<h1>week1-2</h1>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
          <category> signal </category>
          
      </categories>
      
      
        <tags>
            
            <tag> signal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>week1</title>
      <link href="/homework/computer_orgnization/week1-2/"/>
      <url>/homework/computer_orgnization/week1-2/</url>
      
        <content type="html"><![CDATA[<h1>实验一</h1><p>郭高旭 <a href="mailto:ggx21@mails.tsinghua.edu.cn">ggx21@mails.tsinghua.edu.cn</a> 2021010803</p><h2 id="实验报告">实验报告</h2><ul class="lvl-0"><li class="lvl-2"><h4 id="实验一">实验一</h4><ul class="lvl-2"><li class="lvl-4"><p>代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">la a0, 0x80400000</span><br><span class="line">li t0, 10</span><br><span class="line">li t3, 1</span><br><span class="line">li t2, 1</span><br><span class="line"></span><br><span class="line">loop:</span><br><span class="line">sw t3, 0(a0)</span><br><span class="line">add t3, t1, t2</span><br><span class="line">addi a0, a0, 4</span><br><span class="line">addi t0, t0, -1</span><br><span class="line">mv t1,t2</span><br><span class="line">mv t2,t3</span><br><span class="line">bnez t0, loop</span><br><span class="line">li a7, 10</span><br><span class="line">jr ra</span><br></pre></td></tr></table></figure></li><li class="lvl-4"><p>结果</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/e9ded4b40a999d3c46159a61617989ee/202309221828154.png" alt="image-20230922182821127"></p></li></ul></li><li class="lvl-2"><h4 id="实验二">实验二</h4><ul class="lvl-2"><li class="lvl-4"><p>代码与结果</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/a05e736febd06d9f31c4b67db8763379/202309221830179.png" alt="image-20230922183018142"></p></li></ul></li><li class="lvl-2"><h4 id="实验三">实验三</h4><ul class="lvl-2"><li class="lvl-4"><p>代码与结果（高八位<code>0x00000168</code>低八位<code> 0x6c8312d0</code>）</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/10cfe5b5a7ca23a4abbf6fc6ac0685f7/202309221832365.png" alt=""></p></li></ul></li></ul><h3 id="代码分析：">代码分析：</h3><h4 id="term：">term：</h4><ul class="lvl-0"><li class="lvl-2"><p>结构</p><ol><li class="lvl-5"><strong>test_programs函数</strong>：该函数用于检查是否可以运行所需的程序，如汇编器、反汇编器和二进制拷贝工具。</li><li class="lvl-5"><strong>output_binary函数</strong>：用于将二进制数据写入标准输出，兼容Python 2和Python 3。</li><li class="lvl-5"><strong>int_to_byte_string和byte_string_to_int函数</strong>：用于将整数和字节字符串相互转换。</li><li class="lvl-5"><strong>multi_line_asm和single_line_disassmble函数</strong>：这两个函数用于将汇编代码转换为二进制指令和将二进制指令反汇编为汇编代码。它们使用了系统中安装的汇编器和反汇编器。</li><li class="lvl-5"><strong>run_T、run_A、run_F、run_R、run_D、run_U、run_G函数</strong>：这些函数是与RISC-V处理器进行交互的主要函数。例如，<code>run_T</code>用于打印页表信息，<code>run_A</code>用于写入汇编指令，<code>run_R</code>用于读取寄存器的值，<code>run_D</code>用于显示内存内容，<code>run_U</code>用于读取内存内容并反汇编，<code>run_G</code>用于运行用户程序。</li><li class="lvl-5"><strong>MainLoop函数</strong>：这是程序的主循环，用于接收用户输入的命令并执行相应的操作。</li><li class="lvl-5"><strong>InitializeSerial和InitializeTCP函数</strong>：用于初始化串口或TCP连接，根据命令行参数选择不同的初始化方式。</li><li class="lvl-5"><strong>Main函数</strong>：程序的入口点，根据命令行参数选择串口或TCP连接，然后进入主循环。</li></ol></li><li class="lvl-2"><p>交互：见思考题第五问</p></li></ul><h4 id="kernel：">kernel：</h4><ul class="lvl-0"><li class="lvl-2"><p>结构</p><ul class="lvl-2"><li class="lvl-4"><pre><code class="language-apl">evec.s #监控程序的入口点，是最先执行的代码init.S #初始化,主要工作是为kernel分配资源kernel32.ldkernel64.ldshell.S #主要功能实现test.S #trap.S #定义了一些报错的消息utils.S #读写串口的功能<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 交互:同样见思考题的4,5问</span><br><span class="line"></span><br><span class="line">## 思考题</span><br><span class="line"></span><br><span class="line">### 1.risc-v与x86寻址方式异同</span><br><span class="line"></span><br><span class="line">#### 异</span><br><span class="line"></span><br><span class="line">1. **复杂寻址模式：** RV32I省略了x86-32中存在的复杂寻址模式。x86-32提供了多种寻址模式，例如基址寻址、间接寻址等，而RV32I采用了更简单的模式，只支持基地址寄存器和立即数的组合。</span><br><span class="line">2. **歧视数据类型：** RV32I的寻址模式不会歧视任何数据类型，可以用于加载和存储不同类型的数据，而x86-32的寻址模式可能需要根据数据类型进行调整。</span><br><span class="line">3. **堆栈指令：** x86-32提供了特殊的堆栈指令，例如push和pop，用于堆栈操作。相比之下，RV32I没有专门的堆栈指令，而是借助通用寄存器来实现堆栈操作。</span><br><span class="line"></span><br><span class="line">#### 同</span><br><span class="line"></span><br><span class="line">加载和存储的支持寻址模式是符号扩展 12 位立即数到基地址寄存器(在risc-v中是唯一支持的寻址模式)</span><br><span class="line"></span><br><span class="line">### 2.阅读监控程序，列出监控程序的 19 条指令，请根据自己的理解对用到的指令进行分类，并说明分类原因。</span><br><span class="line"></span><br><span class="line">- 运算类</span><br><span class="line"></span><br><span class="line">  ADD: ADDI, AND, ANDI, OR, ORI, SLLI, SRLI, XOR，AUIPC</span><br><span class="line"></span><br><span class="line">- 跳转控制类</span><br><span class="line"></span><br><span class="line">  BEQ: BNE，JAL，JALR</span><br><span class="line"></span><br><span class="line">- save&amp;load类</span><br><span class="line"></span><br><span class="line">  LB: LW，LUI，SB，SW</span><br><span class="line"></span><br><span class="line">  lui主要是为了构造一个足够大的立即数</span><br><span class="line"></span><br><span class="line">- 分类原因</span><br><span class="line"></span><br><span class="line">  分类方法对应着冯诺依曼架构计算机**（运算器、控制器、存储器、输入设备、输出设备）**，不考虑输入输出设备，运算类对应运算器，跳转控制类对应控制器，sl类对应存储器</span><br><span class="line"></span><br><span class="line">### 3.term 是如何实现用户程序计时的。</span><br><span class="line"></span><br><span class="line">在term.py的run_G函数是在kernel中执行用户risc-v汇编程序的主要代码</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">def run_G(addr):</span><br><span class="line">    # ...</span><br><span class="line">    time_start = timer()</span><br><span class="line">    while True:</span><br><span class="line">        ret = inp.read(1)</span><br><span class="line">        if ret == b&#x27;\x07&#x27;:</span><br><span class="line">            break</span><br><span class="line">        elif ret == b&#x27;\x81&#x27;:</span><br><span class="line">            print(&#x27;killed timeout program.&#x27;)</span><br><span class="line">            break</span><br><span class="line">        elif ret == b&#x27;\x80&#x27;:</span><br><span class="line">            trap()</span><br><span class="line">        output_binary(ret)</span><br><span class="line">    print(&#x27;&#x27;) #just a new line</span><br><span class="line">    elapse = timer() - time_start</span><br><span class="line">    print(&#x27;elapsed time: %.3fs&#x27; % (elapse))</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ul><p>在kernel/common.h处定义了如下几个信号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SIG_TIMERSET    0x06        <span class="comment">// ascii (ACK) 启动计时</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIG_TIMETOKEN   0x07        <span class="comment">// ascii (BEL) 停止计时</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIG_FATAL       0x80        <span class="comment">// 严重错误</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIG_TIMEOUT     0x81        <span class="comment">// 超时</span></span></span><br></pre></td></tr></table></figure><p>在kernel/shell.s中的.OP_G:部分定义了kernel如何判断程序是否超时</p><ul class="lvl-0"><li class="lvl-2"><p><code>li a0, SIG_TIMERSET(0x06)</code>,<em>写开始计时信号</em>,告诉终端用户程序开始运行</p></li><li class="lvl-2"><p>首先，它获取当前 <code>mtime</code> 计时器的值保存 <code>t1</code>（RV32）中。</p></li><li class="lvl-2"><p>然后，它将一个固定值 <code>10000000</code> 添加到 <code>mtime</code>，以表示用户程序的最大允许运行时间。</p></li><li class="lvl-2"><p>接着，它将新的值写入 <code>mtimecmp</code> 计时器比较寄存器，以设置超时时间。</p></li><li class="lvl-2"><p>如果 RV32 架构，它还会检查进位并更新高 32 位的 <code>mtimecmp</code> 寄存器。</p></li><li class="lvl-2"><p>如果超时,跳转到trap.s的userret_timeout,发送超时信号(0x81)</p></li></ul><h3 id="4-说明-kernel-是如何使用串口的。">4.说明 kernel 是如何使用串口的。</h3><p>主要使用了utsil.s中<code>WRITE_SERIAL</code> 和<code>read_serial</code>两个函数</p><ul class="lvl-0"><li class="lvl-2"><p><code>WRITE_SERIAL</code> 函数负责向串口发送数据。它会不断检查串口是否就绪，一旦就绪，就将数据写入串口的传输寄存器。</p></li><li class="lvl-2"><p><code>READ_SERIAL</code> 函数用于从串口接收数据。它会不断检查串口是否有可读数据，一旦有数据可读，就将数据从串口的接收寄存器读取出来。</p></li></ul><p>这两个函数都采用了忙等待的方式，也就是它们会一直等待串口准备好（写入或读取），然后再执行相应的操作。</p><h3 id="5-请问-term-如何检查-kernel-已经正确连入，并分别指出检查代码在-term-与-kernel-源码中的位置。">5.请问 term 如何检查 kernel 已经正确连入，并分别指出检查代码在 term 与 kernel 源码中的位置。</h3><ul class="lvl-0"><li class="lvl-2"><h4 id="判断正确连入">判断正确连入</h4><ol><li class="lvl-5">通过<strong>InitializeTCP</strong>函数与kernel建立tcp链接</li><li class="lvl-5">在主函数中使用test_program检查Term 所需的三个外部程序是否可以正常使用</li><li class="lvl-5">在main函数中尝试读取来自内核的前33个字节信息(欢迎消息)</li><li class="lvl-5">在main函数中会使用 <code>outp.write(b'W')</code> 发送一个 <code>'W'</code> 命令，以探测内核的 XLEN（字长）设置：</li><li class="lvl-5">进入主循环(读取用户终端输入)</li></ol></li><li class="lvl-2"><h4 id="检查代码在term中的位置">检查代码在term中的位置</h4><p>主要是test_program和main两个函数</p></li><li class="lvl-2"><h4 id="在kernel中的位置">在kernel中的位置</h4><p>kernel不需要特地检查是否已经与term进行了tcp链接,kernel只是在开始或者每次成功处理指令后跳转到<code>read_serial</code>检测串口是否有输入</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
          <category> cod </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cod </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>week1-2</title>
      <link href="/notes/computer_orgnization/week1-2/"/>
      <url>/notes/computer_orgnization/week1-2/</url>
      
        <content type="html"><![CDATA[<h1>week1-2</h1><p>malloc出来的动态数据放在heap中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQD9WcsWyYPepXxB9/uB7XCzrr06XIxhsh97M358hCDb2u/B30cvcHrNnnrZWy9dReblhLNoqGT2SrtfIz3SeYmO3u2fHerfChGp0ey3UCW1j8BbLcA1LMbVtHl5t8MPQ8RAalhIDIN3A20r0S79V8artkQcb8TN9unHG3MKzbnyxW1W5VMBXGVL4UXJgD3L1mYM30V/Ud3yCgBVnL4BVYthBo7Ad6XX5BJcp15VtL2KcFsrRCDLsrYGTCxnzezX/8KPe/d8wzr2hanVL/VVXvqMJ6PsJSG3s7i8RJe1YGbX3qQSgWWBdQr6BLHPewu2Un8Vq2saEEAKDan2eOiMEtpzqv4/gPPMk5qEYJZ14tBp8yxPf0wMEtd49f7iMpJiXyoRQ7/GA/MFuZuGh31cYPxjNLBbWfIQB1NfPqLwgSpPxt9NSGLM8T0lYcHoBV4MCOs/LbZFky1u36E12A9wvqsOOCeF/eNyAzO8b9fJz3MneujsaWT+RBgzAw5stVKy+Kk= 18344@ggx0803</span><br><span class="line">&quot; &gt;&gt; ~/.ssh/authorized_keys</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
          <category> cod </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cod </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>week1-2</title>
      <link href="/notes/flower_identification/%E8%8A%B1%E5%8D%89%E9%89%B4%E8%B5%8F%E7%AC%94%E8%AE%B01/"/>
      <url>/notes/flower_identification/%E8%8A%B1%E5%8D%89%E9%89%B4%E8%B5%8F%E7%AC%94%E8%AE%B01/</url>
      
        <content type="html"><![CDATA[<h1>花卉鉴赏笔记</h1><h3 id="花卉鉴赏报告（25pts）">花卉鉴赏报告（25pts）</h3><h4 id="作业要求">作业要求</h4><h5 id="基本信息">基本信息</h5><ul class="lvl-0"><li class="lvl-2"><p>编号:和目录对应</p></li><li class="lvl-2"><p>中文名: 中志或其他权威志书选用的中文名</p></li><li class="lvl-2"><p>别名:仅列常见别名，没有不用写，不要把植物志上收集的列出来</p></li><li class="lvl-2"><p>学名:拉丁学名，注意格式</p></li><li class="lvl-2"><p>分类地位:科名、属名</p></li><li class="lvl-2"><p>校园分布: 校园中观察到该种植物的详细位置</p></li><li class="lvl-2"><p>2-3张图片：1张花（果），1-2张典型识别特征</p></li></ul><h4 id="注意的问题：">注意的问题：</h4><ul class="lvl-0"><li class="lvl-2"><p>照片不清晰：</p><p>可以清理周围杂草or放背景板</p></li></ul><h2 id="如何识别花卉？">如何识别花卉？</h2><ul class="lvl-0"><li class="lvl-2"><p>注意系统的统一（推荐采用apg系统）</p></li><li class="lvl-2"><p>形态+分布</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
          <category> flowers </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flowers </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/homework/flower_identification/%E8%8A%B1%E5%8D%89%E9%89%B4%E8%B5%8F%E7%AC%94%E8%AE%B0/"/>
      <url>/homework/flower_identification/%E8%8A%B1%E5%8D%89%E9%89%B4%E8%B5%8F%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1>花卉鉴赏笔记</h1><h3 id="名词解释">名词解释</h3><ul class="lvl-0"><li class="lvl-2"><p>花序</p><blockquote><p>朵花按照一定次序排列的花枝，这段花枝顶生或侧生于茎上。相对的概念是单生花，是指一朵花单独顶生或侧生于茎上</p></blockquote></li><li class="lvl-2"><p>合瓣花（亚纲）&lt;–&gt;离瓣花</p></li><li class="lvl-2"><p>可育花–&gt;不育花</p></li><li class="lvl-2"><p>苞片</p><blockquote><p><em>苞片</em>指长在单生花或花序的柄梗处，且在花萼以下正常营养叶以上的变形特化叶</p></blockquote></li></ul><h3 id="知识点">知识点</h3><ul class="lvl-0"><li class="lvl-2"><p>花萼、雄蕊甚至雌蕊都可能特化成花瓣形状</p></li><li class="lvl-2"></li><li class="lvl-2"><p>绒球状的花如合欢,含羞草的花常常是豆科含羞草亚科,绒球是雄蕊</p></li></ul><h3 id="回去找找">回去找找</h3><ul class="lvl-0"><li class="lvl-2"><p>杜仲</p></li><li class="lvl-2"><p>蒙古栎（医学院东侧，果期9-10月）</p></li><li class="lvl-2"></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;aside epub:type=&quot;footnote&quot; id=&quot;footnote-4-95&quot;&gt;60华氏度≈15.6摄氏度。——编者注&lt;/aside&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>新的一天</title>
      <link href="/Somniloquy/dream-8/"/>
      <url>/Somniloquy/dream-8/</url>
      
        <content type="html"><![CDATA[<h1>新的一天</h1>]]></content>
      
      
      <categories>
          
          <category> Somniloquy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> THU </tag>
            
            <tag> Somniloquy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>how to use proxy</title>
      <link href="/others/proxy/"/>
      <url>/others/proxy/</url>
      
        <content type="html"><![CDATA[<h1>使用Clash, Shadowrocket等客户端设置系统代理</h1><p>在这篇文章中，我将为您介绍如何通过安装特定的客户端（如Clash和Shadowrocket）并使用订阅链接来设置系统代理。<strong>注意：</strong> 使用代理可能受到相关法律的限制，请务必遵守当地法律法规。</p><h2 id="目录">目录</h2><ol><li class="lvl-3"><p><a href="#%E6%8F%90%E5%89%8D%E9%98%85%E8%AF%BB">提前阅读</a></p></li><li class="lvl-3"><p><a href="#1-Windows">Windows</a></p></li><li class="lvl-3"><p><a href="#2-macOS">macOS</a></p></li><li class="lvl-3"><p><a href="#3-Linux">Linux</a></p></li><li class="lvl-3"><p><a href="#4-Android">Android</a></p></li><li class="lvl-3"><p><a href="#5-iOS">iOS</a></p></li></ol><p><a name="issues"></a></p><h2 id="提前阅读">提前阅读</h2><p>为实现代理,首先我们来认识三个名词:Clash、机场和订阅链接.</p><p>我将简单解释一下Clash、机场和订阅链接，并说明它们是如何一起工作来帮助您实现代理的。</p><h3 id="Clash">Clash</h3><p>Clash是一个代理工具，它允许您的设备通过一个代理服务器连接到互联网。当您访问网站或使用互联网服务时，通常您的设备直接连接到目标服务器。通过使用Clash，您的互联网流量会被重新定向，经过一个或多个代理服务器，然后才到达目标服务器。这样，您可以隐藏您的真实IP地址、绕过地理限制或访问某些被屏蔽的网站。</p><h3 id="机场">机场</h3><p>机场是一个俚语，通常用于描述提供代理服务器服务的提供商。机场会有很多代理服务器，分布在世界各地。当您使用机场的服务时，您可以选择通过哪个代理服务器连接到互联网。这样，您可以根据需要选择不同的地理位置，以访问不同地区的内容或隐藏您的真实位置。</p><h3 id="订阅链接">订阅链接</h3><p>订阅链接是一个包含代理服务器信息的链接，通常由机场提供。当您在Clash中添加订阅链接时，Clash会自动从链接中获取代理服务器的列表和配置信息。这使得配置Clash变得非常简单，因为您不需要手动输入每个代理服务器的详细信息。</p><h3 id="如何配合使用实现代理">如何配合使用实现代理</h3><ol><li class="lvl-3"><p><strong>选择一个机场</strong>: 您首先需要选择一个机场，即代理服务器提供商。您可以搜索一些评价较高的机场，或者询问朋友的推荐。</p><blockquote><p>这里我推荐两个个我在用的</p><ul class="lvl-3"><li class="lvl-2"><a href="https://189854.xyz/">wallesspku</a>北大人搞的,胜在完全免费且比较稳定,但是每个月只有20G流量,并且常常登不上chatgpt.而且你需要北大或清华邮箱来注册(我不确定其他高校的邮箱是否可以注册)链接:<a href="https://189854.xyz/">wallesspku</a></li><li class="lvl-2"><a href="https://glados.space/landing/AGKRM-HPVMK-H37VV-MIEL7">GLaDOS</a> 老牌机场,比较稳定,价格便宜(15rmb/月)但是每天签到可以白嫖时长(签到1次+1天),教育邮箱还可以免费白嫖一整年.教育优惠的位置比较隐蔽,在官网最下面,链接:<a href="https://glados.one/console/education">education plan</a></li></ul></blockquote></li><li class="lvl-3"><p><strong>获取订阅链接</strong>: 注册并登录到您选择的机场的网站，通常您可以在用户控制面板中找到一个订阅链接。</p></li><li class="lvl-3"><p><strong>安装和配置Clash</strong>: 下载并安装Clash，在Clash中添加您从机场获取的订阅链接。这将自动配置代理服务器列表。</p></li><li class="lvl-3"><p><strong>启用代理</strong>: 在Clash中启用代理，并选择一个代理服务器。这时，您的互联网连接将通过该代理服务器。</p></li><li class="lvl-3"><p><strong>浏览互联网</strong>: 现在，当您访问网站或使用互联网服务时，您的流量将通过代理服务器。这可以帮助您访问受限制的内容，保护您的隐私或绕过网络屏蔽。</p></li></ol><p>请注意，使用代理可能受到相关法律的限制，务必遵守当地法律法规。在遵守当地法律法规的条件下,你可以根据你的设备选择对应的教程.</p><h3 id="注意">注意:</h3><p>由于提供的clash链接均在github上,国内访问可能较慢.</p><div class="tips"><p>实际上<a href="https://glados.space/landing/AGKRM-HPVMK-H37VV-MIEL7">glados官网</a>有比我更加详细的教程与资源.你可以转到<a href="https://glados.space/landing/AGKRM-HPVMK-H37VV-MIEL7">这里</a>查看.</p></div><p><a name="windows"></a></p><h2 id="1-Windows">1. Windows</h2><p>在Windows系统中，我们将使用Clash客户端来设置系统代理。</p><h4 id="步骤">步骤</h4><ol><li class="lvl-3"><p>访问 <a href="https://github.com/Fndroid/clash_for_windows_pkg/releases">Clash for Windows</a> 并下载最新版本。</p></li><li class="lvl-3"><p>安装并启动Clash。</p></li><li class="lvl-3"><p>打开浏览器，访问 <a href="https://glados.space/landing/AGKRM-HPVMK-H37VV-MIEL7">glados官网</a> 并注册一个账户，然后激活。</p></li><li class="lvl-3"><p>在GLaDOS的控制面板中，找到并复制您的订阅链接。</p></li><li class="lvl-3"><p>返回Clash，点击 <strong>“Profiles”</strong> 选项，然后点击 <strong>“订阅”</strong>，粘贴刚刚复制的订阅链接，并点击 <strong>“下载”</strong>。</p><img src="https://gitlab.com/ggx-blog/imglab/uploads/a3c8989730f7cab6073d4982fc27a830/202306162311555.png" alt="image-20230616231144496" style="zoom: 67%;" /></li><li class="lvl-3"><p>在 <strong>“General”</strong> 页面，打开 <strong>“系统代理”</strong> 开关。<strong>这一步很重要!!</strong></p><img src="https://gitlab.com/ggx-blog/imglab/uploads/50e1e9219a8c4c2ccaec655ebb8d65d0/202306162314664.png" alt="image-20230616231423604" style="zoom:67%;" /></li><li class="lvl-3"><p>在 <strong>“proxies”</strong> 页面，选择 <strong>“rule(按规则转发)”或“global(全局转发)”</strong> 开关。</p><img src="https://gitlab.com/ggx-blog/imglab/uploads/08cff6a7602ba6af99cb82b39598b382/202306162313234.png" alt="image-20230616231341186" style="zoom:67%;" /></li></ol><p><a name="macos"></a></p><h2 id="2-macOS">2. macOS</h2><p>在macOS系统中，我们同样使用Clash客户端。</p><h4 id="步骤-2">步骤</h4><ol><li class="lvl-3"><p>访问 <a href="https://github.com/yichengchen/clashX/releases">ClashX</a> 并下载最新版本。</p></li><li class="lvl-3"><p>安装并启动ClashX。</p></li><li class="lvl-3"><p>按照Windows中的步骤3-4，访问GLaDOS网站并获取订阅链接。</p></li><li class="lvl-3"><p>在ClashX的菜单中选择 <strong>“配置”</strong> &gt; <strong>“远程配置”</strong>，粘贴订阅链接，并点击 <strong>“下载”</strong>。</p></li><li class="lvl-3"><p>在菜单栏中，点击ClashX图标并启用 <strong>“Set as system proxy”</strong>。</p></li></ol><p><a name="linux"></a></p><h2 id="3-Linux">3. Linux</h2><p>对于Linux用户，我们也使用Clash。</p><h4 id="步骤-3">步骤</h4><ol><li class="lvl-3"><p>访问 <a href="https://github.com/Dreamacro/clash/releases">Clash for Linux</a> 并下载最新版本。</p></li><li class="lvl-3"><p>使用您的浏览器访问 <a href="https://glados.space/landing/AGKRM-HPVMK-H37VV-MIEL7">GLaDOS</a> 并注册一个账户，然后激活。</p></li><li class="lvl-3"><p>获得订阅连接。</p></li><li class="lvl-3"><p>安装并运行Clash。</p></li><li class="lvl-3"><p>将订阅链接配置到Clash。</p></li><li class="lvl-3"><p>在系统设置中将代理设置为Clash的本地端口。</p></li></ol><p><a name="android"></a></p><h2 id="4-Android">4. Android</h2><p>在Android上，我们将使用Clash for Android来设置系统代理。</p><h4 id="步骤：">步骤：</h4><ol><li class="lvl-3"><p>在您的Android设备上打开浏览器，并访问 <a href="https://github.com/Kr328/ClashForAndroid/releases">Clash for Android GitHub</a> 页面。</p></li><li class="lvl-3"><p>在 <strong>“Releases”</strong> 部分，找到最新的版本。点击最新版本下的 <strong>“Assets”</strong> 展开文件列表。</p></li><li class="lvl-3"><p>下载以 <code>.apk</code> 结尾的文件。</p></li><li class="lvl-3"><p>下载完成后，打开该文件以开始安装过程。您可能需要允许安装来自未知来源的应用程序。</p></li><li class="lvl-3"><p>安装完成后，打开Clash for Android应用。</p></li><li class="lvl-3"><p>使用您的浏览器访问 <a href="https://glados.space/landing/AGKRM-HPVMK-H37VV-MIEL7">GLaDOS</a> 并注册一个账户，然后激活。</p></li><li class="lvl-3"><p>在GLaDOS的控制面板中，找到并复制您的订阅链接。</p></li><li class="lvl-3"><p>返回到Clash for Android应用，点击左上角的三条横线打开侧边栏，然后选择 <strong>“Profiles”</strong>。</p></li><li class="lvl-3"><p>在 <strong>“Profiles”</strong> 页面的右下角，点击 <strong>“+”</strong> 图标，然后选择 <strong>“Download”</strong>。</p></li><li class="lvl-4"><p>在URL字段中粘贴刚刚复制的订阅链接，然后点击 <strong>“Download”</strong> 按钮。</p></li><li class="lvl-4"><p>回到主界面，点击右下角的开关图标来启用Clash。</p></li><li class="lvl-4"><p>确认允许Clash创建VPN连接。请注意，这并不会创建实际的VPN连接，而是用于将流量重定向到Clash。</p></li></ol><p>现在，您的Android设备应该已经配置好使用Clash作为系统代理了。请注意，使用代理可能受到相关法律的限制，请务必遵守当地法律法规。</p><p><a name="ios"></a></p><h2 id="5-iOS">5. iOS</h2><p>在iOS上，我们同样使用Shadowrocket。</p><h4 id="步骤-4">步骤</h4><ol><li class="lvl-3"><p>在App Store下载并安装Shadowrocket。(这需要你拥有非国区apple id)</p></li><li class="lvl-3"><p>按照之前的步骤在GLaDOS网站注册并获取订阅链接。</p></li><li class="lvl-3"><p>在Shadowrocket中，点击 <strong>“添加”</strong>，然后选择 <strong>“使用URL导入配置”</strong>，粘贴订阅链接。</p></li><li class="lvl-3"><p>激活配置，并在手机的设置中启用Shadowrocket的VPN。</p></li></ol><p><strong>注意：</strong> 使用代理可能受到相关法律的限制，请务必遵守当地法律法规。</p>]]></content>
      
      
      <categories>
          
          <category> tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/notes/pytorch/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BB%9F%E8%AE%A1%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
      <url>/notes/pytorch/%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BB%9F%E8%AE%A1%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1>第四章:<strong>统计机器学习方法</strong></h1><h3 id="统计学习的三个基本要素">统计学习的三个基本要素</h3><p>统计学习的三个基本要素包括：模型、策略和算法。</p><ol><li class="lvl-3"><p>模型：在统计学习中，我们要假设或构造一个模型来表示数据的生成过程。模型的复杂性影响着学习的难度和效果。例如，线性模型是比较简单的模型，而神经网络是一种复杂的模型。</p></li><li class="lvl-3"><p>策略：策略是指在模型的所有可能性中，我们如何选择一个最好的模型。这个“最好”通常是通过一个损失函数或评价指标来定义的，如均方误差、交叉熵损失等。我们的目标就是找到一个模型，使得这个损失函数或评价指标达到最优。</p></li><li class="lvl-3"><p>算法：算法就是如何找到这个最优模型的计算方法。在一些简单的情况下，我们可以直接求解得到最优模型。但在许多复杂的情况下，我们需要借助一些优化算法，如梯度下降、牛顿法等，来迭代求解最优模型。</p></li></ol><p>所以说模型是统计学习的对象，策略是选择模型的准则，算法是实现策略和求解模型的工具。三者缺一不可，共同构成了统计学习的基本框架。</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/98b93a9bbaa1abaaad4ba903f2e90f37/202306160003519.jpg" alt="photo_2023-06-12_22-54-53.jpg"></p><p>hello?</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>DLC-总复习</title>
      <link href="/notes/DLC/%E6%80%BB%E5%A4%8D%E4%B9%A0/"/>
      <url>/notes/DLC/%E6%80%BB%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1>数字逻辑电路总复习</h1><ul class="lvl-0"><li class="lvl-2"><h3 id="全书一句话">全书一句话</h3><p>表达式+触发器</p><ul class="lvl-2"><li class="lvl-4"><p>组合逻辑:表达式</p></li><li class="lvl-4"><p>时序逻辑:表达式+触发器</p></li><li class="lvl-4"><p>集成电路(可编程逻辑):表达式+触发器的具体应用</p></li></ul><h4 id="表达式">表达式</h4><ul class="lvl-2"><li class="lvl-4"><p>手工化简:公式法与卡诺图</p></li><li class="lvl-4"><p>计算机化简:表格法</p></li></ul></li><li class="lvl-2"><h3 id="组合逻辑一句话">组合逻辑一句话</h3><p>$$<br>表达式\equiv 真值表\equiv 逻辑图<br>$$</p><p>用表达式表示全部组合逻辑</p><ul class="lvl-2"><li class="lvl-4"><p>译码器</p></li><li class="lvl-4"><p>编码器</p></li><li class="lvl-4"><p>数据选择器</p></li><li class="lvl-4"><p>数据比较器</p></li><li class="lvl-4"><p>奇偶校验器</p></li><li class="lvl-4"><p>加法器</p></li></ul></li><li class="lvl-2"><h3 id="时序逻辑一句话">时序逻辑一句话</h3><p><strong>触发器结构和原理</strong></p><ul class="lvl-2"><li class="lvl-4"><p>基本RS触发器</p></li><li class="lvl-4"><p>电位型触发器</p><ul class="lvl-4"><li class="lvl-6"><p>D触发器</p></li><li class="lvl-6"><p>RS触发器</p></li></ul></li><li class="lvl-4"><p>边沿触发器</p><ul class="lvl-4"><li class="lvl-6">D触发器</li><li class="lvl-6">JK触发器</li></ul></li><li class="lvl-4"><p>会灵活运用以上触发器</p><p>基本概念：功能表，现态Qn，次态Qn+1 ，状态表与状态图，状态方程，激励表</p></li></ul></li><li class="lvl-2"><h3 id="可编程逻辑一句话">可编程逻辑一句话</h3></li></ul><h2 id="组合逻辑">组合逻辑</h2><p>当输入线为2根（标记为$x$和$y$），输出线为4根（标记为$Y_0$、$Y_1$、$Y_2$和$Y_3$）时，2-4译码器的逻辑表达式如下：</p><p>$$<br>\begin{align*}<br>Y_0 &amp;= \bar{x} \cdot \bar{y} \<br>Y_1 &amp;= \bar{x} \cdot y \<br>Y_2 &amp;= x \cdot \bar{y} \<br>Y_3 &amp;= x \cdot y \<br>\end{align*}<br>$$<br>其中，符号 $\bar{x}$ 表示非$x$，$\cdot$ 表示与，$+$ 表示或。</p><p>这些逻辑表达式描述了译码器的输出如何根据输入进行编码。例如，当输入$x$为低电平（0），输入$y$为低电平（0）时，输出$Y_0$为高电平（1），而其他输出线为低电平（0）。当输入信号发生变化时，输出线的状态将相应地改变，以反映输入的变化。这样，2-4译码器可以将2个输入线的组合状态映射到4个输出线上。</p><h2 id="触发器结构和原理"><strong>触发器结构和原理</strong></h2><ul class="lvl-0"><li class="lvl-2"><p>基本RS触发器</p><img src="https://gitlab.com/ggx-blog/imglab/uploads/c8aead3528634185ef5198d0465e3d82/202306172259218.png" alt="image-20230617225904163" style="zoom: 50%;" /><ul class="lvl-2"><li class="lvl-4"><p>S-R=0-1:RESET,Q’置零</p></li><li class="lvl-4"><p>S-R=1-0:SET,Q’置1</p></li><li class="lvl-4"><p>S-R=1-1:保持</p></li><li class="lvl-4"><p>S-R=0-0:异常(Q’,$\bar Q’$)=(1,1)</p></li><li class="lvl-4"><p>0-0转1-1:保持?不定态!</p></li></ul><p>为了解决上面问题,引入控制端E:</p></li><li class="lvl-2"><p>电位型触发器</p><p>当E=0时保持,E=1时接受输入</p><ul class="lvl-2"><li class="lvl-4"><p>RS触发器</p><p><strong>两个问题</strong>:</p><ol><li class="lvl-7"><p>RS=11保持功能与控制端E重复</p></li><li class="lvl-7"><p>当控制端启用的时候,RS=00仍然会异常</p></li></ol><p>所以去掉这两个状态后,只剩下(set)与(reset);则可以只用一个输入D表示</p></li><li class="lvl-4"><p>D触发器</p></li></ul></li><li class="lvl-2"><p>边沿触发器</p><p>当E上升沿时接受输入,其他状态保持</p><ul class="lvl-2"><li class="lvl-4"><p>D触发器</p><div class="warning"><img src="https://gitlab.com/ggx-blog/imglab/uploads/8c25881da02ec3efa792e32f71907890/202306172326118.png" alt="image-20230617232641045" style="zoom: 50%;" /><p>什么是维持阻塞?</p><ul class="lvl-5"><li class="lvl-6"><p>多个触发器组成的电路最高时钟频率</p></li><li class="lvl-6"><p>正沿D触发器的开关特性</p></li><li class="lvl-6"><p>见第九次课件</p></li></ul></div></li><li class="lvl-4"><p>JK触发器</p><ul class="lvl-4"><li class="lvl-6">特性方程<br>$$<br>Q^*=J\overline Q + \overline K Q<br>$$</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
          <category> DLC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DLC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人智导第三章笔记</title>
      <link href="/notes/pytorch/%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
      <url>/notes/pytorch/%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1>第三章:对抗搜索</h1><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/ad66c389194db9b0426cc0244e73b0d8/202306161254085.png" alt="image-20230615212012526"></p><h2 id="α-β剪枝">α-β剪枝</h2><p>基于max-min</p><p>根本思想是如果知道这条路很差,那么不需要知道这条路究竟有多差</p><p>所以当一个max结点发现自己找到了一条路,这条路比它祖先的<strong>任意</strong>一个(已经有值的)min结点的值($\beta$)要好,就直接放弃继续搜索.这叫(因为)$\beta$剪枝</p><p>因为作为max结点我肯定会选择这条看上去的比较好的路,可是他的这个min祖先一定不会最终选择这条路.(如果真的选择了,这条路的最终值会一直传上去,直到在和那个坏蛋min结点的另一个孩子竞争时失败)</p><h3 id="模拟算法实现时的注意事项">模拟算法实现时的注意事项</h3><p>其实α-β剪枝理解起来是很直观的,就和人类对局面的思考差不多.不知道为什么看了ppt什么<code>极大节点的下界为a。极小节点的上界为b。</code>反而变糊涂了</p><p>主要是注意一下结点发生剪枝时至少进行了一次搜索,所谓的剪枝实际上是剪掉了<strong>剩下的所有儿子</strong>,而不是直接剪掉了自己</p><p>在祖先没有已经计算过的另一种结点时,不会发生剪枝,所以左起这个2不应该被剪掉,同时父亲也应该更新</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/569deb73a14a60102d58c2eee7439904/202306161254315.png" alt="image-20230615215559423"></p><p>但是更新到爷爷时,应该在箭头位置进行$\beta$剪枝</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/27a4312acc544cca314e4fe9a42255e7/202306161254521.png" alt="image-20230615215720463"></p><h2 id="蒙特卡洛MCTS-Monte-Carlo-Tree-Search">蒙特卡洛MCTS: Monte Carlo Tree Search</h2><h3 id="定义">定义</h3><ol><li class="lvl-3"><p><strong>蒙特卡洛算法</strong>: 这是一种统计模拟方法，通过从概率分布中随机抽样或使用随机数来近似复杂过程的结果。蒙特卡洛方法广泛应用于各种领域，从物理学到金融，当然还有游戏。</p></li><li class="lvl-3"><p><strong>蒙特卡洛树搜索 (MCTS)</strong>: 这是一种在很多游戏和决策过程中使用的搜索算法，它使用蒙特卡洛方法来评估每个动作的潜在价值。它通过重复模拟游戏的玩法来构建一个搜索树，并使用统计数据来选择最有希望的移动。MCTS 主要包括四个步骤：选择(Selection)、扩展(Expansion)、模拟(Simulation)和回传(Backpropagation)。</p></li><li class="lvl-3"><p><strong>UCT (Upper Confidence Bounds for Trees) 算法</strong>: 这是 MCTS 的一个变种，它在选择步骤中使用 UCB 策略。UCB 考虑了两个因素：一个节点的平均奖励和该节点被访问的次数。通过使用 UCB，UCT 在探索（搜索未知的部分）和利用（聚焦于已知的好动作）之间找到平衡。</p></li></ol><p>简单说来,MCTS就是选择-拓展-模拟-回传,而UCT是MCTS的一个特例</p><h3 id="UCT-主要包括以下四个步骤：">UCT 主要包括以下四个步骤：</h3><ol><li class="lvl-3"><p><strong>选择(Selection)</strong>: 从根节点开始，使用 UCB 公式选择子节点，直到找到一个可以扩展的节点（即没有完全展开或游戏结束的节点）。UCB 公式是这样的：</p><p><code>UCB = X + C * sqrt(2ln(n) / ni)</code></p><p>其中 <code>X</code> 是节点的平均奖励值(比如胜率)，<code>n</code> 是总的访问次数，<code>ni</code> 是当前节点的访问次数，<code>C</code> 是一个常数，控制探索与利用的平衡。较高的值会增加探索，而较低的值会强调利用。</p><blockquote><p>利用就是X,探索就是sqrt(2ln(n) / ni),如果当前访问次数较小,探索值就会偏大</p></blockquote></li><li class="lvl-3"><p><strong>扩展(Expansion)</strong>: 如果找到的节点不是一个游戏结束的状态，那么创建一个或多个子节点并选择其中一个。通常，这一步是随机地选择一个尚未尝试过的动作。</p></li><li class="lvl-3"><p><strong>模拟(Simulation)</strong>: 从选定的节点开始，通过随机地选择动作，模拟游戏直到达到游戏结束状态.</p></li><li class="lvl-3"><p><strong>回传(Backpropagation)</strong>: 一旦模拟结束，根据模拟的结果（赢、输或平局），更新从所选节点一直到根节点的所有节点的统计数据。</p></li></ol><h2 id="阿尔法狗">阿尔法狗</h2><p>使用神经网络+MCTS</p><p>其中神经网络包括策略神经网络和估值神经网络</p><h3 id="MCTS的问题">MCTS的问题</h3><ul class="lvl-0"><li class="lvl-2"><p>生成所有子节点</p></li><li class="lvl-2"><p>模拟具有盲目性</p></li></ul><p>就是说:<mark>盲目</mark></p><h3 id="策略网络">策略网络</h3><p>损失函数L(w)=$-t_a log(p_a)$</p><p>​    $t_a$：当前棋局下棋手落子在a处时为1，否则为0</p><p>​    $p_a$：策略网络在a出落子的概率</p><p>就是说,如果棋手落在a位置,希望策略网络也在a处落子</p><h3 id="估值网络">估值网络</h3><p>损失函数L(w)=$(R-V)^2$</p><p>R为棋局的胜负</p><p>V为估值网络的输出(-1,1)</p><h3 id="与MCTS融合">与MCTS融合</h3><p>AlphaGo增加了第三个原则<strong>经验</strong>：落子概率高的节点</p><img src="https://gitlab.com/ggx-blog/imglab/uploads/fb4f1d6cf22666a9f2871b6f6757b7c3/202306161254311.png" alt="image-20230616005919473" style="zoom:67%;" /><p>上面的图不用记.只需要知道最后选择的点是根子节点中被拓展过最多次的点.</p><blockquote><p>还有一个要注意的点是最后回传的价值:奇数层和偶数层之间正负号要切换.因为一方得利就是另一方失利</p></blockquote><h2 id="强化学习">强化学习</h2><h5 id="强化学习就是监督学习的反义词">强化学习就是监督学习的反义词</h5><p>强化学习是机器学习的一个子领域，它关注的是如何基于环境反馈来采取最优的行动。</p><p>在强化学习中，我们设有一个智能体（Agent），它在某个环境（Environment）中进行行动。每一次行动之后，环境都会对智能体的状态造成变化，并给予一定的回馈（Reward）。智能体的目标就是通过学习，寻找一种策略，使得随着时间的推移，其能获取最多的回馈。</p><p>为了实现这个目标，智能体需要通过探索（Exploration）和利用（Exploitation）之间进行平衡。探索是指尝试新的行动以获取更多信息，利用是指根据已有的知识采取最佳行动。如果智能体只是利用当前的知识，可能会错过那些长远看有更大回馈的行动；但是如果过多地探索新的行动，也可能会付出更多代价。</p><h3 id="深度强化学习">深度强化学习</h3><p>基于神经网络的强化学习方法</p><h3 id="三个方法">三个方法</h3><ul class="lvl-0"><li class="lvl-2"><p>基于策略梯度</p><ul class="lvl-2"><li class="lvl-4"><p>假设获胜者的行为都是正确的，负者行为都是不正确的</p></li><li class="lvl-4"><p>假设获负时对权重的修改量大小与获胜时一样，方向相反</p></li><li class="lvl-4"><p>流程</p><ol><li class="lvl-7">自己和自己下棋</li><li class="lvl-7">下完棋的数据用来训练新模型</li><li class="lvl-7">新的自己和过去的自己下棋</li><li class="lvl-7">如果赢了则更新自己的版本</li><li class="lvl-7">jump to 1</li></ol></li></ul></li><li class="lvl-2"><p>基于价值评估</p></li></ul><p>实际上前两种方法就是把监督学习的MCTS的<strong>策略网络</strong>和<strong>估值网络</strong>迁移过来给出了一个深度学习的版本而已</p><ul class="lvl-0"><li class="lvl-2"><p>演员评价方法</p></li></ul><img src="https://gitlab.com/ggx-blog/imglab/uploads/46d9d1acbcfebe6b618e8aee442c8ee5/202306161254390.png" alt="image-20230616012023947" style="zoom:67%;" /><p>实际上演员评价方法就是把上面两个网络变成两个通道,最后再通过一定的权重组合</p><h3 id="AlphaGo-Zero"><strong>AlphaGo</strong> <strong>Zero</strong></h3><p>在第三步的模拟过程中,用估值网络的输出取代模拟过程</p><p>引入多样性:人为引入噪声.</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
          <category> iAi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iAi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人智导第四章笔记</title>
      <link href="/notes/pytorch/%E7%AC%AC%E5%9B%9B%E7%AB%A0/"/>
      <url>/notes/pytorch/%E7%AC%AC%E5%9B%9B%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1>第四章:支持向量机</h1><p>在超平面的表达式$f(x) = w^Tx + b = 0$中：</p><ul class="lvl-0"><li class="lvl-2"><p>$x$: 是数据点在特征空间中的向量表示。例如，如果每个数据点有两个特征（如长和宽），那么$x$就是一个二元素向量，包含了数据点的长和宽。</p></li><li class="lvl-2"><p>$w$: 是权重向量，和$x$有相同的维数。权重向量决定了最优超平面的方向。几何意义上，可以理解为超平面的法线向量。</p></li><li class="lvl-2"><p>$b$: 是偏置项，影响最优超平面的位置（即与原点的距离）。</p></li></ul><p>在二维空间中，超平面就是一条直线，而在三维空间中，超平面就是一个平面，以此类推。</p><p>权重向量$w$的方向正交于超平面。也就是说，任意在超平面上的两点$x_1$和$x_2$，都满足方向向量$(x_2-x_1)$与$w$的点积为零，即$|(x_2-x_1)w|=0$。</p><p>权重向量$w$的模长（即欧几里得长度）与超平面的间隔成反比。模长越小，间隔越大。因此优化$w$的目标就是让其模长尽量小，从而使间隔尽量大。</p><div class="tips"><h3 id="间隔">间隔</h3><p>函数间隔和几何间隔都是在超平面（决策边界）划分数据集时定义出的两个重要概念：</p><ol><li class="lvl-3"><p>函数间隔（Functional Margin）: 对于给定的训练数据集$\mathrm{T}$和超平面$(w, b)$，定义超平面$(w, b)$关于样本点$(x_i, y_i)$的函数间隔为$y_i(w^T x_i + b)$。规定如果样本点被正确分类，那么函数间隔需为正。这对应了数据点到超平面的“原始距离”。</p></li><li class="lvl-3"><p>几何间隔（Geometrical Margin）: 对于给定的训练数据集$\mathrm{T}$和超平面$(w, b)$，定义超平面$(w, b)$关于样本点$(x_i, y_i)$的几何间隔为$y_i(w^T x_i + b)/||w||$。也就是在函数间隔的基础上，采用单位化权重向量来消除权重向量长度的影响，从而得到的数据点到超平面的真实距离。</p></li></ol><p>在最优化问题中，SVM主要的目标是寻求得到最大的<mark>几何间隔</mark>，从而最小化模型的泛化误差，提高模型的分类性能。</p></div><p>而偏置项$b$决定了超平面距离原点的远近。比如在二维空间中，假设超平面是一条直线，那么$b$就是直线在y轴上的截距。增大$b$的绝对值会使直线沿着与$w$方向正交的方向移动，但并不会改变直线的方向。</p><h3 id="如何优化w">如何优化w?</h3><div class="tips"><h4 id="什么是支持向量">什么是支持向量</h4><p>在支持向量机(SVM)的标准形式中，所有的数据点都会形成一些约束条件，但在实践中，大部分的数据点对最终的最优解影响不大。那些真正影响到SVM的最优解（即最优超平面）的数据点是那些离分割超平面最近的点，也就是被称为&quot;支持向量&quot;的数据点。换言之，最优解依赖于那些位于或者在最优超平面附近的点，它们被称为&quot;支持向量&quot;。这是因为这些点满足 $y_i(w^T x_i+b) -1 = 0$ 或者 $y_i (w^T x_i+b) +1 = 0$ ，是损失函数（即上述的拉格朗日函数）的<strong>活跃约束</strong>，同时也是我们判定间隔边界的点。所以，<strong>SVM只关心那些离超平面近的点，即支持向量，而对其他的点则不敏感。</strong></p></div><h4 id="拉格朗日方法">拉格朗日方法</h4><p>选取最优化平面问题作为例子，我们知道，这是支持向量机(SVM)的基本思想。要找到一个最优的超平面，使得所有样本到该平面的间隔最大。用拉格朗日乘数法的语言来描述，就是我们希望求解以下原始问题：</p><p><strong>最小化目标函数</strong></p><p>$$\frac{1}{2} ||w||^2$$</p><p><strong>约束条件</strong></p><p>$$y_i (w^T x_i + b) - 1 \geq 0, \text{ } \forall i$$</p><p>其中，$w$维度的向量，是我们要找的超平面的法向量；$x_i$是样本的特征向量；$y_i$是样本的类别标签，取值为-1或+1；and $b$是超平面的截距。</p><p><strong>由上述原问题，我们可以构建出以下拉格朗日函数</strong>：“</p><p>$$L(w, b, \alpha) = \frac{1}{2} ||w||^2  - \sum_{i=1}^{m} \alpha <em>{i} [y</em>{i}(w^T x_i + b) - 1]$$</p><p>其中，$\alpha _{i}$就是拉格朗日乘数，M为样本数。</p><p>通过对w和b求导，令其等于零，得到w和b的表达式，将这个表达式带入到拉格朗日函数中，我们可以得到对偶问题。</p><p><strong>对偶问题的优化目标就变为，求以下函数最大值</strong>：</p><p>$$\max_{\alpha} \sum_{i=1}^m \alpha_i - \frac{1}{2} \sum_{i=1}^m \sum_{j=1}^m y_i y_j \alpha_i \alpha_j &lt;x_i,x_j&gt;$$</p><p>约束条件为：</p><p>$$\sum_{i=1}^m \alpha_i y_i = 0 \quad \text{ and } \quad \alpha_i \geq 0 , i=1,2,3,…,m$$</p><p>之所以要构建对偶问题，是因为它一般情况下要比原问题更容易求解，并且能自然地引入核函数，处理逻辑非线性可分的情况。在求解了对偶问题之后，我们能通过拉格朗日乘数法得到w、b参数，然后得到分类平面。</p><h4 id="考虑到软分类优化">考虑到软分类优化</h4><img src="https://gitlab.com/ggx-blog/imglab/uploads/cb92b20dfe48ae21d2ed72d8da5759a7/202306161638006.png" alt="image-20230616163823956" style="zoom: 50%;" /><img src="https://gitlab.com/ggx-blog/imglab/uploads/ee359d17d4380f4abe31a358d5e73d54/202306161637145.png" alt="image-20230616163703036" style="zoom: 50%;" /><h3 id="非线性支持向量机">非线性支持向量机</h3><p><strong>使用一个变换，将原空间数据映射到新空间</strong></p><h2 id="决策树">决策树</h2><h4 id="下面是ID3算法的基本步骤：">下面是ID3算法的基本步骤：</h4><ol><li class="lvl-3"><p><strong>计算信息增益</strong>：对于数据集中的每个特征，计算使用该特征来划分数据集的信息增益。</p></li><li class="lvl-3"><p><strong>选择最佳特征</strong>：选择具有最高信息增益的特征。</p></li><li class="lvl-3"><p><strong>分裂数据集</strong>：使用选定的特征，根据该特征的所有可能值来分裂数据集。</p></li><li class="lvl-3"><p><strong>递归构建子树</strong>：对于分裂后的每个子数据集，重复步骤1-3，直到满足停止条件（如，数据集中的所有实例都属于同一类别，或达到预定的树的深度）。</p></li><li class="lvl-3"><p><strong>生成决策树</strong>：一旦达到停止条件，每个子数据集都将被分配一个类标签，这个类标签通常是该子数据集中最常见的类。</p></li></ol><h4 id="C4-5">C4.5</h4><ul class="lvl-0"><li class="lvl-2"><p><strong>信息增益比</strong>:相比于ID3,增加了增益比,在选择最佳特征时在考虑n个最高信息增益的特征时<strong>额外</strong>考虑信息增益比(倾向于使分类不平均)</p></li><li class="lvl-2"><p><strong>后剪枝</strong>:生成决策树后为防止过拟合,进行后剪枝:将所有的子孙叶节点合并到自己,自己成为新的叶节点</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
          <category> iAi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iAi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CH8</title>
      <link href="/notes/network/%E5%BA%94%E7%94%A8%E5%B1%82/"/>
      <url>/notes/network/%E5%BA%94%E7%94%A8%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h1>应用层基础</h1><p>应用层：  规定应用进程之间在通信时所遵循的协议</p><h2 id="目标">目标</h2><ol><li class="lvl-3"><p>掌握应用进程通信方式以及服务进程工作模式</p></li><li class="lvl-3"><p>掌握域名系统DNS基本原理和工作机制</p></li><li class="lvl-3"><p>掌握电子邮件系统体系结构及基本工作原理</p></li><li class="lvl-3"><p>掌握万维网WWW系统结构和HTTP协议工作原理</p></li></ol><h2 id="我的理解">我的理解</h2><h4 id="应用">应用</h4><p>“应用”通常是指用户级别的软件程序，而“进程”是操作系统级别的概念。一个应用可以由一个或多个进程组成，而一个进程通常是一个应用的执行实例。</p><h4 id="进程与端口">进程与端口</h4><p>应用的进程和网络端口之间的对应关系可以是多对多的。</p><ul class="lvl-0"><li class="lvl-2"><p><strong>一个进程可以使用多个端口</strong>：例如，一个Web服务器可能在一个端口（如80）上监听HTTP请求，同时在另一个端口（如443）上监听HTTPS请求。此外，某些应用程序可能同时监听多个端口以提供不同类型的服务。</p></li><li class="lvl-2"><p><strong>多个进程可以共享同一个端口</strong>：这在使用UDP协议时比较常见，因为UDP不同于TCP，没有所谓的“连接”。在使用TCP时，通常不同的进程不会共享同一个端口，因为端口被用来区分不同的连接。但是，还是存在例外，比如在某些情况下，通过使用SO_REUSEPORT套接字选项，多个进程可以共享同一个TCP端口。</p></li><li class="lvl-2"><p><strong>单个进程单个端口</strong>：这是非常常见的情况，比如一个简单的Web服务器可能只监听一个端口（例如80）。</p></li></ul><h4 id="套接字socket">套接字socket</h4><p>套接字（socket）可以类比为一个门或者说是一个通信端点，允许来自应用程序的进程将信息发送到网络，或者从网络接收信息。从家里(主机,进程)打开门进入网络.</p><h3 id="应用进程通信方式"><mark>应用进程通信方式</mark></h3><p>应用进程: 两台主机通信实际是其上对应的两个应用进程(process)在通信,以下所有的C,B,S,P实际上指的都是<strong>应用进程</strong></p><ul class="lvl-0"><li class="lvl-2"><p>C/S, Client/Server 方式</p></li><li class="lvl-2"><p>B/S， Browser/Server方式</p><p>优点:界面统一， 使用简单  易于维护  可扩展性好  信息共享度高(HTML兼容性好)</p></li><li class="lvl-2"><p>P2P， Peer to Peer 方式</p></li></ul><h3 id="服务器进程通信方式"><mark>服务器进程通信方式</mark></h3><p>从服务器角度看应用层</p><ul class="lvl-0"><li class="lvl-2"><p>循环方式:阻塞方式,无连接的</p></li><li class="lvl-2"><p>并发方式:非阻塞方式,有连接的</p></li></ul><p>实际上对应了两种socket</p><ul class="lvl-0"><li class="lvl-2"><p><strong>流套接字（Stream Sockets）</strong>：也称为TCP套接字，它们使用传输控制协议（TCP）进行通信。流套接字提供一种可靠的、双向的、基于连接的字节流。这意味着在发送数据之前，必须先<strong>建立一个连接</strong>，然后通过这个连接发送数据。流套接字常用于需要可靠传输的应用程序，如Web服务器和数据库应用。</p><blockquote><p>建立连接</p><p>父服务进程接受到请求时创建子服务进程,子服务进程与客户进程建立连接</p></blockquote></li><li class="lvl-2"><p><strong>数据报套接字（Datagram Sockets）</strong>：也称为UDP套接字，它们使用用户数据报协议（UDP）进行通信。与流套接字不同，数据报套接字是无连接的，这意味着不需要在发送数据之前建立一个连接。数据报套接字通常用于不需要可靠性或顺序的应用程序，如流媒体、在线游戏或VoIP。</p></li></ul><h2 id="域名系统-DNS-Domain-Name-System">域名系统(DNS,Domain Name System)</h2><p>向所有需要<strong>域名解析</strong>的应用提供服务，将域名映射成IP</p><p>**DNS下层使用什么协议？**UDP数据报, 端口号为53</p><p>Internet的域名结构采用了<strong>层次树状结构</strong>的命名方法</p><blockquote><p>… .三级域名.二级域名.顶级域名</p></blockquote><h3 id="域名服务器-名字服务器">域名服务器(名字服务器)</h3><p>分为两大类</p><ul class="lvl-0"><li class="lvl-2"><p>权威名字服务器(authoritative name server)</p><p>根据本地知识知道本DNSzone内容的服务器,无需查询其他服务器</p><p>根据对应zone的层次进一步分为</p><ul class="lvl-2"><li class="lvl-4"><p>根名字服务器(root name server) /根服务器(root server)</p></li><li class="lvl-4"><p>顶级域名字服务器(TLD name server)</p></li><li class="lvl-4"><p>二级域名字服务器(second level domain name server)</p></li><li class="lvl-4"><p>三级域名字服务器(third level domain name server)</p></li><li class="lvl-4"><p>本地域名服务器:</p><p>三级域及以下的名字服务器(<a href="http://xn--tsinghua-kx2m263f.edu.cn">例如tsinghua.edu.cn</a>)通常在用户本地区域 因此三级域及以下的名字服务器也统称为本地域名服务器</p></li></ul></li><li class="lvl-2"><p>递归解析器(recursive resolver)/递归服务器</p></li></ul><h3 id="域名解析过程">域名解析过程</h3><p>应用进程将域名放在DNS报文中(UDP数据报, 端口号为53),发送给域名服务器</p><ul class="lvl-0"><li class="lvl-2"><p>递归查询</p><p>本地域名字服务器  向根请求,域名服务器负责递归向下</p></li><li class="lvl-2"><p>迭代查询</p><p>域名服务器将下一步应查找的域名服务器ip告知本地域名字服务器,本地负责继续向下查询</p></li></ul><p>为了减小根的压力,一般采用迭代.根服务器共有13套(不是13台机器)  ,每套又有多个镜像,更改根服务器数据只在a.rootservers.net上进行  然后同步.</p><p>为了提高查询效率,采取<strong>高速缓存</strong></p><h3 id="DNS报文格式">DNS报文格式</h3><p>资源记录RR格式:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Name:</span> <span class="string">example.com.</span></span><br><span class="line"><span class="attr">Type:</span> <span class="string">A</span> <span class="comment">#AAAA(ipv6),CNAME</span></span><br><span class="line"><span class="attr">Class:</span> <span class="string">IN</span> <span class="comment">#通常是IN,表示internet</span></span><br><span class="line"><span class="attr">TTL:</span> <span class="number">86400</span></span><br><span class="line"><span class="attr">RDLENGTH:</span> <span class="number">4</span></span><br><span class="line"><span class="attr">RDATA:</span> <span class="number">93.184</span><span class="number">.216</span><span class="number">.34</span></span><br></pre></td></tr></table></figure><h2 id="电子邮件-学什么">电子邮件???学什么???</h2><p>掌握电子邮件系统体系结构及基本工作原理</p><blockquote><p>SMTP(simple)， POP3， IMAP， Webmail；推/拉的模式</p></blockquote><h4 id="组成">组成</h4><ul class="lvl-0"><li class="lvl-2"><p>用户代理（user agent） ——邮件客户端</p></li><li class="lvl-2"><p>传输代理（message transfer agent） ——邮件服务器</p></li></ul><h4 id="分类">分类</h4><ul class="lvl-0"><li class="lvl-2"><p>SMTP:负责发件人的推,端口25</p></li><li class="lvl-2"><p>POP3,IMAP,Webmail(http)负责收件人的拉</p></li><li class="lvl-2"><p>POP3:收取/删除,端口110</p><p>客户:user,pass.服务器:OK,ERR.</p></li><li class="lvl-2"><p>IMAP:改进,邮件与文件夹关联;允许用户代理获取邮件某些部分</p></li><li class="lvl-2"><p>webmail:基于web&amp;http,用户代理就是普通的浏览器</p></li></ul><h2 id="WWW与HTTP">WWW与HTTP</h2><ul class="lvl-0"><li class="lvl-2"><h3 id="静态web">静态web</h3></li><li class="lvl-2"><h3 id="动态web">动态web</h3><ol><li class="lvl-5"><p>通用网关接口CGI:<strong>程序在服务器端处理</strong></p><p>Web服务器接收来自客户端（通常是Web浏览器）的请求，并将请求传递给后端的应用程序进行处理，然后将应用程序的响应返回给客户端。</p></li><li class="lvl-5"><p>脚本语言+数据库技术 (*.php, *.asp, *.aspx)  :<strong>服务器返回脚本程序,在客户端浏览器内执行</strong></p></li></ol></li></ul><h3 id="HTTP">HTTP</h3><ul class="lvl-0"><li class="lvl-2"><h4 id="http1-0">http1.0</h4><ol><li class="lvl-5"><strong>建连</strong>:TCP三次握手连接建立–&gt;所有的资源都需要完整的一次HTTP交互过程</li><li class="lvl-5"><strong>请求</strong>:Request （Get /index.html）</li><li class="lvl-5"><strong>响应</strong>:Respone</li><li class="lvl-5"><strong>关闭</strong>:关闭TCP连接</li></ol></li><li class="lvl-2"><h4 id="http1-1"><strong>http1.1</strong></h4><ol><li class="lvl-5">相比于1.0,提供持久连接,响应后保持连接.</li><li class="lvl-5">支持流水线机制,按序相应(同时请求一堆,经历较少的慢启动过程,减少往返时间)</li></ol></li><li class="lvl-2"><h4 id="https">https</h4><p>增加ssl,在tcp之上提供安全机制</p></li><li class="lvl-2"><h4 id="http2-0">http2.0</h4></li></ul><h3 id="代理服务器-proxy-server">代理服务器 proxy server</h3><ul class="lvl-0"><li class="lvl-2"><p>又称为万维网高速缓存(Web cache)，它代表浏览器发出 HTTP 请求</p></li><li class="lvl-2"><p>万维网高速缓存把最近的一些请求和响应暂存在本地磁盘中</p></li><li class="lvl-2"><p>当与暂时存放的请求相同的新请求到达时，万维网高速缓存就把暂存的响应发送出去，而不需要按 URL 的地址再去互联网访问该资源</p></li></ul><p>所有缓存的问题:<mark>缓存一致性</mark></p><p>解决方案:<mark>询问式策略</mark></p><p>• <strong>客户端</strong>：在发送的HTTP请求中指定缓存的时间，请求头包含If-modified-since: <date><br>• <strong>服务器</strong>：如果缓存的对象是最新的,响应头包含HTTP/1.1 304 NotModified,否则服务器响应HTTP/1.1 200 OK <data></p><h3 id="web安全与隐私🍪cookie">web安全与隐私🍪cookie</h3><p>讲了什么?感觉没什么新东西</p><h2 id="流媒体">流媒体</h2><p>分类:点播,直播,交互式(如腾讯会议)</p><h4 id="MPEG">MPEG</h4><p>图像组(GOP)一组连续的ipb画面</p><ul class="lvl-0"><li class="lvl-2"><p>帧内编码帧（I帧)<strong>关键帧</strong></p></li><li class="lvl-2"><p>预测帧（P帧）</p></li><li class="lvl-2"><p>双向帧（B帧）</p></li></ul><h3 id="点播流程">点播流程</h3><ul class="lvl-0"><li class="lvl-2"><p>web服务器返回的http内容指向一个<strong>元文件</strong>（有音/视频文件的统一资源定位符 URL)</p></li><li class="lvl-2"><p>客户浏览器将元文件交给媒体播放器</p></li><li class="lvl-2"><p>媒体播放器使用元文件url,向媒体服务器发送http请求</p></li><li class="lvl-2"><p>媒体播放器边下载,边压缩,边播放</p></li></ul><h4 id="缓存">缓存:</h4><p>为了消除抖动客户端播放的是本地缓冲区的内容，而不是立即播放来自网络的实时内容</p><h4 id="协议">协议:</h4><ul class="lvl-0"><li class="lvl-2"><p>RTSP(Real-Time Streaming Protocol),控制传输(如缓存),不包含数据</p></li><li class="lvl-2"><p>RTP(Real-time Transport Protocol),传输数据</p></li><li class="lvl-2"><p>RTCP (RTP Control Protocol),控制RTP,带有发送端和接收端对服务质量的统计信息报告</p></li><li class="lvl-2"><p>DASH,自适应码率ABR（Adaptive bitrate）</p></li></ul><h2 id="CDN-内容分发网络">CDN,内容分发网络</h2><p>一种Web缓存系统， 靠近边缘（用户） 提供内容服务</p><p><strong>HTTP重定向请求内容</strong>,网站所有者可以重写网页：通过CDN与内容链接的页面</p><h2 id="其它典型应用层协议">其它典型应用层协议</h2><h3 id="Telnet">Telnet:</h3><p>服务器端,23端口(客户端任意)</p><h3 id="FTP">FTP:</h3><p>服务器端,21端口控制,20端口传输(客户端同样任意)</p><h3 id="SNMP-简单网络管理协议">SNMP:简单网络管理协议</h3><p>用于管理和监控网络设备的标准协议。</p><p>SNMP消息使用一种叫做管理信息库（Management Information Base，MIB）的数据结构来组织和描述设备的信息。MIB是一个层次化的树状结构，其中包含了设备的各种参数和状态。管理员可以使用SNMP的操作（如GET、SET、TRAP等）来访问和操作MIB中的数据。</p><ul class="lvl-0"><li class="lvl-2"><p>get检测状态</p></li><li class="lvl-2"><p>set修改状态</p></li><li class="lvl-2"><p>trap代理不经检测就发送某些信息</p></li></ul><p><strong>节点的表示</strong><br>• 标识符：iso.org.dod.internet<br>• 标号： 1.3.6.1</p><h3 id="无线局域网WLAN">无线局域网WLAN</h3><h4 id="基础架构模式">基础架构模式</h4><ul class="lvl-0"><li class="lvl-2"><p>DS</p><ul class="lvl-2"><li class="lvl-4"><p>AP</p><ul class="lvl-4"><li class="lvl-6">STA</li><li class="lvl-6">STA</li></ul><p>AP-STAs组成基本服务集BSS</p></li><li class="lvl-4"><p>AP</p></li></ul></li></ul><h4 id="自组织模式">自组织模式</h4><p>站点（STA),IBSS,站点之间直接通信</p><ol><li class="lvl-3"><p>DS（Distribution System）：DS是指分布式系统，它是由多个无线接入点（Access Point，AP）组成的网络。DS用于连接不同的AP，使它们能够互相通信和协调工作。DS负责传输数据、管理移动设备的漫游和提供无线网络的覆盖范围扩展等功能。在一个DS中，AP之间通过无线连接或有线连接（如以太网）进行通信。</p></li><li class="lvl-3"><p>AP（Access Point）：AP是无线局域网中的无线接入点，也被称为基站或无线路由器。它是无线网络的中心设备，用于提供无线连接和网络接入。AP接收来自无线设备（如笔记本电脑、智能手机）的数据，并将其转发到有线网络或其他无线设备。AP负责无线信号的传播和接收，同时还提供安全认证、数据加密等功能。</p></li><li class="lvl-3"><p>无线局域网（WLAN）：无线局域网是一种使用无线通信技术连接设备的局域网。它允许用户通过无线方式连接到网络，而无需使用传统的有线连接。</p></li><li class="lvl-3"><p>Wi-Fi：Wi-Fi是一种基于无线局域网技术的标准，用于在设备之间进行无线通信。Wi-Fi技术基于IEEE 802.11标准，提供了高速数据传输和广泛的设备兼容性。</p></li><li class="lvl-3"><p>无线访问点（Access Point，AP）：无线访问点是无线局域网的中心设备，用于提供无线连接和网络接入。它接收来自无线设备的数据，并将其转发到有线网络或其他无线设备。</p></li><li class="lvl-3"><p>SSID：SSID代表无线局域网的服务集标识（Service Set Identifier），它是用于唯一标识一个无线网络的名称。用户通过选择特定的SSID来连接到所需的无线网络。</p></li></ol><h3 id="IEEE-802-11帧格式">IEEE 802.11帧格式</h3><ul class="lvl-0"><li class="lvl-2"><p>帧控制：具有多种用途</p></li><li class="lvl-2"><p>持续时间：下一个要发送帧可能持续的时间（NAV）或关联ID（AID）</p></li><li class="lvl-2"><p>地址1~地址4：每个地址的含义基于“去往DS”和“来自DS”域段确定</p></li><li class="lvl-2"><p>顺序控制：通过序号过滤掉重复帧，或用于分片组合</p></li><li class="lvl-2"><p>QoS控制域段：存放数据流的QoS信息（802.11e中扩展）</p></li><li class="lvl-2"><p>数据：包含任意长度的数据（0-2312字节）</p></li><li class="lvl-2"><p>CRC校验： 802.11采用4个字节的校验码</p></li></ul><table><thead><tr><th>说明</th><th>去往DS Distribution System</th><th>来自DS Distribution System</th><th>地址1 （物理[实际]接收者）</th><th>地址2 （物理发送者）</th><th>地址3 （逻辑[最终]收发者）</th><th>地址4 （逻辑收发者）</th></tr></thead><tbody><tr><td>自组织模式</td><td>0</td><td>0</td><td>DA</td><td>SA</td><td>IBSSID</td><td>—</td></tr><tr><td>接收自AP</td><td>0</td><td>1</td><td>DA</td><td>BSSID</td><td>SA</td><td>—</td></tr><tr><td>发送至AP</td><td>1</td><td>0</td><td>BSSID</td><td>SA</td><td>DA</td><td>—</td></tr><tr><td>AP到AP</td><td>1</td><td>1</td><td>接收AP</td><td>发送AP</td><td>DA</td><td>SA</td></tr></tbody></table><h3 id="CSMA-CA">CSMA/CA</h3><p>带冲突避免的载波侦听多路访问</p><p>当线路忙时,每次准备发送时先退后</p><h4 id="差错检测与确认重传">差错检测与确认重传</h4><p>停等机制,服务器发送Ack.服务器的IFS比客户端小</p><h4 id="终端暴露问题">终端暴露问题</h4><p>• 目的：通过信道预约，避免数据帧(长帧)冲突<br>• 发送端发送RTS（request to send）<br>• 接收端回送CTS（clear to send）</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计2：参数点估计</title>
      <link href="/notes/gaitong/%E7%BB%9F%E8%AE%A12-%E5%8F%82%E6%95%B0%E7%82%B9%E4%BC%B0%E8%AE%A1/"/>
      <url>/notes/gaitong/%E7%BB%9F%E8%AE%A12-%E5%8F%82%E6%95%B0%E7%82%B9%E4%BC%B0%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1>统计2：参数点估计</h1><p>参数估计:就是用样本来估计总体分布的参数$\theta$<br>$$<br>\hat\theta=\theta(X_1,X_2,\ldots,X_n)<br>$$<br>加一个hat,i.e$.\hat \theta$,就表示估计</p><p>两种最常用的点估计方法是<strong>矩估计</strong>和<strong>极大似然估计</strong></p><h3 id="矩估计">矩估计</h3><p>就是用样本矩估计理论矩</p><h4 id="基本方法">基本方法:</h4><ul class="lvl-0"><li class="lvl-2"><p>$$<br>E(X)=\mu\simeq\bar x<br>$$</p></li><li class="lvl-2"><p>$$<br>Var(x)=\sigma^2\simeq S^2=\frac 1 {n-1} \sum \limits_{i=1}^n(x-\bar x)^2<br>$$</p></li></ul><p><img src="/img/gaitong/%E7%BB%9F%E8%AE%A12-%E5%8F%82%E6%95%B0%E7%82%B9%E4%BC%B0%E8%AE%A1.assets/image-20230607170740516.png" alt="image-20230607170740516"></p><h3 id="极大似然估计">极大似然估计</h3><p>基于一个简单的思想：寻找最有可能产生观测数据的参数值。</p><p>设总体概率函数为$p(x;\theta),\theta$为参数，$x_1,x_2,\ldots,x_k$为样本,则样本联合概率分布函数$L(\theta)=\prod\limits_{k=1}^np(x_k;\theta)$,我们找到$\hat\theta$使得$L(\theta)$取得最大值</p><p>操作上,由于对连乘求导不方便,我们常常对L(θ)取对数得到$l(\theta)$</p><h3 id="卡方分布">卡方分布</h3><p>假设$X_1, X_2, \ldots, X_k$是独立同分布（iid）的标准正态分布（即均值为0，方差为1），那么定义随机变量($Y = X_1^2 + X_2^2 + \ldots + X_k^2$)，则(Y)服从自由度为(k)的卡方分布。</p><p>数学公式表示为：<br>$Y \sim \chi^2(k)$</p><p>其中，X是符合卡方分布的随机变量，k是自由度。</p><h3 id="t分布（t-distribution）"><strong>t分布（t-distribution）</strong></h3><p>假设X是来自标准正态分布的随机变量，Y是来自卡方分布的自由度为k的随机变量（独立于X），则定义随机变量$T = \frac{X}{\sqrt {Y/k} }$，则T服从自由度为k的t分布。</p><p>数学公式表示为： $T \sim t(k)$</p><p>其中，T是符合t分布的随机变量，k是自由度。</p><h3 id="F分布（F-distribution）">F分布（F-distribution）</h3><p>假设Y1是来自自由度为k1的卡方分布的随机变量，Y2是来自自由度为k2的卡方分布的随机变量（两者独立），则定义随机变量$F = \frac{ {Y1}/{k1} } { {Y2}/ {k2} }$，则F服从自由度为k1和k2的F分布。</p><p>数学公式表示为： $F \sim F(k1, k2)$</p><p>其中，F是符合F分布的随机变量，k1和k2是自由度。</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
          <category> gaitong </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gaitong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论部分（单变量）</title>
      <link href="/notes/gaitong/%E9%9A%8F%E6%9C%BA/"/>
      <url>/notes/gaitong/%E9%9A%8F%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1>概率论部分（单变量）</h1><h2 id="一、-随机现象的数学描述和概率论的基本思想">一、 随机现象的数学描述和概率论的基本思想</h2><ol><li class="lvl-3"><p>随机事件之间的关系和事件的基本运算。</p></li><li class="lvl-3"><p>理解条件概率的直观含义和数学定义，掌握条件概率在概率计算中的应用（乘法公式、全概率公式、Bayes 公式）。</p><p>乘法公式：<br>$$<br>P(A \cap B) = P(B|A) \cdot P(A)<br>$$<br>全概率公式：<br>$$<br>P(B) = \sum_i P(B|A_i) \cdot P(A_i)<br>$$<br>Bayes公式：设$A_1,\dots,A_n$为样本空间的一个分割<br>$$<br>P(A_i|B) = \frac{P(B|A_i) \cdot P(A_i)}{\sum_j P(B|A_j) \cdot P(A_j)}<br>$$<br>其中，A和B是事件，P(A)表示事件A发生的概率，P(B)表示事件B发生的概率，P(B|A)表示在事件A发生的条件下事件B发生的概率，A_i表示一系列互斥且完备的事件。</p></li><li class="lvl-3"><p>理解事件的独立性的定义和有关性质。</p><p>事件独立性的定义： 事件A和事件B被称为独立事件，如果满足以下条件：P(A∩B)=P(A)⋅P(B)</p><p>否则称A与B不独立或相关</p><p>如果事件A和事件B是独立事件，则事件A与事件B的并集的概率等于事件A的概率加上事件B的概率减去事件A和事件B的交集的概率：P*(<em>A</em>∪<em>B</em>)=<em>P</em>(<em>A</em>)+<em>P</em>(<em>B</em>)−<em>P</em>(<em>A</em>∩*B)</p></li></ol><h3 id="tips：">tips：</h3><p>抽签模型与次序无关：第一次抽中白球的概率和第二次抽中白球的概率是相同的，无论放不放回。</p><h2 id="随机变量的概率分布">随机变量的概率分布</h2><ol><li class="lvl-3"><p>理解随机变量及其概率分布函数的定义，理解随机变量概率分布函数的性质，掌握概率分布函数的计算。</p><p>分布函数：$F(x)=P(X\leq x)$</p></li><li class="lvl-3"><p>理解离散型随机变量、连续型随机变量的定义，掌握概率分布列、概率密度函数及概率分布函数的关系，掌握有关的计算。</p></li><li class="lvl-3"><p>理解多维随机变量的定义，理解联合概率分布（分布函数、分布列、概率密度）与边缘分布（分布函数、分布列、概率密度），掌握有关计算。</p></li><li class="lvl-3"><p>理解随机变量的独立性的定义和性质，掌握判断独立和不独立的方法</p></li></ol><h2 id="三、-随机变量的数字特征">三、 随机变量的数字特征</h2><ol><li class="lvl-3"><h3 id="单个随机变量的数字特征">单个随机变量的数字特征</h3></li></ol><p>a) 数学期望和方差：<br>i. 理解数学期望的定义，理解数学期望的存在性，掌握数学期望的性质和计算。<br>ii. 理解方差的定义和直观含义，掌握方差的性质和计算。<br>iii. 理解如何线性变换对随机变量进行期望=0，方差=1 的标准化。<br>iv. 理解期望、方差的下述性质：<br>b) 原点矩和中心矩。<br>c) 切比雪夫（Chebyshev）不等式。</p><p>对于任意随机变量X，具有有限方差E[(X-μ)²] = σ²，其中μ是X的均值，σ²是X的方差。对于任意正数ε &gt; 0，切比雪夫不等式给出：</p><p>$$<br>P(|X - \mu| \geq \epsilon) \leq \frac<br>$$<br>即随机变量X偏离其均值μ超过ε的概率不会超过方差σ²除以ε²。</p><ol start="2"><li class="lvl-3"><h3 id="涉及多个随机变量的数字特征">涉及多个随机变量的数字特征</h3></li></ol><p>a) 协方差：理解协方差的定义和性质，掌握协方差的计算。</p><p>b) 相关系数：理解相关系数的定义和性质，掌握有关计算。正确理解不相关和独立的联系与区别。知道线性相关系数为 1 或-1 时的概率含义。</p><p>当涉及到协方差和相关系数时，以下是它们的公式：</p><p>协方差（Covariance）的公式：<br>$$<br>\text{Cov}(X, Y) = E\left[(X - \mu_X)(Y - \mu_Y)\right]=E(XY)-E(X)E(Y)<br>$$<br>相关系数（Correlation coefficient）的公式：<br>$$</p><p>$$<br>其中，$\text{Cov}(X, Y)$ 表示随机变量X和Y的协方差，$\mu_X 和 \mu_Y$ 分别是X和Y的均值(期望)，($\sigma_X$) 和 ($\sigma_Y$) 分别是X和Y的标准差。($\rho(X, Y)$) 表示随机变量X和Y的相关系数。</p><p>c) 条件数学期望：理解定义和有关计算，掌握全（重）期望公式，包括随机和（指求和的随机变量的个数为某随机变量）的期望。<br>$$<br>E(X) = E(X|B) \cdot P(B) + E(X|B^c) \cdot P(B^c)<br>$$</p><h2 id="四、-常见的概率分布">四、 常见的概率分布</h2><h3 id="离散型分布">离散型分布</h3><p><strong>a) 二项分布</strong>：分布列，期望、方差。<br><strong>b) 几何分布</strong>：分布列，期望、方差，无记忆性。<br><strong>c) 泊松分布</strong>：分布列，期望、方差，泊松定理（特殊二项分布的泊松近似）。</p><p>当二项分布中的试验次数<em>n</em>趋向于无穷大，且成功概率<em>p</em>趋向于0，但同时满足np接近一个常数λ时，二项分布可以近似为泊松分布。</p><p><strong>d) 负二项分布</strong>：定义，与几何分布的关系，期望，方差。</p><p>定义：单次成功概率为p成功次数达r时失败次数的<a href="https://zh.wikipedia.org/wiki/%E7%A6%BB%E6%95%A3%E6%A6%82%E7%8E%87%E5%88%86%E5%B8%83">离散概率分布</a>。注意当r取1时即为几何分布</p><table><thead><tr><th>分布</th><th>分布列</th><th>期望</th><th>方差</th></tr></thead><tbody><tr><td>二项分布</td><td>$P(X=k) = \binom{n}{k} p^k (1-p)^{n-k}$</td><td>$np$</td><td>$np(1-p)$</td></tr><tr><td>几何分布</td><td>$P(X=k) = (1-p)^{k-1} p$</td><td>$\frac{1}{p}$</td><td>$\frac{1-p}{p^2}$</td></tr><tr><td>泊松分布</td><td>$P(X=k) = \frac{e^{-\lambda} \lambda^k}{k!}$</td><td>$\lambda$</td><td>$\lambda$</td></tr><tr><td>负二项分布</td><td>$P(X=k+r) = \binom{k+r-1}{r-1} p^r (1-p)^{k}$</td><td>$\frac{r}{p}$</td><td>$\frac{r(1-p)}{p^2}$</td></tr></tbody></table><h3 id="连续型分布">连续型分布</h3><p>a) 均匀分布：一维均匀分布的分布函数、概率密度、期望和方差；多维均匀分布与几何概型的关系。<br>b) 指数分布：分布函数、概率密度、期望、方差，无记忆性。<br>c) 正态分布：一维正态分布的概率密度、期望、方差、标准化；二维正态分布的概率密度及参数的概率含义。正态分布的独立可加性，二元正态分布随机变量相互独立和不相关等价的性质。</p><h2 id="五、-极限定理">五、 极限定理</h2><ol><li class="lvl-3"><p>（伯努利、切比雪夫）（弱）大数定律，依概率收敛的定义，利用切比雪夫不等式验证依概率收敛。</p><p><strong>伯努利大数定律</strong>：伯努利实验中，随着试验次数增加，频率落在概率附近的概率趋于1</p><p><strong>切比雪夫大数定律</strong>：利用切比雪夫不等式，两两不相关的随机变量序列，方差有界，随着序列项数增加，随机变量均值落在期望附近的概率趋于1</p><p>切比雪夫的</p><img src="/img/gaitong//%E5%8D%95%E5%8F%98%E9%87%8F%E9%9A%8F%E6%9C%BA.assets/image-20230607163414308.png" alt="image-20230607163414308" style="zoom:80%;" /><p>$$Var(\frac 1 n \sum X_k)\rarr0$$为马尔可夫条件</p><p><strong>依概率收敛</strong></p><p>当一个随机变量序列以概率1逐渐接近另一个随机变量时，我们称该序列依概率收敛于该随机变量。</p></li><li class="lvl-3"><p>中心极限定理（掌握独立同分布情形 De Moivre-Laplace，林德伯格-勒维）及应用</p><h5 id="中心极限定理">中心极限定理</h5><p>$X_1, X_2, \ldots, X_k$是独立同分布（iid）<br>$$<br>X_1+X_2+ \ldots+X_k\overset{.}{\sim}N(n\mu,n\sigma^2)\<br>\frac {X_1+X_2+ \ldots+X_k -n\mu}{\sigma\sqrt n}\overset{.}{\sim}N(0,1)<br>$$<br>一般地,$b(n,p)\overset{.}{\sim}N(np,npq)$</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
          <category> gaitong </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gaitong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计3：区间估计</title>
      <link href="/notes/gaitong/%E7%BB%9F%E8%AE%A13-%E5%8C%BA%E9%97%B4%E5%81%87%E8%AE%BE/"/>
      <url>/notes/gaitong/%E7%BB%9F%E8%AE%A13-%E5%8C%BA%E9%97%B4%E5%81%87%E8%AE%BE/</url>
      
        <content type="html"><![CDATA[<h1>统计3：区间估计</h1><h5 id="置信水平">置信水平</h5><p>一个置信水平1-α的区间估计的含义是，得到的区间以1-α覆盖被估的参数</p><h3 id="基本方法">基本方法</h3><ol><li class="lvl-3"><p><strong>构造枢轴量</strong>pivot，$G(x_1,\ldots,x_n,\theta)$</p><p>要求,G的分布不依赖于参数$\theta$,否则第2步无法解出不等式</p></li><li class="lvl-3"><p><strong>找到G的边界</strong>适当选取两个常数c,d,对给定的$\alpha有P(c\leq G\leq d)\geq 1- α$</p></li><li class="lvl-3"><p><strong>求解</strong>$c\leq G(x_1,\ldots,x_n,\theta)\leq d$,得到$\theta$的两个估计值边界</p></li></ol><h2 id="预知识">预知识</h2><h3 id="卡方分布">卡方分布</h3><p>假设$X_1, X_2, \ldots, X_k$是独立同分布（iid）的标准正态分布（即均值为0，方差为1），那么定义随机变量($Y = X_1^2 + X_2^2 + \ldots + X_k^2$)，则(Y)服从自由度为(k)的卡方分布。</p><p>数学公式表示为：<br>$Y \sim \chi^2(k)$</p><p>其中，X是符合卡方分布的随机变量，k是自由度。</p><h3 id="t分布（t-distribution）"><strong>t分布（t-distribution）</strong></h3><p>假设X是来自标准正态分布的随机变量，Y是来自卡方分布的自由度为k的随机变量（独立于X），则定义随机变量$T = \frac{X}{\sqrt {Y/k} }$，则T服从自由度为k的t分布。</p><p>数学公式表示为： $T \sim t(k)$</p><p>其中，T是符合t分布的随机变量，k是自由度。</p><h3 id="F分布（F-distribution）">F分布（F-distribution）</h3><p>假设Y1是来自自由度为k1的卡方分布的随机变量，Y2是来自自由度为k2的卡方分布的随机变量（两者独立），则定义随机变量$F = \frac{ {Y1}/{k1} } { {Y2}/ {k2} }$，则F服从自由度为k1和k2的F分布。</p><p>数学公式表示为： $F \sim F(k1, k2)$</p><p>其中，F是符合F分布的随机变量，k1和k2是自由度。</p><h1>解题方法</h1><h3 id="背就完事了">背就完事了</h3><h4 id="1-N-mu-sigma2-sigma2已知-mu未知-求-mu">$1.N(\mu,\sigma<sup>2),\sigma</sup>2已知,\mu未知,求\mu$</h4><p>$G=\frac {\sqrt n (\bar x - \mu)} \sigma \sim N(0,1)$,$d=u_{1-\alpha/2},c=u_{\alpha/2}=-u_{1-\alpha/2}$</p><p><img src="/img/gaitong//%E7%BB%9F%E8%AE%A13-%E5%8C%BA%E9%97%B4%E5%81%87%E8%AE%BE.assets/image-20230607193734916.png" alt="image-20230607193734916"></p><h4 id="2-N-mu-sigma2-sigma2未知-mu未知-求-mu">$2.N(\mu,\sigma<sup>2),\sigma</sup>2未知,\mu未知,求\mu$</h4><p>由于$\sigma$未知,所以想办法约掉$\sigma$:<br>$$<br>\frac {(n-1)s<sup>2}{\sigma</sup>2}\sim \chi^2(n-1)<br>$$<br><img src="/img/gaitong//%E7%BB%9F%E8%AE%A13-%E5%8C%BA%E9%97%B4%E5%81%87%E8%AE%BE.assets/image-20230607193937549.png" alt="image-20230607193937549" style="zoom:80%;" /></p><p>$d=t_{1-\alpha/2}(n-1),c=-t_{1-\alpha/2}(n-1)$</p><p><img src="/img/gaitong//%E7%BB%9F%E8%AE%A13-%E5%8C%BA%E9%97%B4%E5%81%87%E8%AE%BE.assets/image-20230607194203682.png" alt="image-20230607194203682"></p><h4 id="3-N-mu-sigma2-sigma2未知-mu未知-求-sigma-2">$3.N(\mu,\sigma<sup>2),\sigma</sup>2未知,\mu未知,求\sigma^2$</h4><p>$$<br>\frac {(n-1)s<sup>2}{\sigma</sup>2}\sim \chi^2(n-1)<br>$$</p><img src="/img/gaitong//%E7%BB%9F%E8%AE%A13-%E5%8C%BA%E9%97%B4%E5%81%87%E8%AE%BE.assets/image-20230607194622743.png" alt="image-20230607194622743" style="zoom: 67%;" /><h3 id="4">4.</h3><img src="/img/gaitong//%E7%BB%9F%E8%AE%A13-%E5%8C%BA%E9%97%B4%E5%81%87%E8%AE%BE.assets/image-20230607195007278.png" alt="image-20230607195007278" style="zoom:67%;" /><h3 id="大样本区间估计">大样本区间估计</h3><p>样本容量足够大时,用样本统计量替换总体统计量</p><img src="/img/gaitong//%E7%BB%9F%E8%AE%A13-%E5%8C%BA%E9%97%B4%E5%81%87%E8%AE%BE.assets/image-20230607195154548.png" alt="image-20230607195154548" style="zoom:67%;" />]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
          <category> gaitong </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gaitong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计4：假设检验</title>
      <link href="/notes/gaitong/%E7%BB%9F%E8%AE%A14-%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/"/>
      <url>/notes/gaitong/%E7%BB%9F%E8%AE%A14-%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h1>统计4：假设检验</h1><p>$H_0 : \theta\in\Theta_0~~~ vs~~~ H_1 : \theta\in\Theta_1$</p><p>假设检验是一种统计方法，用于评估关于总体参数的假设是否与观察到的样本数据一致。</p><p>总的原理是<strong>假如试验结果与假设日发生矛盾就拒绝原假设 也否则就接受原假设.</strong></p><p><img src="/img/gaitong//%E7%BB%9F%E8%AE%A14-%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C.assets/image-20230607195628247.png" alt="image-20230607195628247"></p><h2 id="定义">定义</h2><ul class="lvl-0"><li class="lvl-2"><p><strong>(统计)假设检验问题</strong></p><p>这是在给定总体与样本下 ，要求对命题做出判断。</p></li><li class="lvl-2"><p><strong>(统计)假设</strong></p><p>统计学中两个非空不相交参数集合$\Theta_0,\Theta_1$,命题成立对应$\theta\in\Theta_0$,否则$\theta\in\Theta_1$</p></li><li class="lvl-2"><p><strong>参数假设检验问题</strong></p><p>假设可用一个参数的集合表示的假设检验问题</p><p>例子:</p><ul class="lvl-2"><li class="lvl-4"><p>均值是否大于4是参数假设检验问题</p></li><li class="lvl-4"><p>是否为正态分布不是,不能用一个参数的集合检验</p></li></ul></li><li class="lvl-3"><p><strong>检验(法则)</strong></p></li></ul><p>通过样本对假设做出判断</p><ul class="lvl-0"><li class="lvl-2"><p><strong>原(零)假设$\Theta_0$与对立(备择)假设$\Theta_1$</strong></p><ul class="lvl-2"><li class="lvl-4"><p>如果$\Theta_0$只含一个点则称为是简单的,否则是复杂的</p></li><li class="lvl-4"><p>$H_0 : \theta\in\Theta_0~~~ vs~~~ H_1 : \theta\in\Theta_1$</p></li><li class="lvl-4"><p><strong>接受域</strong>:样本空间接受H_0的区域</p><blockquote><p>确定了接受域和拒绝域,只需要看样本属于哪个样本空间就完成检验了</p></blockquote></li></ul></li><li class="lvl-2"><p><strong>错误</strong></p><ul class="lvl-2"><li class="lvl-4"><p><strong>第一类错误</strong></p><p>本应接受,结果拒绝,犯错概率称为α(θ)</p></li><li class="lvl-4"><p><strong>第二类错误</strong></p><p>本应拒绝,结果接受，犯错概率称为β(θ)</p></li></ul><p>由于不可能同时降低这两个错误,所以我们仅控制第一类错误.宁肯放过一千,也不错杀一个.</p></li><li class="lvl-2"><p><strong>势函数g(θ)</strong></p><p>样本落在拒绝域内的概率<br>$$<br>\theta\in\Theta_0,g(\theta)=\alpha(\theta),\<br>\theta\in\Theta_1,g(\theta)=1-\beta(\theta)<br>$$</p></li><li class="lvl-2"><p><strong>显著性水平</strong>$\alpha$</p><p>对任意的$\Theta_0$中$\theta$,都有势函数$\leq$α</p><blockquote><p>控制第一类犯错的概率在α内</p></blockquote></li><li class="lvl-2"><p><strong>U检验</strong></p><p>方差已知，对正态总体均值进行检验</p><p><img src="/img/gaitong//%E7%BB%9F%E8%AE%A14-%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C.assets/image-20230531180954677.png" alt="image-20230531180954677"></p></li><li class="lvl-2"><p><strong>t检验</strong></p><p>方差未知，对正态总体均值进行检验</p><p><img src="/img/gaitong//%E7%BB%9F%E8%AE%A14-%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C.assets/image-20230531181013647.png" alt="image-20230531181013647"></p></li><li class="lvl-2"><p><strong>p值</strong></p></li><li class="lvl-2"><p>利用样本观测值能够做出拒绝原假设的最小显著性水平</p><p>原假设成立条件下，检验统计量出现在比观测值更异常的范围的概率的最大值</p></li></ul><h2 id="基本步骤">基本步骤</h2><ol><li class="lvl-3"><p>建立假设</p><ul class="lvl-2"><li class="lvl-5">$H_0 : \theta\in\Theta_0~~~ vs~~~ H_1 : \theta\in\Theta_1$</li></ul></li><li class="lvl-3"><p>选择检验统计量，给出拒绝域的形式</p></li><li class="lvl-3"><p>选择显著性水平，给出拒绝域的具体范围</p></li></ol><h4 id="例题">例题<img src="/img/gaitong//%E7%BB%9F%E8%AE%A14-%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C.assets/image-20230531173915668.png" alt="image-20230531173915668"></h4><ol><li class="lvl-3"><p>建立假设（H_0,优质,μ$\geq$10）</p><p><strong>注意这里优劣并不一定对应原假设/对立假设。</strong></p><div class="tips"><p>按照过去长时间的记录，商店的检验人员相信该厂的产品质量很好，可能选择μ&gt;10为原假设</p><p>如果认为不好也可能选择μ&lt;10为原假设</p></div></li><li class="lvl-3"><p>选择检验统计量</p><p>$\bar x\sim N(\mu,\frac {2^2} {16} )$,拒绝域形式为{(样本),$\bar x$&lt;c}</p></li><li class="lvl-3"><p>确定显著性水平<br>$$<br>P(\bar x&lt;c|\mu = 10)=\alpha\<br>P\left(\frac {\bar x-10} {1/2}&lt;\frac {c-10} {1/2}\right)=\alpha，\frac {\bar x-10} {1/2}\sim N(0,1)<br>$$<br>如果这里α取0.05，那么可以求得</p><p>c=10+$2u_{0.05}$</p></li><li class="lvl-3"><p>$\bar x&gt;c$时，接受原假设，否则拒绝</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
          <category> gaitong </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gaitong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计5：拟合优度检验</title>
      <link href="/notes/gaitong/%E7%BB%9F%E8%AE%A15-%E6%8B%9F%E5%90%88%E4%BC%98%E5%BA%A6%E6%A3%80%E9%AA%8C/"/>
      <url>/notes/gaitong/%E7%BB%9F%E8%AE%A15-%E6%8B%9F%E5%90%88%E4%BC%98%E5%BA%A6%E6%A3%80%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h1>统计5:拟合优度检验</h1><p>我的拟合是否合理?</p><h3 id="K-Pearson的χ2检验（拟合优度检验）">K.Pearson的χ2检验（拟合优度检验）</h3><p>χ² = $\sum \limits _{i=1}^k$ [(观察值 - 期望值)² / 期望值],近似服从自由度为k-1的χ²分布</p><p>若需要通过样本估计s个参数,则服从自由度为k-s-1的卡方分布</p><h3 id="独立性检验">独立性检验</h3><p>列联表检验</p><img src="/img/gaitong//%E7%BB%9F%E8%AE%A15-%E6%8B%9F%E5%90%88%E4%BC%98%E5%BA%A6%E6%A3%80%E9%AA%8C.assets/image-20230607210438587.png" alt="image-20230607210438587" style="zoom:80%;" />]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
          <category> gaitong </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gaitong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>network-homework-14</title>
      <link href="/homework/network/network14/"/>
      <url>/homework/network/network14/</url>
      
        <content type="html"><![CDATA[<h1>网原第14次作业</h1><p>郭高旭 2021010803 <a href="mailto:ggx21@mails.tsinghua.edu.cn">ggx21@mails.tsinghua.edu.cn</a></p><h3 id="1">1</h3><ol><li class="lvl-3"><p>SMTP，http</p></li><li class="lvl-3"><p>SMTP</p></li><li class="lvl-3"><p>POP3，IMAP，http</p></li></ol><h3 id="2-C">2.C</h3><h3 id="3">3.</h3><p>0.2mb</p><p>15.8mb</p><h3 id="4">4.</h3><ol><li class="lvl-3"><p>用户发送请求： 当用户在浏览器中输入网址或点击链接访问一个网站时，请求将被发送到最接近用户位置的DNS服务器。DNS服务器将返回一个CDN的负载均衡器的IP地址。</p></li><li class="lvl-3"><p>CDN负载均衡器： 用户请求到达CDN的负载均衡器，它的作用是选择最适合响应请求的边缘服务器。负载均衡器会考虑到用户的位置、服务器的负载情况和网络条件等因素，选择一个最佳的边缘服务器。</p></li><li class="lvl-3"><p>边缘服务器： 负载均衡器将用户请求转发到最合适的边缘服务器。边缘服务器位于离用户最近的物理位置或网络接入点，它们存储着网站的静态内容的副本。</p></li><li class="lvl-3"><p>边缘服务器处理请求： 边缘服务器接收到用户请求后，会检查自己是否已经缓存了请求的内容。如果有缓存，边缘服务器直接返回缓存的内容给用户。如果没有缓存，边缘服务器会向源服务器发起请求。</p></li><li class="lvl-3"><p>源服务器响应： 边缘服务器向源服务器发送请求，源服务器是原始网站的主机服务器。源服务器响应请求并返回所需的内容给边缘服务器。</p></li><li class="lvl-3"><p>边缘服务器返回内容： 边缘服务器接收到源服务器的响应后，将内容缓存起来，并将响应内容返回给用户。</p></li><li class="lvl-3"><p>用户获取内容： 用户浏览器接收到来自边缘服务器的响应后，显示网页或加载所请求的内容。用户可以享受较低的延迟和更快的加载速度，因为边缘服务器位于较接近用户的位置。</p></li></ol><h3 id="5">5.</h3><ol><li class="lvl-3"><p>主机A解析URL： 主机A首先解析URL（<a href="ftp://ftp.abc.edu.cn/file%EF%BC%89%E4%BB%A5%E8%8E%B7%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%B8%BB%E6%9C%BA%E5%90%8D%EF%BC%88ftp.abc.edu.cn%EF%BC%89%E5%92%8C%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%EF%BC%88/file%EF%BC%89">ftp://ftp.abc.edu.cn/file）以获取服务器的主机名（ftp.abc.edu.cn）和文件路径（/file）</a></p></li><li class="lvl-3"><p>通过DNS或检查本地域名与ip关系获得服务器ip</p></li><li class="lvl-3"><p>客户进程与服务器TCP21端口三次握手建立TCP连接,整个会话期间一直保持,用来控制连接</p></li><li class="lvl-3"><p>客户进程发出文件传输请求到服务器TCP21端口</p></li><li class="lvl-3"><p>服务器控制进程创建数据传输进程（TCP20端口）  和客户端数据传输进程建立新的TCP连接</p></li><li class="lvl-3"><p>数据连接用来连接客户进程和服务器数据传输进程， 实际完成文件的传输</p></li><li class="lvl-3"><p>完成下载： 一旦文件传输完成，服务器发送一个成功的响应。主机A收到响应后，关闭数据连接和控制连接，表示下载过程结束。</p></li></ol><h3 id="思考题1">思考题1</h3><p>C,</p><h3 id="1-C">1.C</h3><p>c能够收到A的RTS维护NAV,D不能</p><h3 id="2">2.</h3><ol><li class="lvl-3"><p>00-12-34-56-78-9b</p></li><li class="lvl-3"><p>00-12-34-56-78-9a</p></li><li class="lvl-3"><p>00-12-34-56-78-9c</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> homework </category>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> homework </tag>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>network-homework-13</title>
      <link href="/homework/network/network13/"/>
      <url>/homework/network/network13/</url>
      
        <content type="html"><![CDATA[<h1>网原第13次作业</h1><p>郭高旭 2021010803 <a href="mailto:ggx21@mails.tsinghua.edu.cn">ggx21@mails.tsinghua.edu.cn</a></p><h3 id="1-B">1. B</h3><h3 id="2">2.</h3><p>如果一个DNS分组丢失且没有自动恢复， 这是否会导致什么问题？应该如何解决？</p><ol><li class="lvl-3"><p>可能会导致不完整的或无法解析的查询结过，客户端无法解析或获得错误的DNS记录，导致延迟或超时。</p></li><li class="lvl-3"><p>客户端重试，如果在指定时间内未收到可以正确解析的响应则重新请求DNS。可以设置更多的DNS服务器，使查询更可靠</p></li></ol><h3 id="3">3.</h3><ol><li class="lvl-3"><p>SMTP，http</p></li><li class="lvl-3"><p>SMTP</p></li><li class="lvl-3"><p>POP3，IMAP，webmail，http</p></li></ol><h3 id="4-C">4.C</h3><h3 id="思考题：D">思考题：D</h3><p>最短时间：本地存有域名到ip的记录。只需要TCP建立连接与请求资源两个RTT</p><p>最长时间：加上主机到本地域名服务器，本地域名服务器迭代查找根、顶级、次级的3个rtt</p>]]></content>
      
      
      <categories>
          
          <category> homework </category>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> homework </tag>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人智导PA3实验报告</title>
      <link href="/notes/pytorch/connect-4/"/>
      <url>/notes/pytorch/connect-4/</url>
      
        <content type="html"><![CDATA[<h1>四子棋实验报告</h1><p>郭高旭 <a href="mailto:ggx21@mails.tsinghua.edu.cn">ggx21@mails.tsinghua.edu.cn</a> 2021010803</p><h2 id="最终版本的对抗结果">最终版本的对抗结果</h2><p>胜率稳定在93%以上。</p><h2 id="实验方法">实验方法</h2><p>实现了α-β剪枝算法。</p><h3 id="原理">原理</h3><p>α-β剪枝算法是基于max-min算法实现的。与蒙特卡洛对棋局随机模拟不同，max-min算法需要对棋局进行<mark>形势判断</mark>,由此给出max-min决策树上每一点的分值.</p><p>所以max-min算法的成功率不仅取决于计算量,也取决于形势判断函数的精度.</p><p>α-β剪枝的作用是:<em>对方已经有了更好的选择，不需要再继续搜索，因为对方会选择让我方分数最小的点</em>.</p><p>所以整个α-β剪枝算法相比于蒙特卡洛而言更加类似于人类棋手的思维模式:</p><ol><li class="lvl-3"><p>拓展决策树到目的深度(实际上是dfs的过程)</p></li><li class="lvl-3"><p>给出叶子结点的形势判断</p></li><li class="lvl-3"><p>上层的opponent选择对当前层player最不利的下法(返回分值)</p></li><li class="lvl-3"><p>其中进行a-b剪枝,如果祖父层的player发现下过某一步后,opponent给出了比祖父player目前最优选择的结果更差的一步,祖父player不需要知道自己走的这一步究竟多差,放弃选择这一步.</p></li></ol><h3 id="具体实现">具体实现</h3><h4 id="max-min算法">max-min算法</h4><p>原理1-3部分实际上就是算法的基本实现过程，其中player（我）是max结点，会选择对我最有利的局面；opponent是min结点，会选择对我最不利的结点。</p><h4 id="α-β剪枝">α-β剪枝</h4><ul class="lvl-0"><li class="lvl-2"><p>player结点：更新<code>alpha = max(alpha, temp_score);</code>如果发现alpha超过了父opponent结点已知的分分数上界beta,由于opponent一定不会选择下这一步,故放弃搜索</p></li><li class="lvl-2"><p>opponent结点：更新<code>beta = min(beta, temp_score);</code>如果发现beta小于了父player结点已知的分分数下界alpha,由于player一定不会选择下这一步,故放弃搜索</p></li></ul><h4 id="形势判断">形势判断</h4><ul class="lvl-0"><li class="lvl-2"><p>最naive的版本是，遍历每一个空点，计算这个点八个方向能够连成的最大长度。給（1，2，3，4）分别一个分数例如（1，10，100，1000）最终这个点的得分是player的长度分-opponent的长度分。整个盘面的形势分就是所有点的得分之和。</p></li><li class="lvl-2"><p>这样可以简单地看到，如果对手有更多马上能够连成4个的点，那么局面对我不利，否则对我有利。</p></li><li class="lvl-2"><p>这样的形势判断大概能获得50+%的得分</p></li></ul><h4 id="补丁">补丁</h4><p>如果发现自己能连成4个子，则直接落子。</p><p>接下来，如果发现对手能连成四个子，则堵住。</p><h2 id="创新部分">创新部分</h2><p>本次实验完全自己完成，所以尝试了各种正常的不正常的创新方法提升我的胜率。</p><p>但是对于α-β剪枝来说，若想提升胜率，我尝试引入一些专家知识，所以我学习了四子棋的一些基本下法</p><h3 id="四子棋小知识">四子棋小知识</h3><ul class="lvl-0"><li class="lvl-2"><p>迫手：类似于五子棋连成4个子，如果四子棋下一步可以连成四个子，则称形成了迫手（逼迫对手一定要走这里）</p><ul class="lvl-2"><li class="lvl-4">无效迫手：如果有player在棋盘较底部形成迫手，则其上的opponent迫手实际上是无效迫手，因为opponent若想获得迫手，必须要填满其下的格子，但是player已经获胜了</li><li class="lvl-4">双迫手，如果player形成双迫手，则opponent无论堵哪个，都可以获胜。</li></ul></li><li class="lvl-2"><p>劣招：容易发现，如果ai实力相当的话，实际上最后胜利总是有一方下满棋盘所有可能的位置后，不得不走在敌方迫手的下一格，导致对手下到自己的迫手而获胜。我们把这种被迫失败的招数称为劣招</p><ul class="lvl-2"><li class="lvl-4"><p>安全运转：如果棋盘剩下的列剩下的格子均为偶数，则后手方可以通过<code>安全运转</code>的方式控制先手方只能获得奇数格.这是7-6棋盘四子棋先手必胜的重要原因</p></li><li class="lvl-4"><p>奇偶迫手:根据上面的内容可以简单地推出下面的结论,如果局面仅剩的最后两列，白棋和黑棋在分别在不同列有且仅有一个迫手，且不会形成更多的迫手。<br>1、白奇黑偶，那么白胜。<br>2、白偶黑偶，那么黑胜。<br>3、白偶黑奇，那么平。<br>4、白奇黑奇，那么平。</p><p>其中黑棋表示后手方.奇/偶表示在某一列的从下往上数的奇/偶行存在迫手</p></li></ul></li><li class="lvl-2"><p>追胜:这里引入五子棋的概念.可以通过一系列的迫手,让对手不停被迫落子,直到自己获得双迫手,或者对手被迫落子后自己连成四子.</p></li></ul><p>学习过上面的四子棋小知识后引入我的创新尝试.</p><h3 id="计算-可能的-长度">计算(可能的)长度</h3><ul class="lvl-0"><li class="lvl-2"><p>希望如果这个点和周围自己的棋子之间即使有空位,比如[黑][白][-][+][白][黑] 这时[+]应该记为3而不是2</p></li><li class="lvl-2"><p>希望给出可能的长度,如果某一方向不可能形成4个字,返回-1比如[黑][白][+][白][黑] [+]不可能横向成4子横向长度记为-1</p></li><li class="lvl-2"><p>实现方案:</p><ul class="lvl-2"><li class="lvl-4">采取窗口滑动来计算某一点的大小,用一个长度为4的窗口在包含[+]的四个方向滑动,如果中间有禁入点或者对手棋子,则这个窗口长度记为0,最后找到含有最多本方棋子的窗口.</li></ul></li></ul><h3 id="新的形势判断函数">新的形势判断函数</h3><ul class="lvl-0"><li class="lvl-2"><p>naive的修改:不再对全局的点进行判断,而只是选择那些对局面有影响的点.具体来说只判断该点下面三个位置有棋子的点(只是为了减小计算量)</p></li><li class="lvl-2"><p>如果这个局面轮到某一player,且这个player可以连成4个,则返回无限大<code>INT-MAX</code>或者<code>intmin</code>,这方便剪枝,并且是合理的,因为无论能形成多少迫手,价值都不会比取得胜利大.</p></li><li class="lvl-2"><p>无效迫手:考虑到四子棋小知识中的无效迫手环节.如果棋盘底部有player的迫手,则迫手上方opponent的分数除以10(价值降低)</p></li></ul><h3 id="新的问题">新的问题</h3><ol><li class="lvl-3"><p>不知道双迫手,常常被对手形成两个迫手而输掉</p></li><li class="lvl-3"><p>赢了开浪,判断自己要获胜后(得分为’INT-max’)不会选择最简明的取胜方法,而是认为自己下哪里都能赢.可是由于我不能保证我的算法永远work,常常浪输比赛</p></li><li class="lvl-3"><p>输了开摆,当判断自己无论走哪里都会输时(无论走哪里得分都是<code>int-min</code>),不会挣扎</p></li></ol><p>因此我引入了更多专家知识,比如<strong>追胜</strong></p><p>如果我落子时,判断对方可以通过追胜的方法取得胜利,则禁止下到这一点.</p><p>如果我落子时,发现自己可以通过追胜取得胜利,则直接追胜.</p><h3 id="追胜的实现">追胜的实现</h3><p>简单来说就是递归地模拟落子</p><ol><li class="lvl-3"><p>遍历棋盘上所有可能的落子点</p></li><li class="lvl-3"><p>如果可以取得胜利，返回<code>胜利</code></p></li><li class="lvl-3"><p>否则如果可以形成迫手,则落子</p><ul class="lvl-2"><li class="lvl-5">如果对手能直接取得胜利,不考虑这个落子点</li><li class="lvl-5">否则对手必然要堵住我的迫手,继续模拟落子,直到胜利/不能形成新的迫手</li></ul></li></ol><p>上面的过程看似会递归爆炸,其实几乎是<strong>一本道</strong>(棋类术语,大意为只能这么下)的,所以实际上开销很低</p><p>对于追胜来说还有更多的边界条件,写在我的代码注释里.</p><p>在每次模拟落子时，首先检测自己是否能够追胜，这样大大提高了剪枝效率</p><p>经过实验我发现,仅仅使用追胜判断+形势判断(如果能追胜就追胜,如果对手追胜则禁止,其余情况下使得自己局面分数最高的点)已经可以实现<strong>70%的胜率</strong></p><h3 id="补丁-2">补丁</h3><p>对于输了开摆,我采取的方式是,降低搜索深度,选择比较低深度下最佳的点,这样ai不知道自己要输,就会认真下.</p><p>如果还是输,则继续降低深度,</p><p>(如果看一眼就知道走哪都要输了,那就开摆吧…随机下一个)</p><h3 id="时间控制">时间控制</h3><p>首版本的α-β剪枝用时几乎都在500ms以内，虽然能够达到90%左右胜率，但是我难以控制搜索深度，深度为6（每人走三步）.时经常超时,深度为5,则用时太少,而且由于我使用了递归,棋盘大小对我用时的影响非常大</p><p>所以最终采取的方案是,初始深度限制为7(一个较大的数)如果到了50%的time-limit,则深度限制减一,80%的limit,继续减一.95%的limit,不再继续搜索,直接返回形势判断值.</p><p>但是这样其实也有问题,就是前面几列搜索深度较深,后面较浅,不平衡.</p><p>开局落子可能性多,中局落子可能性少,因而每步用时基本是下降趋势,但有时中局的决策更加重要</p><h3 id="内存控制">内存控制</h3><p>我的算法根本不需要额外内存开销（完全是在同一个棋盘上模拟），所以根本不需要控制内存。感觉很吃亏，但也没有想到好方法用上内存</p><h2 id="致谢与实验感想">致谢与实验感想</h2><p>本次实验代码完全是自己完成，没有参考任何往年代码。</p><p>四子棋的知识来源于百度贴吧的分享<a href="https://tieba.baidu.com/p/4941848759">【图片】屏风式四子棋获胜诀窍（先手必胜？）！【新棋吧】_百度贴吧 (baidu.com)</a></p><ul class="lvl-0"><li class="lvl-2"><p>算法实际上有相当多的妥协,如果在每一步想要更多精度,就会损失搜索深度</p></li><li class="lvl-2"><p>我本来想引入更多专家知识,但是胜率越来越低.一方面我不能保证我的代码正确性,另一方面如果我已经下不过ai,我教他下棋只会越教越菜.</p></li><li class="lvl-2"><p>但是蒙特卡洛根本没这么多事情,它不需要形势判断,而且可以控制计算时间.我真的后悔为什么要写α-β剪枝(为什么要推荐我写)</p></li><li class="lvl-2"><p>我认为本实验最大的创新点是引入了追胜的概念，它确实有效，但是耗费了我大量时间考虑边界条件和debug。最终版本的追胜算法实际上是在我改了很多版之后改回了较为原始的版本。一方面，胜利的判断是很难的，比如加入认为自己一列上有连续两个迫手则宣称获胜，很可能对手在另一列通过追胜直接获胜；另一方面，追胜导致了更为激进的剪枝，这很容易使得ai对形势出现误判；再者，认为自己获胜或失败非常容易导致<code>赢了开浪,输了开摆</code>的结果,所以最终我限制了追胜的搜索深度.</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
          <category> iAi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iAi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>deadlines</title>
      <link href="/homework/deadlines/"/>
      <url>/homework/deadlines/</url>
      
        <content type="html"><![CDATA[<blockquote><p>日拱一卒未有尽，​      功不唐捐终到海。</p></blockquote><details> <summary><b>图例</summary><div class="danger"><p>时间紧，任务重，I’m f**ked up</p></div><div class="warning"><p>时间不多了,under pressure</p></div><div class="tips"><p>时间还早,totally under control</p></div><div class="success"><p>写完了😄</p></div></details><h2 id="发现红框没有被check，可以来压力我😄">发现红框没有被check，可以来压力我😄</h2><details open><summary><span class="pre-summary">&nbsp;</span>点击折叠</summary><div class="danger"><ul class="lvl-2"><li class="lvl-2"><p><input type="checkbox" id="checkbox15"><label for="checkbox15">毛概案例分析 十二周周日 </label><mark>周末再说吧</mark></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox16"><label for="checkbox16">第12周DLCE</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox17"><label for="checkbox17">数电12周作业</label></p></li></ul></div></details><hr><details open><summary><span class="pre-summary">&nbsp;</span>点击折叠</summary><div class="warning"><ul class="lvl-2"><li class="lvl-2"><p><input type="checkbox" id="checkbox18"><label for="checkbox18">网原大作业(联机实验部分)</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox19"><label for="checkbox19">计图pa3</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox20" checked="true"><label for="checkbox20">网原实验3</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox21" checked="true"><label for="checkbox21">数电实验报告</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox22" checked="true"><label for="checkbox22">数电作业</label></p></li></ul></div></details><hr><details open><summary><span class="pre-summary">&nbsp;</span>点击折叠</summary><div class="tips"><ul class="lvl-2"><li class="lvl-2"><p><input type="checkbox" id="checkbox23"><label for="checkbox23">习概作业 17周周日</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox24"><label for="checkbox24">计图大作业</label></p></li></ul></div></details><details open><summary><span class="pre-summary">&nbsp;</span>点击折叠</summary><div class="success"><ul class="lvl-2"><li class="lvl-2"><p><input type="checkbox" id="checkbox25" checked="true"><label for="checkbox25">希腊语第三次作业</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox26" checked="true"><label for="checkbox26">计图pa2</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox27" checked="true"><label for="checkbox27">人智导第二次作业</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox28" checked="true"><label for="checkbox28">网原第九次作业</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox29" checked="true"><label for="checkbox29">网原第十次作业</label></p></li><li class="lvl-2"><p><input type="checkbox" id="checkbox30" checked="true"><label for="checkbox30">概统第十次作业</label></p></li><li class="lvl-2"><p>[ ]</p></li></ul></div></details>]]></content>
      
      
      <categories>
          
          <category> homework </category>
          
      </categories>
      
      
        <tags>
            
            <tag> homework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/others/chart/"/>
      <url>/others/chart/</url>
      
        <content type="html"><![CDATA[import * as echarts from "echarts";// 基于准备好的dom，初始化echarts实例var myChart = echarts.init(document.getElementById("main"));// 绘制图表myChart.setOption({  title: {    text: "ECharts 入门示例",  },  tooltip: {},  xAxis: {    data: ["衬衫", "羊毛衫", "雪纺衫", "裤子", "高跟鞋", "袜子"],  },  yAxis: {},  series: [    {      name: "销量",      type: "bar",      data: [5, 20, 36, 10, 10, 20],    },  ],});]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>tips</title>
      <link href="/others/tips/"/>
      <url>/others/tips/</url>
      
        <content type="html"><![CDATA[<h2 id="终端设置代理">终端设置代理</h2><p>要永久设置HTTP代理和HTTPS代理，可以将这些命令添加到PowerShell的配置文件中。</p><p>以下是在PowerShell中设置永久HTTP代理和HTTPS代理的步骤：</p><ol><li class="lvl-3"><p>打开PowerShell命令提示符，输入以下命令：<code>notepad $PROFILE</code></p></li><li class="lvl-3"><p>在打开的文件中，添加以下两行命令：</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$Env:http_proxy=&quot;http://127.0.0.1:&lt;你的代理端口&gt;&quot;</span><br><span class="line">$Env:https_proxy=&quot;http://127.0.0.1:&lt;你的代理端口&gt;&quot;</span><br></pre></td></tr></table></figure><ol start="3"><li class="lvl-3"><p>保存并关闭文件。</p></li></ol><p>现在，每次打开新的PowerShell窗口时，都会自动加载此配置文件，并在环境变量中设置HTTP代理和HTTPS代理。</p><p>请注意，如果您使用的是PowerShell Core，配置文件的位置可能不同，并且可能需要使用其他命令来编辑它。</p><h2 id="网关代理模式">网关代理模式</h2><p>当涉及到网络通信和数据交换时，网关代理模式（Gateway Proxy Mode）是一种常见的架构模式。在这种模式下，网关作为客户端和服务器之间的中间代理，处理客户端的请求并转发给服务器，同时接收服务器的响应并返回给客户端。这种模式在网络安全、负载均衡和数据转换等方面具有重要作用。</p><div class="tips"><p>在计算机网络中，网关（Gateway）是连接不同网络之间的节点或设备。它充当了网络之间的中继站点，用于转发数据包和信息。网关可以是硬件设备（如路由器）或软件实体（如计算机上的网络接口）。</p></div><p>以下是网关代理模式的一般工作流程：</p><ol><li class="lvl-3"><p>客户端发送请求：客户端向网关发送请求，将其视为目标服务器。</p></li><li class="lvl-3"><p>网关接收请求：网关接收到客户端的请求，并代表客户端向服务器发送请求。</p></li><li class="lvl-3"><p>请求转发：网关将请求转发给目标服务器，可以根据特定的规则或策略来选择目标服务器。这个过程通常涉及路由选择和数据包转发。</p></li><li class="lvl-3"><p>目标服务器处理请求：目标服务器接收到网关发送的请求，并处理请求。</p></li><li class="lvl-3"><p>响应返回：目标服务器生成响应，并将其发送回网关。</p></li><li class="lvl-3"><p>网关接收响应：网关接收到来自目标服务器的响应。</p></li><li class="lvl-3"><p>响应传递给客户端：网关将响应传递给客户端，客户端认为响应是直接来自服务器的。</p></li></ol><pre class="mermaid">graph TD    A[互联网] --> B[路由器]    B --> C[手机]    B --> D[电脑]    B --> E[VR头显]    B --> F[NS]    B --> G[iPad]</pre><h4 id="举个简单的例子">举个简单的例子</h4><p>上图中，电脑访问互联网的路径是电脑–&gt;路由器–&gt;互联网</p><pre class="mermaid">graph TD    A[互联网] --> B[路由器]    B --> C[手机]    B --> D[电脑]    B --> E[VR头显]    B --> F[NS]    B --> G[iPad]    D -.-> |req|B    B -.->|req|A</pre><p>而当手机开启代理,可以将这个路径改变为电脑–&gt;手机–&gt;路由器–&gt;互联网.</p><pre class="mermaid">graph TD    A[互联网] --> B[路由器]    B --> C[手机]    subgraph 局域网设备    D -.-> C    E -.-> C    F -.-> C    G -.-> C    end    C -.-> B    B -.-> A    D[电脑]    E[VR头显]    F[NS]    G[iPad]</pre><p>这样把开启了代理的手机作为电脑的网关,也代理了电脑的请求.</p><blockquote><p>为什么这样设置后ping 不到Google?</p></blockquote><p>当你使用类似 Clash 的代理工具时，它通常是在<strong>应用层</strong>工作，并且只有经过代理工具指定的端口或代理规则的流量才会被代理。像 ping 等工具运行的网络流量通常是在操作系统的<strong>网络层</strong>处理，而不会经过应用层代理。</p><p>这些代理工具一般通过<strong>配置代理规则或端口</strong>来确定哪些流量需要经过代理。当你在代理工具中配置了代理规则或指定了特定的代理端口，只有匹配这些规则或端口的流量才会被发送到代理工具，并由代理工具进行转发。</p><p>其他未匹配代理规则或端口的流量将绕过代理工具，直接通过正常的网络路径发送。这意味着只有符合代理规则的流量才会被真正代理。</p><p>这种应用层代理的方式通常用于代理特定的应用程序流量，而不是整个系统的网络流量。通过配置代理规则或端口，你可以选择性地将特定应用程序的流量经过代理，以实现隐私保护、访问控制或其他需求。</p><p>总而言之,能用就行…</p>]]></content>
      
      
      <categories>
          
          <category> tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>network-E4</title>
      <link href="/homework/network/network-E4/"/>
      <url>/homework/network/network-E4/</url>
      
        <content type="html"><![CDATA[<h1>网原第三次小实验</h1><p>郭高旭 2021010803 <a href="mailto:ggx21@mails.tsinghua.edu.cn">ggx21@mails.tsinghua.edu.cn</a></p><h2 id="抓包实验-1：">抓包实验 1：</h2><h3 id="1-UDP-数据包在-IP-层的类型编号是17">1.UDP 数据包在 IP 层的类型编号是17</h3><p><img src="/img/network-E4.assets/image-20230522233420722.png" alt="image-20230522233420722"></p><h3 id="2-UDP-数据包头字段依次是">2.UDP 数据包头字段依次是</h3><p><img src="/img/network-E4.assets/image-20230522233509382.png" alt="image-20230522233509382"></p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span>                   <span class="number">1</span>                   <span class="number">2</span>                   <span class="number">3</span></span><br><span class="line"> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="operator">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="operator">|</span>          <span class="variable">Source</span> <span class="variable">Port</span>          <span class="operator">|</span>       <span class="variable">Destination</span> <span class="variable">Port</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="operator">|</span>            <span class="built_in">Length</span>             <span class="operator">|</span>           <span class="variable">Checksum</span>            <span class="operator">|</span></span><br><span class="line"><span class="operator">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="operator">|</span>                             <span class="variable">Data</span>                              <span class="operator">|</span></span><br><span class="line"><span class="operator">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br></pre></td></tr></table></figure><p>源端口号(16bit)，目的端口号(16bit)， UDP 包总长(16bit)，校验和(16bit)</p><h2 id="抓包实验2：">抓包实验2：</h2><h3 id="1-TCP-数据包在-IP-层的类型编号是-6">1.TCP 数据包在 IP 层的类型编号是  6</h3><p><img src="/img/network-E4.assets/image-20230522234307449.png" alt="image-20230522234307449"></p><h3 id="2-TCP-数据包头字段依次是？">2. TCP 数据包头字段依次是？</h3><p><img src="/img/network-E4.assets/image-20230522234759931.png" alt="image-20230522234759931"></p><p>源端口号(16bit)，目的端口号(16bit)，报文序列号(32bit)，报文确认序列号(32bit)，包头长度(4bit)，保留位和标记位(12bit)，窗口大小(16bit)，校验和(16bit)，紧急指针(16bit)，选项</p><h4 id="以下是一个使用RFC标准格式的TCP头的示例代码块：">以下是一个使用RFC标准格式的TCP头的示例代码块：</h4><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span>                   <span class="number">1</span>                   <span class="number">2</span>                   <span class="number">3</span></span><br><span class="line"> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="operator">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="operator">|</span>          <span class="variable">Source</span> <span class="variable">Port</span>          <span class="operator">|</span>       <span class="variable">Destination</span> <span class="variable">Port</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="operator">|</span>                        <span class="built_in">Sequence</span> <span class="built_in">Number</span>                        <span class="operator">|</span></span><br><span class="line"><span class="operator">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="operator">|</span>                    <span class="variable">Acknowledgment</span> <span class="built_in">Number</span>                      <span class="operator">|</span></span><br><span class="line"><span class="operator">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="operator">|</span>  <span class="variable">Data</span> <span class="operator">|</span>           <span class="operator">|</span><span class="variable">U</span><span class="operator">|</span><span class="variable">A</span><span class="operator">|</span><span class="variable">P</span><span class="operator">|</span><span class="variable">R</span><span class="operator">|</span><span class="variable">S</span><span class="operator">|</span><span class="variable">F</span><span class="operator">|</span>                               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="built_in">Offset</span><span class="operator">|</span> <span class="variable">Reserved</span>  <span class="operator">|</span><span class="variable">R</span><span class="operator">|</span><span class="built_in">C</span><span class="operator">|</span><span class="variable">S</span><span class="operator">|</span><span class="variable">S</span><span class="operator">|</span><span class="variable">Y</span><span class="operator">|</span><span class="built_in">I</span><span class="operator">|</span>            <span class="variable">Window</span>             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="operator">|</span>           <span class="operator">|</span><span class="variable">G</span><span class="operator">|</span><span class="built_in">K</span><span class="operator">|</span><span class="variable">H</span><span class="operator">|</span><span class="variable">T</span><span class="operator">|</span><span class="built_in">N</span><span class="operator">|</span><span class="built_in">N</span><span class="operator">|</span>                               <span class="operator">|</span></span><br><span class="line"><span class="operator">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="operator">|</span>           <span class="variable">Checksum</span>            <span class="operator">|</span>         <span class="variable">Urgent</span> <span class="variable">Pointer</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="operator">|</span>                    <span class="built_in">Options</span>                    <span class="operator">|</span>    <span class="built_in">Padding</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br></pre></td></tr></table></figure><p>在上述代码块中，我们可以看到TCP头的结构，具体字段如下：</p><ul class="lvl-0"><li class="lvl-2"><p>Source Port：16位字段，表示源端口号，标识发送方的应用程序或进程。</p></li><li class="lvl-2"><p>Destination Port：16位字段，表示目标端口号，标识接收方的应用程序或进程。</p></li><li class="lvl-2"><p>Sequence Number：32位字段，用于对TCP数据流中的字节进行编号，用于排序和重组数据。</p></li><li class="lvl-2"><p>Acknowledgment Number：32位字段，表示期望接收方接收到的下一个字节的编号。用于确认已经成功接收到的数据。</p></li><li class="lvl-2"><p>Data Offset：4位字段，表示TCP头的长度，以32位字（4字节）为单位。</p></li><li class="lvl-2"><p>Reserved：6位字段，保留位，未使用，必须为0。</p></li><li class="lvl-2"><p>Control Flags：6位字段，包括URG（紧急数据标志）、ACK（确认标志）、PSH（推送标志）、RST（重置标志）、SYN（同步标志）和FIN（结束标志）。</p></li><li class="lvl-2"><p>Window：16位字段，表示接收窗口大小，用于流量控制。</p></li><li class="lvl-2"><p>Checksum：16位字段，用于校验TCP头和数据的完整性。校验和的计算涉及TCP头、TCP数据以及伪首部的部分。</p></li><li class="lvl-2"><p>Urgent Pointer：16位字段，指示紧急数据的位置，仅在URG标志被设置时有效。</p></li><li class="lvl-2"><p>Options：可变长度字段，用于携带可选的TCP选项，如最大段大小（MSS）、窗口扩大因子等。</p></li><li class="lvl-2"><p>Padding：可变长度字段，用于填充，以保证TCP头长度是32位字的倍数。</p></li></ul><h3 id="3-TCP-三次握手过程使用三个数据包">3.TCP 三次握手过程使用三个数据包</h3><p><img src="/img/network-E4.assets/image-20230522235654303.png" alt="image-20230522235654303"></p><p>第一次(A-&gt;B,SYN,SEQ=X,ACK=0)  此处X=0</p><p><img src="/img/network-E4.assets/image-20230522235805183.png" alt="image-20230522235805183"></p><p>第二次 (B-&gt;A,SYN||ACK,SEQ=Y,ACK=X+1)  这里Y=0，X=0</p><p><img src="/img/network-E4.assets/image-20230522235908626.png" alt="image-20230522235908626"></p><p>第三次(A-&gt;B,ACK,SEQ=X+1,ACK=Y+1)  这里Y=0，X=0</p><p><img src="/img/network-E4.assets/image-20230523000024878.png" alt="image-20230523000024878"></p><p>协商options：Maximum segement size等等</p><h3 id="4-序列号增长和包长关系是什么？">4.序列号增长和包长关系是什么？</h3><p><img src="/img/network-E4.assets/image-20230523000445206.png" alt="image-20230523000445206"></p><p>由图可知，next sequence number = sequence number + TCP segment len\TCP 序列号的增长差值与前一个包的 TCP 段长度(TCP 数据字段)相等；</p><p><img src="/img/network-E4.assets/image-20230523000720575.png" alt="image-20230523000720575"></p><p>观察这组数据与对应确认包，数据包对应确认包中，确认序列号与(原包序列号+段长)相等</p><h2 id="简答">简答</h2><h3 id="1-TCP-选项还支持什么特殊的功能？">1.TCP 选项还支持什么特殊的功能？</h3><ol><li class="lvl-3"><p>窗口扩大（Window Scale）：允许发送方和接收方扩大TCP窗口的大小，以适应更高的带宽延迟乘积（BDP）和更大的网络拥塞窗口。</p></li><li class="lvl-3"><p>时间戳（Timestamps）：用于测量和估计网络往返时间（RTT），从而改善拥塞控制算法的性能和精度。</p></li><li class="lvl-3"><p>选择确认（Selective Acknowledgment，SACK）：允许接收方向发送方报告丢失和乱序的数据段的具体位置，以便发送方只重传丢失的数据段，而不是整个窗口的数据。</p></li><li class="lvl-3"><p>最大报文段长度（Maximum Segment Size，MSS）：用于协商TCP报文段的最大有效载荷大小，以便在网络中避免分片和重组。</p></li><li class="lvl-3"><p>无延迟确认（No Delayed Acknowledgment）：用于在接收方立即发送确认，而不等待延迟确认定时器的到期。</p></li><li class="lvl-3"><p>紧急数据指针（Urgent Pointer）：用于指示TCP报文段中的紧急数据的起始位置，以便在应用层处理紧急数据。</p></li></ol><h3 id="什么此反射-DoS-攻击大多使用基于-UDP-的公共-服务，而不是基于-TCP-呢">什么此反射 DoS 攻击大多使用基于 UDP 的公共 服务，而不是基于 TCP 呢</h3><ul class="lvl-0"><li class="lvl-2"><p>**UDP 协议是无连接的，不需要握手过程，也不验证源 IP 地址，因此更容易进行 IP 欺骗。**TCP 协议则需要三次握手才能建立连接，如果源 IP 地址被伪造，攻击者无法收到目标服务器的 SYN-ACK 包，也就无法完成连接。</p></li><li class="lvl-2"><p>**UDP 协议有一些服务可以产生放大效应，即请求包的大小远小于响应包的大小，从而增加攻击的效力。**例如，NTP、DNS、SSDP、Memcached 等服务都可以被用作放大器，将请求包的大小放大数十倍甚至数百倍。TCP 协议则没有这样的放大效应，因为它有拥塞控制和流量控制机制，会根据网络状况和接收方能力调整发送速率和窗口大小。</p></li><li class="lvl-2"><p>**UDP 协议有更多的公共服务可以被利用，而且这些服务往往没有安全配置或认证机制。**互联网上存在大量的开放的 UDP 服务，如 NTP、DNS、SSDP、Memcached 等，这些服务通常会响应所有 IP 的请求，而不进行任何过滤或限制。TCP 协议则有较少的公共服务可以被利用，而且这些服务往往有更好的安全配置或认证机制，如 HTTP、SMTP、FTP 等。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> homework </category>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> homework </tag>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>network-homework-12</title>
      <link href="/homework/network/network12/"/>
      <url>/homework/network/network12/</url>
      
        <content type="html"><![CDATA[<h1>网原第12次作业</h1><p>郭高旭 2021010803 <a href="mailto:ggx21@mails.tsinghua.edu.cn">ggx21@mails.tsinghua.edu.cn</a></p><h2 id="第一题">第一题</h2><blockquote><p>Tahoe,Reno,Cubic等拥塞控制协议均基于丢包信号调整发送速度,基于丢包判断链路拥塞有什么缺点</p></blockquote><ol><li class="lvl-3"><p>延迟反应：基于丢包的拥塞控制算法在判断链路拥塞时需要等待丢包事件的发生，然后才能采取相应的措施。这意味着它们的反应时间相对较慢。</p></li><li class="lvl-3"><p>误判和误解退：基于丢包的拥塞控制算法可能会误判某些丢包事件。丢包并不总是意味着链路发生了拥塞。例如，丢包可能是由于网络噪声、传输错误或临时网络抖动等原因引起的。</p></li><li class="lvl-3"><p>面临丢包恢复问题：基于丢包判断链路拥塞的算法通常采用的策略是减小发送速度以降低拥塞，即减小拥塞窗口（CWND）。然而，一旦发生丢包，发送方会降低发送速率，这可能导致网络带宽未被充分利用。</p></li></ol><blockquote><p>BBR忽略丢包信号，但主动探测什么其他指标来判断链路状态</p></blockquote><p>瓶颈带宽与时延</p><h2 id="第二题">第二题</h2><ol><li class="lvl-3"><p>TCP多流复用加剧了队头阻塞,QUIC建立相互独立的多个子流,一个子流数据包丢失不影响其他子流</p></li><li class="lvl-3"><p>TCP的重传包使用和原包相同的序号,返回的ACK不能确定是对原包还是重传包,导致RTT计算错误.</p><p>QUIC的packet number单调递增，对于重传包也会递增packet number， 避免RTO</p></li><li class="lvl-3"><p>TCP基于ip:端口,QUIC基于connection id,支持ip/端口切换</p></li><li class="lvl-3"><p>整个QUIC包被加密传输</p></li></ol><h2 id="第三题">第三题</h2><ol><li class="lvl-3"><p>多径带宽聚合  可以利用设备的多个网口实现多路径传输,带来更好的带宽与吞吐量</p></li><li class="lvl-3"><p>负载均衡：MPTCP可以将数据流分散到多个路径上，实现负载均衡。它可以动态选择和调整数据传输路径，根据路径的质量和拥塞情况来决定发送数据的路径，从而均衡地利用可用的网络资源。</p></li><li class="lvl-3"><p>更加可靠,一条路径故障可以在其他路径上继续传输数据</p></li><li class="lvl-3"><p>将属于同一个数据流的数据包调度到不同的路径上传输.,降低数据乱序到达对网络性能产生的不利影响</p></li><li class="lvl-3"><p>支持链路的平滑切换,多路径传输方式允许终端在不同接入网络间快速、平滑地切换 选取链路质量最好的路径传输数据</p></li></ol><h2 id="第四题">第四题:</h2><p>小流关心延迟,大流关心带宽.</p><p>根据拥塞程度精细调整发送窗口</p><p>DCTCP: 𝑐𝑤𝑛𝑑 ← 𝑐𝑤𝑛𝑑 × (1 - 𝛼/2),  𝛼: 使用显示拥塞信号得到的“拥塞程度”</p><p>DCTCP通过交换机标记超出阈值的流量ACK来控制发送端的发送速率，进而保证了接收端队列维持在较短的长度，使得小流有较低的延迟，同时大流仍保持较⾼的带宽</p>]]></content>
      
      
      <categories>
          
          <category> homework </category>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> homework </tag>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新的一天</title>
      <link href="/Somniloquy/dream-7/"/>
      <url>/Somniloquy/dream-7/</url>
      
        <content type="html"><![CDATA[<h2 id="24：09">24：09</h2><p>又是一周这样错过，不知道说什么好。给你放首歌听吧。</p>        <div id="aplayer-cWKcxgdK" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-cWKcxgdK"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "蠢货",              author: "小霞",              url: "/music/蠢货/蠢货.mp3",              pic: "/music/蠢货/蠢货.webp",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><h2 id="2023-5-19">2023/5/19</h2><h3 id="23-12">23:12</h3><p>一直觉着自己是个幸运的小孩。</p><p>明明有很多事情是自己不能决定的，但往往都能有个不错的结局。</p><p>就比如：</p><img src="/img/dream-7.assets/dcbc3ab12c8718d42bca5bc03e6f6db.png" alt="dcbc3ab12c8718d42bca5bc03e6f6db" style="zoom: 33%;" /><p>遇到的人都对我很好。</p><p>许下的愿望莫名都能完成。</p><p>即使是犯过的错也往往有补救的余地。</p><p>有什么事情能让我伤心？</p><p>那些人和事是我直面生活的力量来源。</p>        <div id="aplayer-EvRjZvRi" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-EvRjZvRi"),            narrow: false,            autoplay: true,            showlrc: false,            music: {              title: "完美生活",              author: "许巍",              url: "/music/完美生活/完美生活.mp3",              pic: "/music/完美生活/完美生活.webp",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><blockquote><p>靠，我的freemp3网站寄了，暂时拿网易云的外链播放器顶上了</p></blockquote><blockquote><p>现在改了.</p></blockquote><blockquote><p>但其实原来我想放《旅行》的</p></blockquote><blockquote><p>是谁来自山川湖海，囿于什么什么与爱？困在五道口。。怎么走都出不去。</p></blockquote><p>今天北京下了大雨，天地一片乌蒙蒙，六教楼下的杂草长势甚是喜人。吃完饭和松子在操场，get到了散步的点？大概没有。</p><img src="/img/dream-7.assets/7e9c0d3707380ddd6c96420b163df74.jpg" alt="7e9c0d3707380ddd6c96420b163df74" style="zoom:33%;" /><p>不过还是抽了些纪念品回去，开心。</p><p>今天很开心。</p><p>翰元问我要班级同学姓名照片对照表，不错，狠狠社交。</p><p>怎么又有情感故事，真的腻了。</p><p>哎呀，感觉人一开心，长得都会更好看</p>]]></content>
      
      
      <categories>
          
          <category> Somniloquy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> THU </tag>
            
            <tag> Somniloquy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>network-homework-11</title>
      <link href="/homework/network/network11/"/>
      <url>/homework/network/network11/</url>
      
        <content type="html"><![CDATA[<h1>网原第11次作业</h1><p>郭高旭 2021010803 <a href="mailto:ggx21@mails.tsinghua.edu.cn">ggx21@mails.tsinghua.edu.cn</a></p><h2 id="第一题">第一题</h2><blockquote><p>为什么要发明一个新的抽象ID(端口号),而不用进程ID?</p></blockquote><h5 id="答">答:</h5><ol><li class="lvl-3"><p>传输层不需要知道进程ID，只需要知道它的目的与源端口。端口与进程的转换发生在终端系统内部。</p></li><li class="lvl-3"><p>传输层如果使用进程ID，需要维护一个端口到进程的关系表，这样增大了网络的开销</p></li><li class="lvl-3"><p>进程可能使用多个端口</p></li></ol><h2 id="第二题">第二题</h2><blockquote><p>数据报的分段和重组机制由IP层来处理，对于TCP不可见。试问,这是否意味着TCP不用担心数据错序到达的问题</p></blockquote><p>答:不是</p><ol><li class="lvl-3"><p>数据报的分段和重组机制由IP层来处理，ip层只是保证了数据报的完整性，</p></li><li class="lvl-3"><p>TCP协议会通过TCP头的序号接收端进行有序地重组</p></li><li class="lvl-3"><p>TCP协议还会使用校验和机制来检测丢弃、重传不正确的数据报，</p></li></ol><h2 id="第三题">第三题</h2><blockquote><p><img src="/img/network11.assets/image-20230512115040962.png" alt="image-20230512115040962"></p></blockquote><ol><li class="lvl-3"><p>ABCDE同时增加，4线路到达瓶颈，BCD停止增长</p></li><li class="lvl-3"><p>A，B继续增长直到1到达瓶颈</p></li><li class="lvl-3"><p>变化：原有BCD流大小不变均为1/3，AE大小为1/2</p></li></ol><h2 id="第四题">第四题</h2><pre class="mermaid">sequenceDiagram    participant Client    participant ServerNote over Client: closedNote over Server: listen    Client->>Server: SYN = 1, Seq = X    Note over Client: syc-sent    Note over Server: syc-received    Server-->>Client: SYN = 1, ACK = 1, Seq = Y, Ack = X+1Note over Server: established    Client->>Server: ACK = 1, Seq = X+1, Ack = Y+1Note over Client: established    Note over Client, Server: 握手完成</pre><ol><li class="lvl-3"><p>listen-&gt;syc-received-&gt;established</p></li><li class="lvl-3"><p>closed-&gt;syc-sent-&gt;established</p></li><li class="lvl-3"><p>(1)SYN(3)SYN+ACK</p></li><li class="lvl-3"><p>665,234</p></li></ol><h3 id="5">5.</h3><h5 id="AIAD">AIAD</h5><img src="/img/network11.assets/image-20230522214940743.png" alt="image-20230522214940743" style="zoom:33%;" /><p>由于等速率加减,只是在某一条斜率为一的直线上来回震荡,不能到达最优(忽略左边垂直向下的线)</p><h5 id="MIMD">MIMD</h5><img src="/img/network11.assets/image-20230522215252248.png" alt="image-20230522215252248" style="zoom:50%;" /><p>是在某条斜率为k的直线上震动,也不能趋近最优</p><h5 id="MIAD">MIAD</h5><img src="/img/network11.assets/image-20230522215426392.png" alt="image-20230522215426392" style="zoom:50%;" /><p>如图所示,反而增大了不公平性</p><h3 id="6-C">6. C</h3><p>慢启动:每收到X字节,翻倍</p><p>拥塞避免:每收到X字节,+1</p>]]></content>
      
      
      <categories>
          
          <category> homework </category>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> homework </tag>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Somniloquy-6</title>
      <link href="/Somniloquy/dream-6/"/>
      <url>/Somniloquy/dream-6/</url>
      
        <content type="html"><![CDATA[<h2 id="20：09">20：09</h2><p>刚刚好一周没写了。果然日记迅速地变成了周记。</p><p>感觉问题在于操作太麻烦。。。</p><p>头痛欲裂了。</p><p>错过。错过。错过。</p>]]></content>
      
      
      <categories>
          
          <category> Somniloquy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> THU </tag>
            
            <tag> Somniloquy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>counter-mod60</title>
      <link href="/homework/DLCE/%E5%85%AD%E5%8D%81%E8%BF%9B%E5%88%B6%E8%AE%A1%E6%95%B0%E5%99%A8/"/>
      <url>/homework/DLCE/%E5%85%AD%E5%8D%81%E8%BF%9B%E5%88%B6%E8%AE%A1%E6%95%B0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1>60进制计数器</h1><p>郭高旭 <a href="mailto:ggx21@mails.tsinghua.edu.cn">ggx21@mails.tsinghua.edu.cn</a> 2021010803</p><h2 id="实验目的">实验目的</h2><ul class="lvl-0"><li class="lvl-2"><p>掌握组合逻辑电路的基本分析方法与设计方法；</p></li><li class="lvl-2"><p>理解触发器的分析与设计方法；</p></li><li class="lvl-2"><p>学会元件例化；</p></li><li class="lvl-2"><p>学会利用软件仿真实现对数字电路的验证与分析</p></li></ul><h2 id="实验内容">实验内容</h2><ul class="lvl-0"><li class="lvl-2"><p>设计D触发器</p></li><li class="lvl-2"><p>利用半加器构建60进制计数器</p></li></ul><h2 id="实验原理">实验原理</h2><h3 id="D触发器：">D触发器：</h3><p>输入：D, CP, Rd, Sd: in std_logic ;</p><p>输出：Q，nQ: out std_logic ；</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">architecture</span> arch <span class="keyword">of</span> DFF <span class="keyword">is</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"> <span class="keyword">process</span>(Rd, Sd, CP)</span><br><span class="line"> <span class="keyword">begin</span></span><br><span class="line"> <span class="keyword">if</span> (Rd = <span class="string">&#x27;0&#x27;</span>) <span class="keyword">then</span></span><br><span class="line">  Q &lt;= <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">  nQ &lt;= <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"> <span class="keyword">elsif</span> (Sd = <span class="string">&#x27;0&#x27;</span>) <span class="keyword">then</span></span><br><span class="line">  Q &lt;= <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">  nQ &lt;= <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"> <span class="keyword">elsif</span> (CP<span class="symbol">&#x27;event</span> <span class="keyword">and</span> CP = <span class="string">&#x27;1&#x27;</span>) <span class="keyword">then</span></span><br><span class="line">  Q &lt;= D;</span><br><span class="line">  nQ &lt;= <span class="keyword">not</span> D;</span><br><span class="line"> <span class="keyword">end</span> <span class="keyword">if</span> ;</span><br><span class="line"> <span class="keyword">end</span> <span class="keyword">process</span> ;</span><br><span class="line"><span class="keyword">end</span> arch;</span><br></pre></td></tr></table></figure><p>过程中的三个 if 语句用于控制 D 触发器的行为。当 Rd 信号为 ‘0’ 时，Q 和 nQ 都被强制为 ‘0’ 和 ‘1’。当 Sd 信号为 ‘0’ 时，Q 和 nQ 都被强制为 ‘1’ 和 ‘0’。当 CP 信号上升沿（在事件发生条件 CP’event and CP = ‘1’ 下）发生时，D 触发器接收 D 信号，Q 和 nQ 的值被更新。</p><h3 id="计数器：">计数器：</h3><p>基于上面构建的D触发器，可以构建六进制与十进制计数器，下面以六进制为例。</p><p>输入：clk, Rd, c0: in std_logic ;</p><p>输出：out_6: out std_logic_vector(3 downto 0)</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">architecture</span> click_6_bhv <span class="keyword">of</span> click_6 <span class="keyword">is</span></span><br><span class="line">  <span class="keyword">component</span> ourDFF <span class="keyword">is</span></span><br><span class="line"> <span class="keyword">port</span>(</span><br><span class="line"> D, CP, Rd, Sd: <span class="keyword">in</span> <span class="built_in">std_logic</span> ;</span><br><span class="line"> Q: <span class="keyword">out</span> <span class="built_in">std_logic</span> := <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"> nQ: <span class="keyword">out</span> <span class="built_in">std_logic</span> := <span class="string">&#x27;1&#x27;</span></span><br><span class="line"> );</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">component</span>;</span><br><span class="line">  <span class="keyword">signal</span> D, Q, nQ: <span class="built_in">std_logic_vector</span>(<span class="number">2</span> <span class="keyword">downto</span> <span class="number">0</span>);</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"> lb0: <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> <span class="keyword">to</span> <span class="number">2</span> <span class="keyword">generate</span></span><br><span class="line">Di: ourDFF <span class="keyword">port</span> <span class="keyword">map</span>(D(i), clk , Rd, <span class="string">&#x27;1&#x27;</span>, Q(i), nQ(i));</span><br><span class="line"> <span class="keyword">end</span> <span class="keyword">generate</span> lb0;</span><br><span class="line"> D(<span class="number">0</span>) &lt;= c0 <span class="keyword">xor</span> Q(<span class="number">0</span>);</span><br><span class="line"> D(<span class="number">1</span>) &lt;= ((<span class="keyword">not</span> c0) <span class="keyword">and</span> Q(<span class="number">1</span>)) <span class="keyword">or</span> (c0 <span class="keyword">and</span> (nQ(<span class="number">2</span>) <span class="keyword">and</span> (Q(<span class="number">1</span>) <span class="keyword">xor</span> Q(<span class="number">0</span>))));</span><br><span class="line"> D(<span class="number">2</span>) &lt;= ((<span class="keyword">not</span> c0) <span class="keyword">and</span> Q(<span class="number">2</span>)) <span class="keyword">or</span> (c0 <span class="keyword">and</span> ((Q(<span class="number">2</span>) <span class="keyword">and</span> nQ(<span class="number">0</span>)) <span class="keyword">or</span> (Q(<span class="number">1</span>) <span class="keyword">and</span> Q(<span class="number">0</span>))));</span><br><span class="line"> out_6(<span class="number">2</span> <span class="keyword">downto</span> <span class="number">0</span>) &lt;= Q;</span><br><span class="line"> out_6(<span class="number">3</span>) &lt;= <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">end</span> click_6_bhv;</span><br></pre></td></tr></table></figure><p>首先generate三个 D 触发器的实例，其端口分别是 D、CP、Rd、Sd、Q 和 nQ。其中，D、CP、Rd 和 Sd 分别表示 D 触发器的输入端口 D、时钟、异步清零和异步置位，分别连接的是计数器输入端口 c0、clk、Rd 和常量’1’。Q 和 nQ 分别表示 D 触发器的输出端口 Q 和 nQ，这两个端口被访问和修改的是一个 std_logic_vector 类型的信号 D，由该信号内的三个元素 D(2 downto 0) 分别连接这三个 D 触发器的输入端口 D。注意到 D 触发器的输出信号 Q(0) 、Q(1) 和 Q(2) 作为后续逻辑的信号。</p><p>在 process 外部，当 c0 在时钟信号时一次产生一个计数脉冲时，D 触发器的输入信号 D(0)、D(1) 和 D(2) 会被根据 c0、Q(0)、Q(1)、Q(2)、nQ(0)、nQ(1)、nQ(2) 计算得到对应的取值，分别站三个位置的权位。</p><p>最后，计数器的值被送到输出端口 out_6 上，其中低三位连接 Q(2)、Q(1)、Q(0)，因为这三个信号是计数器的低三位，最高位是输出默认设置为 0。</p><p>因此，每当输入端口 c0 产生一个计数脉冲时，计数器的值增加 1，计数器的最小值是 0，最大值是 5（即 101b）。</p><p><strong>注意</strong>：六进制计数器作为高位，应该考虑一个低位进位输入c0，而10位计数器不考虑输入。</p><h3 id="组合6进制计数器与10进制计数器：basic">组合6进制计数器与10进制计数器：basic</h3><p>输入：clk , rst : in std_logic ;</p><p>输出：low, high: out std_logic_vector(3 downto 0)</p><p>大致思路：引入一个6进制计数器与10进制计数器，再额外引进一个触发器用于判断是否进位。</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span></span><br><span class="line"> count_low: click_10 <span class="keyword">port</span> <span class="keyword">map</span>(clk, Rd, QL);</span><br><span class="line"> count_high: click_6 <span class="keyword">port</span> <span class="keyword">map</span>(clk, Rd, c0, QH);</span><br><span class="line"> trigger: ourDFF <span class="keyword">port</span> <span class="keyword">map</span>(D, clk, Rd, <span class="string">&#x27;1&#x27;</span>, c0);</span><br><span class="line"> <span class="comment">-- Rd &lt;= not (rst or(QH(0)and(((not QL(3))and(QL(2)and QL(1)))and (not QL(0))))); 16进制</span></span><br><span class="line">     Rd&lt;=<span class="keyword">not</span> (rst)<span class="comment">--60进制</span></span><br><span class="line"> D &lt;= (QL(<span class="number">3</span>) <span class="keyword">and</span> (<span class="keyword">not</span> QL(<span class="number">2</span>))) <span class="keyword">and</span> ((<span class="keyword">not</span> QL(<span class="number">1</span>)) <span class="keyword">and</span> (<span class="keyword">not</span> QL(<span class="number">0</span>)));</span><br><span class="line"> low &lt;= QL;</span><br><span class="line"> high &lt;= QH;</span><br><span class="line"><span class="keyword">end</span> basic_bhv;</span><br></pre></td></tr></table></figure><p>在六十进制情况下,只有rst被触发,才激活异步清零;</p><p>而十六进制,rst被触发或判断到达十六,就异步清零</p><p>D:trigger的输入,在Low位到达8的时候为1,激活trigger.这样下一刻low位到达9,trigger修改低位进位输出c0,再下一刻使得高位加1.</p><p>low,high输出.</p><h3 id="七位译码管">七位译码管.</h3><p>为了让输出在不带译码器的数码管显示,需要一个七位译码管.实现不作分析,参见代码.</p><h3 id="点击触发">点击触发:</h3><p>基本要求,用开关实现clk,rst.</p><h3 id="时钟触发">时钟触发:</h3><p>基于点击触发:</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span></span><br><span class="line"> main_count: click <span class="keyword">port</span> <span class="keyword">map</span>(clk2, rst , lout , hout);</span><br><span class="line"> <span class="keyword">process</span>(pause, clk , rst )</span><br><span class="line"> <span class="keyword">begin</span></span><br><span class="line"> <span class="keyword">if</span> ( rst = <span class="string">&#x27;1&#x27;</span>) <span class="keyword">then</span></span><br><span class="line"> t &lt;= <span class="number">0</span>;</span><br><span class="line"> clk2 &lt;= <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"> <span class="keyword">elsif</span> (clk <span class="symbol">&#x27;event</span> <span class="keyword">and</span> clk = <span class="string">&#x27;1&#x27;</span> <span class="keyword">and</span> pause = <span class="string">&#x27;0&#x27;</span>) <span class="keyword">then</span></span><br><span class="line"> <span class="keyword">if</span> (t = <span class="number">1000000</span>) <span class="keyword">then</span></span><br><span class="line"> t &lt;= <span class="number">0</span>;</span><br><span class="line"> clk2 &lt;= <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"> <span class="keyword">elsif</span> (t = <span class="number">500000</span>) <span class="keyword">then</span></span><br><span class="line"> t &lt;= t + <span class="number">1</span>;</span><br><span class="line"> clk2 &lt;= <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> t &lt;= t + <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">end</span> <span class="keyword">if</span> ;</span><br><span class="line"> <span class="keyword">end</span> <span class="keyword">if</span> ;</span><br><span class="line"> <span class="keyword">end</span> <span class="keyword">process</span> ;</span><br><span class="line"><span class="keyword">end</span> counter_bhv;</span><br></pre></td></tr></table></figure><p>逢1M模拟一次clk,一半低电平一半高电平.</p><h2 id="实验现象">实验现象</h2><p>16进制触发器与60进制触发器均正常工作.</p><p>实验后优化了代码,转到了使用译码管的实现.</p><p>发现取消clk的低电平也即</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">elsif</span> (t = <span class="number">500000</span>) <span class="keyword">then</span></span><br><span class="line"> t &lt;= t + <span class="number">1</span>;</span><br><span class="line"> clk2 &lt;= <span class="string">&#x27;0&#x27;</span>;</span><br></pre></td></tr></table></figure><p>一样work</p>]]></content>
      
      
      <categories>
          
          <category> homework </category>
          
          <category> DLCE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> homework </tag>
            
            <tag> DLCE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复叶鉴赏</title>
      <link href="/homework/flower_identification/%E5%A4%8D%E5%8F%B6%E9%89%B4%E8%B5%8F/"/>
      <url>/homework/flower_identification/%E5%A4%8D%E5%8F%B6%E9%89%B4%E8%B5%8F/</url>
      
        <content type="html"><![CDATA[<h1>叶的形态</h1><ul class="lvl-0"><li class="lvl-2"><h3 id="羽状复叶：栾">羽状复叶：栾</h3><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/dd611818350c4feb8b9351da4fd74f12/202310071834831.png" alt="image-20231007183418698"></p></li><li class="lvl-2"><h3 id="羽状复叶2-华北珍珠梅">羽状复叶2:华北珍珠梅</h3><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/49e4228c914e1e46d9a90586519cea1e/202310071838594.png" alt="image-20231007183804342"></p></li><li class="lvl-2"><p>掌状复叶1：七叶树</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/a58c35b6d061970ff6dfde92fb87dd8b/202310071830900.png" alt="image-20231007183058684"></p></li><li class="lvl-2"><p>掌状复叶2：五叶地锦</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/777499aa0d706543751c9ee01d447e87/202310081017886.jpg" alt="fd3e6f179d4a7b48cbb2562dd2a0f4a"></p></li><li class="lvl-2"><p>羽状分裂叶片1：山楂</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/ea1b9841e35a3d92233010cc051cbd1b/202310071842909.png" alt="image-20231007184206866"></p></li><li class="lvl-2"><p>羽状分裂叶片2：沼生栎–&gt;绿园</p></li><li class="lvl-2"><p>掌状分裂叶片1：梧桐</p></li><li class="lvl-2"><p>掌状分裂叶片2：</p></li><li class="lvl-2"><p>三出复叶1</p></li><li class="lvl-2"><p>多回复叶1</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> homework </category>
          
          <category> 花卉鉴赏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> homework </tag>
            
            <tag> 花卉鉴赏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>花卉调查报告素材</title>
      <link href="/homework/flower_identification/%E8%8A%B1%E5%8D%89%E8%B0%83%E6%9F%A5%E6%8A%A5%E5%91%8A/"/>
      <url>/homework/flower_identification/%E8%8A%B1%E5%8D%89%E8%B0%83%E6%9F%A5%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<h1>花卉报告素材</h1><h2 id="1-中文名：七叶树">1.中文名：七叶树</h2><p>学名：<strong>Aesculus</strong> <strong>chinensis</strong></p><p>分布地位（科名，属名）：无患子科 七叶树属</p><p>观察地点：紫荆公寓附近，清芬园南</p><ul class="lvl-0"><li class="lvl-2"><p>掌状复叶对生，有明显小叶柄</p><img src="https://gitlab.com/ggx-blog/imglab/uploads/8348bae942ca88abc5c893f5caa0f110/202310061245540.png" alt="image-20231006124521369" style="zoom:50%;" /></li><li class="lvl-2"><p>蒴果球形，密生疣点</p><img src="https://gitlab.com/ggx-blog/imglab/uploads/98c58152f5fdb56f78399c658376a2a6/202310061252943.png" alt="image-20231006125241782" style="zoom:50%;" /></li></ul><h2 id="2-中文名：鹅掌楸">2.中文名：鹅掌楸</h2><ul class="lvl-0"><li class="lvl-2"><p>学名：<strong>Liriodendron</strong> <strong>chinense</strong></p></li><li class="lvl-2"><p>分布地位（科名，属名）：木兰科 鹅掌楸属</p></li><li class="lvl-2"><p>观察地点：荷塘中心荒岛，C楼附近</p></li><li class="lvl-2"><p>叶马褂形</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/ca40ec49c8e7f17632da63855b8d33e9/202310061255717.png" alt="image-20231006125539465"></p></li><li class="lvl-2"></li></ul><h2 id="3-中文名：桔梗">3.中文名：桔梗</h2><ul class="lvl-0"><li class="lvl-2"><p>学名：<strong>Platycodon</strong> <strong>grandiflorus</strong></p></li><li class="lvl-2"><p>分布地位（科名，属名）：桔梗科 桔梗属</p></li><li class="lvl-2"><p>观察地点：紫藤架东南</p></li><li class="lvl-2"><p>花单朵顶生，蓝紫色花冠漏斗状钟形，5裂</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/7e29b1571198834123280f10c9744e0f/202310061405486.png" alt="image-20231006140551112"></p></li><li class="lvl-2"><p>叶卵形或披针形，边缘具细锯齿。茎直立不分枝</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/d0a26fb9cee96765958c96ac45c97278/202310061412081.png" alt="image-20231006141254940"></p></li></ul><h2 id="4-中文名：紫珠">4.中文名：紫珠</h2><ul class="lvl-0"><li class="lvl-2"><p>学名：<strong>Callicarpa</strong> <strong>bodinieri</strong></p></li><li class="lvl-2"><p>分布地位（科名，属名）：马鞭草科-紫珠属</p></li><li class="lvl-2"><p>观察地点：紫藤架东南</p></li><li class="lvl-2"><p>花语是聪明</p></li><li class="lvl-2"><p>果球形，紫色，径约2毫米</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/fd951f0bc8475c0181e45e7153b3feb7/202310061423904.png" alt="image-20231006142338731"></p></li><li class="lvl-2"><p>叶卵状长椭圆形，长7-18厘米</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/58b1084a1157470e212d61d7a6791251/202310061425199.png" alt="image-20231006142518021"></p></li></ul><h2 id="5-中文名：风箱果">5.中文名：风箱果</h2><ul class="lvl-0"><li class="lvl-2"><p>学名：<strong>Physocarpus</strong> <strong>amurensis</strong></p></li><li class="lvl-2"><p>分布地位（科名，属名）：蔷薇科 风箱果属</p></li><li class="lvl-2"><p>观察地点：荷塘中心荒岛</p></li><li class="lvl-2"><p>蓇葖果膨大，卵圆形，顶端渐尖</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/fb269d8b126d373e6b851e2d21937b29/202310061428030.png" alt="image-20231006142848842"></p></li><li class="lvl-2"><p>叶三角状卵形至倒卵形，常3裂，稀5裂</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/c4d92805cd54ee570f5f19857314aea6/202310061429371.png" alt="image-20231006142913147"></p></li></ul><h2 id="6-中文名：木香薷">6.中文名：木香薷</h2><p>学名：<strong>Elsholtzia</strong> <strong>stauntonii</strong></p><p>分布地位（科名，属名）：唇形科 香薷属</p><p>观察地点：紫藤架东南</p><ul class="lvl-0"><li class="lvl-2"><p>穗状花序偏向一侧，花冠淡红紫色</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/d5d058f41dfac343bf4df5a347f9cf27/202310061440469.png" alt="image-20231006144014259"></p></li><li class="lvl-2"><p>半直立灌木，叶披针形，长8-12厘米</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/4c324ff70867e2e333d21f081d5d8f53/202310061441955.png" alt="image-20231006144130751"></p></li></ul><h2 id="7-中文名：连翘？？">7.中文名：连翘？？</h2><ul class="lvl-0"><li class="lvl-2"><p>学名：<strong>Forsythia</strong> <strong>suspensa</strong></p></li><li class="lvl-2"><p>分布地位（科名，属名）：木樨科-连翘属</p></li><li class="lvl-2"><p>观察地点：生物馆南侧</p></li><li class="lvl-2"><p>花通常单生着生于叶腋，（花期3-4月为什么我能拍到）</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/54824fa2f931ec5fdfa4495f689e310d/202310061447563.png" alt="image-20231006144749345"></p></li><li class="lvl-2"><p>叶片卵形、宽卵形或椭圆状卵形至椭圆形</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/818a0da5e313b69cd84e725b7c664fb1/202310061449761.png" alt="image-20231006144929475"></p></li></ul><h2 id="8-中文名：千屈菜">8.中文名：千屈菜</h2><ul class="lvl-0"><li class="lvl-2"><p>学名：<strong>Lythrum</strong> <strong>salicaria</strong></p></li><li class="lvl-2"><p>分布地位（科名，属名）：千屈菜科，千屈菜属</p></li><li class="lvl-2"><p>俗名：水柳</p></li><li class="lvl-2"><p>观察地点：荷塘边</p></li><li class="lvl-2"><p>花组成小聚伞花序，簇生，因花梗及总梗极短，因此花枝全形似一大型穗状花序</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/5b5c4bb323f71ef9f9b1098e9f189f32/202310061452383.png" alt="image-20231006145226162"></p></li><li class="lvl-2"><p>多年生草本，茎直立，多分枝，密被绒毛</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/e2af15a9e0c9b1c90bd38bd5e3ffd801/202310061454546.png" alt="image-20231006145422309"></p></li></ul><h2 id="9-中文名：君迁子">9.中文名：君迁子</h2><p>学名：<strong>Diospyros</strong> <strong>lotus</strong></p><p>分布地位（科名，属名）：柿科-柿属</p><p>观察地点：生物馆南</p><ul class="lvl-0"><li class="lvl-2"><p>果近球形或椭圆形，常被白色薄蜡层</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/23b21a8b5036c6551bef1a1636c77852/202310061459039.png" alt="image-20231006145927771"></p></li><li class="lvl-3"><p>高大落叶乔木；叶近膜质，椭圆形或长椭圆形，</p></li></ul><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/dfaee92f78cc6adb844dc273e9e9f1d6/202310061500403.png" alt="image-20231006150031117"></p><h2 id="10-中文名：紫荆？？">10.中文名：紫荆？？</h2><p>学名：</p><p>分布地位（科名，属名）：</p><p>观察地点：</p><ul class="lvl-0"><li class="lvl-2"><p>荚果扁，窄长圆形，顶端急尖</p></li><li class="lvl-2"><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/06140e149c38039fc3177871160378a8/202310061505812.png" alt="image-20231006150511719"></p></li><li class="lvl-2"></li></ul><h2 id="11-中文名：栾">11.中文名：栾</h2><p>学名：<strong>Koelreuteria</strong> <strong>paniculata</strong></p><p>分布地位（科名，属名）：无患子科 栾属</p><p>观察地点：绿园</p><ul class="lvl-0"><li class="lvl-2"><p>蒴果</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/a1a8e1ca45fd2b817471b41bf0a45f7e/202310061508305.png" alt="image-20231006150843114"></p></li><li class="lvl-2"><p>种子近球形，径6-8毫米；</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/cd945b284d8c26f4e322da199be26035/202310061509654.png" alt="image-20231006150931491"></p></li><li class="lvl-2"><p>羽状复叶，对生或互生，卵形，齿端具小尖头</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/de493d4978aa850b58b9ea528f532886/202310061509789.png" alt="image-20231006150950590"></p></li></ul><h2 id="12-中文名：山楂">12.中文名：山楂</h2><p>学名：<strong>Crataegus</strong> <strong>pinnatifida</strong></p><p>分布地位（科名，属名）：蔷薇科，山楂属</p><p>观察地点：绿园</p><ul class="lvl-0"><li class="lvl-3"><p>果近球形或梨形，深红色，</p></li></ul><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/dcf059e3feae3e0c88f3298454c8aed3/202310061514592.png" alt=""></p><ul class="lvl-0"><li class="lvl-3"><p>叶宽卵形或三角状卵形，有3-5对羽状深裂片，裂片卵状披针形或带形</p></li></ul><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/4f2c2ba215ffadde0804a7cc4958823a/202310071927092.png" alt="image-20231007192756018"></p><h2 id="13-中文名：梧桐">13.中文名：梧桐</h2><ul class="lvl-0"><li class="lvl-2"><p>学名：<strong>Firmiana</strong> <strong>simplex</strong></p></li><li class="lvl-2"><p>分布地位（科名，属名）：梧桐科-梧桐属</p></li><li class="lvl-2"><p>观察地点：绿园</p></li><li class="lvl-2"><p>蓇葖果膜质，有柄，成熟前开裂成叶状，有种子2-4个</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/8ad20cba2d454bd2aec540d1add653d5/202310062041103.png" alt="image-20231006191355714"></p></li><li class="lvl-2"><p>树皮青绿色，光滑</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/ff70df4382a88186a2271c653acc4ca0/202310062041269.png" alt="image-20231006204134113"></p></li></ul><h2 id="14-中文名：紫薇">14.中文名：紫薇</h2><p>学名：<strong>Lagerstroemia</strong> <strong>indica</strong></p><p>分布地位（科名，属名）：千屈菜科-紫薇属</p><p>观察地点：绿园</p><ul class="lvl-0"><li class="lvl-2"><p>蒴果椭圆状球形或宽椭圆形；顶生圆锥花序，花瓣6，皱缩，具长爪</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/15b9fdeef80a0e85163b3d7010a21f73/202310062040497.png" alt="image-20231006204057376"></p></li><li class="lvl-2"><p>小枝具4棱，叶互生或时有对生，椭圆形</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/12899c6318ebb386db73de4623005deb/202310062043313.png" alt="image-20231006204329099"></p></li></ul><h2 id="15-中文名：婆婆针">15.中文名：婆婆针</h2><p>学名：<strong>Bidens</strong> <strong>bipinnata</strong></p><p>分布地位（科名，属名）：菊科 鬼针草属</p><p>观察地点：荷塘中荒岛</p><ul class="lvl-0"><li class="lvl-2"><p>舌状花黄色，不育</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/a48437bc7b940c4ed6846f657c05785a/202310062046175.png" alt="image-20231006204628067"></p></li><li class="lvl-2"><p>管状花黄色，结实。瘦果线形</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/e91e959a2f1b2f68935842dc47d4302c/202310062049125.png" alt="image-20231006204933091"></p></li><li class="lvl-3"><p>叶对生，长5-14厘米，二回羽状分裂</p></li></ul><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/7a0073b9ff4148a9bfd39e5e947ff08f/202310071929026.png" alt="image-20231007192956878"></p><h2 id="16-中文名：？？">16.中文名：？？+</h2><p>学名：</p><p>分布地位（科名，属名）：</p><p>观察地点：</p><ul class="lvl-0"><li class="lvl-2"><p>花</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/9750964943d510a6ba91097c88f3e909/202310062054645.png" alt="image-20231006205405406"></p></li><li class="lvl-2"><p>叶</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/6e036f99c18403a91e02a645e21d3440/202310062054817.png" alt="image-20231006205421648"></p></li></ul><h2 id="17-中文名：水栒子">17.中文名：水栒子</h2><p>学名：<strong>Cotoneaster</strong> <strong>multiflorus</strong></p><p>分布地位（科名，属名）：蔷薇科-栒子属</p><p>观察地点：荷塘中心荒岛</p><ul class="lvl-0"><li class="lvl-3"><p>果近球形或倒卵圆形，径7-8毫米，成熟时红色</p></li></ul><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/7e2665fd60702b300360b4c382872524/202310062057742.png" alt="image-20231006205729651"></p><ul class="lvl-0"><li class="lvl-2"><p>落叶灌木，叶卵形或宽卵形，纸条细</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/010e1fe31b41268bc21cc2ffede20592/202310062058567.png" alt="image-20231006205824396"></p></li></ul><h2 id="17-中文名：紫花地丁">17.中文名：紫花地丁</h2><p>学名：<strong>Viola</strong> <strong>philippica</strong></p><p>分布地位（科名，属名）：堇菜科 堇菜属</p><p>观察地点：荷塘中荒岛</p><ul class="lvl-0"><li class="lvl-3"><p>花紫堇色或淡紫色，喉部有紫色条纹；蒴果长圆形，无毛；</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/f7b5080f38fc2af783012202e9cd457b/202310071334844.png" alt="image-20231007133431558"></p></li><li class="lvl-2"><p>多年生草本，基生叶莲座状，</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/57d16b0eb940a32f717b5d557538838e/202310071337509.png" alt="image-20231007133714662"></p></li></ul><h2 id="18-中文名：xx苋">18.中文名：xx苋</h2><p>学名：</p><p>分布地位（科名，属名）：</p><p>观察地点：荷塘中荒岛</p><ul class="lvl-0"><li class="lvl-3"><p>果/花<img src="https://gitlab.com/ggx-blog/imglab/uploads/783a150733255bf04d20e850654c2cf3/202310071342216.png" alt="image-20231007134206847"></p></li><li class="lvl-2"><p>叶</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/ab96157d224030b5f9bc1f6a165b5a94/202310071342212.png" alt="image-20231007134236993"></p></li></ul><h2 id="19-中文名：牛膝菊">19.中文名：牛膝菊</h2><p>学名：<strong>Galinsoga</strong> <strong>parviflora</strong></p><p>分布地位（科名，属名）：菊科-牛膝菊属</p><p>观察地点：荷塘中荒岛</p><ul class="lvl-0"><li class="lvl-3"><p>舌状花4-5，舌片白色，先端3齿裂，</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/10942be08aa261cf6417c4b1ff3f365c/202310071346053.png" alt="image-20231007134638873"></p></li><li class="lvl-3"><p>叶对生，卵形或长椭圆状卵形,花序下部的叶披针形,疏被白色贴伏柔毛.</p></li></ul><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/85a0de3760815424a28d09281384ce6c/202310071346104.png" alt="image-20231007134404893"></p><h2 id="20-中文名：枸杞">20.中文名：枸杞</h2><p>学名：<strong>Lycium</strong> <strong>chinense</strong></p><p>分布地位（科名，属名）：茄科 枸杞属</p><p>观察地点：荷塘中心荒岛</p><ul class="lvl-0"><li class="lvl-3"><p>花冠漏斗状，淡紫色 ，5深裂，雄蕊较花冠稍短，或因花冠裂片外展而伸出花冠</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/db708ece4b56d2b5ef7fd34c7a165663/202310071354631.png" alt="image-20231007135424228"></p></li><li class="lvl-2"><p>枝条细弱，弯曲或俯垂，叶卵形</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/38aa92d32c0c3f1e93727c76ee03f9e3/202310071355941.png" alt="image-20231007135518631"></p></li></ul><h2 id="21-中文名：白睡莲">21.中文名：白睡莲</h2><p>学名：<strong>Nymphaea</strong> <strong>alba</strong></p><p>分布地位（科名，属名）：睡莲科 睡莲属</p><p>观察地点：荷塘</p><ul class="lvl-0"><li class="lvl-3"><p>花浮于水面，径10-20厘米，花瓣20-25，白色，椭圆形至卵状椭圆形。</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/3a54a72cc9c34e30aff25372f08573ad/202310071402813.png" alt="image-20231007140218601"></p></li><li class="lvl-2"><p>叶飘浮水面，革质，近圆形</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/d0da6c7dc541c34f9cba8dc0c73cb3f8/202310071401504.png" alt="image-20231007140132147"></p></li></ul><h2 id="22-中文名：（？梣，白蜡？）">22.中文名：（？梣，白蜡？）</h2><p>学名：</p><p>分布地位（科名，属名）：</p><p>观察地点：</p><ul class="lvl-0"><li class="lvl-3"><p>果/花</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/92aada09dd330f2481aa880a87d8fd9a/202310071407349.png" alt="image-20231007140711958"></p></li><li class="lvl-2"><p>叶</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/fd8bb429b7a7ed1cb96b413280f16444/202310071407739.png" alt="image-20231007140738335"></p></li></ul><h2 id="23-中文名：旋覆花">23.中文名：旋覆花</h2><p>学名：<strong>Inula</strong> <strong>japonica</strong></p><p>分布地位（科名，属名）：菊科 旋覆花属</p><p>观察地点：荷塘中荒岛</p><ul class="lvl-0"><li class="lvl-3"><p>舌状花黄色，舌片线形</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/076ffabd076e7c75b1b9950b56c452a6/202310071411174.png" alt="image-20231007141105794"></p></li><li class="lvl-3"><p>中部叶长圆形、长圆状披针形或披针形，无柄</p></li></ul><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/eab8304a8a267e6d5fa319d2936aea7b/202310071411851.png" alt="image-20231007141124689"></p><h2 id="24-中文名：龙葵">24.中文名：龙葵</h2><p>学名：<strong>Solanum</strong> <strong>nigrum</strong></p><p>分布地位（科名，属名）：茄科-茄属</p><p>观察地点：荷塘中荒岛</p><ul class="lvl-0"><li class="lvl-3"><p>果/花</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/09dd6896369ab33f2795d50f14df181f/202310071418285.png" alt="image-20231007141837173"></p></li><li class="lvl-3"><p>浆果球形，成熟时黑色，果柄弯曲</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/1810179c02d73ce63b9a8394926bc3cd/202310071419522.png" alt="image-20231007141945386"></p></li><li class="lvl-2"><p>叶卵形</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/ffbfec96efb65ca4d5fc2942db00cb7d/202310071421602.png" alt="image-20231007142156394"></p></li></ul><h2 id="25-中文名：狼尾草">25.中文名：狼尾草</h2><p>学名：<strong>Pennisetum</strong> <strong>alopecuroides</strong></p><p>分布地位（科名，属名）：禾本科 狼尾草属</p><p>观察地点：荷塘，校河边</p><ul class="lvl-0"><li class="lvl-3"><p>圆锥花序直立，刚毛状小枝常呈紫色，</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/90ce92cb732c2454ac8ac38b13083d2d/202310072303382.png" alt="image-20231007230300223"></p></li><li class="lvl-2"><p>秆直立，丛生，叶鞘光滑，两侧压扁，主脉呈脊</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/a4c4ec62e770c5c57175479d03cc38af/202310071422762.png" alt="image-20231007142238619"></p></li></ul><h2 id="26-中文名：">26.中文名：</h2><p>学名：</p><p>分布地位（科名，属名）：葡萄科</p><p>观察地点：</p><ul class="lvl-0"><li class="lvl-3"><p>果/花</p></li></ul><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/aa42b0f0b4dace95e264929625925b24/202310071424734.png" alt="image-20231007142454470"></p><ul class="lvl-0"><li class="lvl-2"><p>叶</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/c3204180b0981b5076b80da14770f1f6/202310071425703.png" alt="image-20231007142519316"></p></li></ul><h2 id="27-中文名：圆叶牵牛">27.中文名：圆叶牵牛</h2><p>学名：<strong>Ipomoea</strong> <strong>purpurea</strong></p><p>分布地位（科名，属名）：旋花科 虎掌藤属</p><p>观察地点：荷塘中心荒岛，广布</p><ul class="lvl-0"><li class="lvl-3"><p>花冠漏斗状，长4-6厘米，紫红色，花冠管通常白色，</p></li></ul><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/40e8a4740f4da8cac63a053dfd380dbf/202310071426543.png" alt="image-20231007142609406"></p><ul class="lvl-0"><li class="lvl-3"><p>叶圆心形或宽卵状心形</p></li></ul><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/1f6b22844b7a954aa86a966de5dde239/202310071426637.png" alt="image-20231007142620366"></p><h2 id="28-中文名：湖北梣">28.中文名：湖北梣</h2><p>学名：<strong>Fraxinus</strong> <strong>hubeiensis</strong></p><p>分布地位（科名，属名）：木樨科 梣属</p><p>观察地点：绿园 生物学馆南侧</p><ul class="lvl-0"><li class="lvl-3"><p>翅果匙形</p></li></ul><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/c613e3cb006b882b19d93065048c21d7/202310071428858.png" alt="image-20231007142843739"></p><ul class="lvl-0"><li class="lvl-2"><p>奇数羽状复叶</p></li></ul><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/d253b6a19ce18369154b4721a06b1f57/202310071428269.png" alt="image-20231007142855056"></p><h2 id="29-中文名：山楂">29.中文名：山楂</h2><p>学名：<strong>Crataegus</strong> <strong>pinnatifida</strong></p><p>分布地位（科名，属名）：蔷薇科 山楂属</p><p>观察地点：生物学馆南侧</p><ul class="lvl-0"><li class="lvl-4"><p>果近球形或梨形，深红色</p></li></ul><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/89056676fe1b981f63ddefee08cf4f7e/202310071429933.png" alt="image-20231007142911808"></p><ul class="lvl-0"><li class="lvl-2"><p>叶宽卵形或三角状卵形，有3-5对羽状深裂片</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/23f5e53f230ada37985f182a6d7c79aa/202310071429590.png" alt="image-20231007142927462"></p></li></ul><h2 id="30-中文名：柿">30.中文名：柿</h2><p>学名：<strong>Diospyros</strong> <strong>kaki</strong></p><p>分布地位（科名，属名）：柿科 柿属</p><p>观察地点：生物学馆南侧</p><ul class="lvl-0"><li class="lvl-3"><p>果/花</p></li></ul><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/081255fb40bbbd803d534f47e2baa573/202310071426042.png" alt="image-20231007142641822"></p><ul class="lvl-0"><li class="lvl-2"><p>叶</p></li></ul><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/d20e563c33f6f54466fba23078f81b18/202310071428447.png" alt="image-20231007142826294"></p><h2 id="31-中文名：牵牛">31.中文名：牵牛</h2><p>学名：<strong>Ipomoea</strong> <strong>nil</strong></p><p>分布地位（科名，属名）：旋花科 虎掌藤属</p><p>观察地点：荷塘中荒岛</p><ul class="lvl-0"><li class="lvl-3"><p>花冠蓝紫或紫红色，筒部色淡</p></li></ul><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/50cbf53e4f65d86e0f693aab1ac48eb5/202310071429545.png" alt="image-20231007142954227"></p><ul class="lvl-0"><li class="lvl-2"><p>叶宽卵形或近圆形，长4-15厘米，3(-5)裂</p></li></ul><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/0961a6cca83bfdc47ddd4514559b3d67/202310071430956.png" alt="image-20231007143001676"></p><h2 id="32-中文名：荆芥">32.中文名：荆芥</h2><p>学名：<strong>Nepeta</strong> <strong>cataria</strong></p><p>分布地位（科名，属名）：唇形科 荆芥属</p><p>观察地点：</p><ul class="lvl-0"><li class="lvl-3"><p>聚伞圆锥花序顶生</p></li></ul><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/2a8e2f807f56bff631f5844e683a74a0/202310071431236.png" alt="image-20231007143131104"></p><ul class="lvl-0"><li class="lvl-2"><p>叶卵形或三角状心形，基部心形或平截，具粗齿</p></li></ul><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/c1044672006c3e26ff1df6544cf52774/202310071431971.png" alt="image-20231007143142790"></p><h2 id="33-中文名：八宝">33.中文名：八宝</h2><p>学名：<strong>Hylotelephium</strong> <strong>erythrostictum</strong></p><p>分布地位（科名，属名）：景天科 八宝属</p><p>观察地点：老馆东校河边</p><ul class="lvl-0"><li class="lvl-3"><p>伞房状花序顶生；花密生，花瓣5，白或粉红色，宽披针形</p></li></ul><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/cdd870690cb957f2bd8def4b61acd513/202310071432062.png" alt="image-20231007143253792"></p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/9127180f0045d623d31f43565bbda422/202310071433224.png" alt="image-20231007143313924"></p><ul class="lvl-0"><li class="lvl-3"><p>叶对生，稀互生或3叶轮生，长圆形或卵状长圆形，无柄</p></li></ul><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/b38823b7329d417b6e93455b252b6f48/202310071432341.png" alt="image-20231007143246991"></p><h2 id="34-中文名：苹果">34.中文名：苹果</h2><p>学名：<strong>Malus</strong> <strong>pumila</strong></p><p>分布地位（科名，属名）：蔷薇科 苹果属</p><p>观察地点：观畴园</p><ul class="lvl-0"><li class="lvl-3"><p>果扁球形</p></li></ul><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/43539cdfbfe1bb6bfd20655d07c97456/202310072255311.png" alt="image-20231007225544049"></p><ul class="lvl-0"><li class="lvl-3"><p>叶椭圆形、卵形或宽椭圆形</p></li></ul><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/825113606696073e8aa1de46244e832f/202310072255984.png" alt="image-20231007225557802"></p><h2 id="35-中文名：酸浆">35.中文名：酸浆</h2><p>学名：<strong>Alkekengi</strong> <strong>officinarum</strong></p><p>分布地位（科名，属名）：茄科 酸浆属</p><p>观察地点：家属区</p><ul class="lvl-0"><li class="lvl-3"><p>果<img src="https://gitlab.com/ggx-blog/imglab/uploads/4f2444b9b3faa01da7c826ec7a36ba1d/202310071433828.png" alt="image-20231007143344506"></p></li><li class="lvl-3"><p>叶长卵形或宽卵形</p></li></ul><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/24d991da13494c7beba4a0b689c0b9ca/202310071433252.png" alt="image-20231007143329875"></p><h2 id="36-中文名：扁豆">36.中文名：扁豆</h2><p>学名：<strong>Lablab</strong> <strong>purpureus</strong></p><p>分布地位（科名，属名）：豆科 扁豆属</p><p>观察地点：家属区</p><ul class="lvl-0"><li class="lvl-3"><p>荚果长圆状镰形</p></li></ul><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/60cf70bdd01b39f1ee0aa9baac53e490/202310071434125.png" alt="image-20231007143437956"></p><ul class="lvl-0"><li class="lvl-4"><p>总状花序直立，花冠白色或紫色，旗瓣圆形</p></li></ul><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/381a1f61a89aa6a757ea72e7a2078b2e/202310071434871.png" alt="image-20231007143427770"></p><ul class="lvl-0"><li class="lvl-2"><p>羽状复叶具3小叶</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/261a6a167438474c9db44147b364eb96/202310072008829.png" alt="image-20231007200824765"></p></li></ul><h2 id="37-中文名：四季秋海棠">37.中文名：四季秋海棠</h2><p>学名：<strong>Begonia</strong> <strong>cucullata</strong></p><p>分布地位（科名，属名）：秋海棠科 秋海棠属</p><p>观察地点：天大广场盆栽</p><ul class="lvl-0"><li class="lvl-3"><p>聚伞花序腋生，具数花，花红色，淡红色或白色</p><ul class="lvl-2"><li class="lvl-5"><p>雄花较大有花被片4</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/c017c12898696d362dd95e2255815ca8/202310071435363.png" alt="image-20231007143549082"></p></li><li class="lvl-5"><p>雌花稍小，有花被片5</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/771d5fc884803940cb8a098a83843e1c/202310071436409.png" alt="image-20231007143610098"></p></li></ul></li><li class="lvl-2"><p>单叶互生，有光泽</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/06c7087482cb596a7db5a539a0d16586/202310071437945.png" alt="image-20231007143727583"></p></li></ul><h2 id="38-中文名：紫萼">38.中文名：紫萼</h2><p>学名：<strong>Hosta</strong> <strong>ventricosa</strong></p><p>分布地位（科名，属名）：天门冬科 玉簪属</p><p>观察地点：新经管楼北侧</p><ul class="lvl-0"><li class="lvl-3"><p>花漏斗状，紫红色，雄蕊伸出花被之外</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/0cf2c92235014e4f1388eae1df88e876/202310071438464.png" alt="image-20231007143844187"></p></li><li class="lvl-2"><p>叶基生， 卵状心形、卵形至卵圆形</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/33658a8fd8e2f21699afaa49ff373872/202310071438596.png" alt="image-20231007143852327"></p></li></ul><h2 id="39-中文名：凤尾丝兰">39.中文名：凤尾丝兰</h2><p>学名：<strong>Yucca</strong> <strong>gloriosa</strong></p><p>分布地位（科名，属名）：天门冬科 丝兰属</p><p>观察地点：C楼门口，主楼广场</p><ul class="lvl-0"><li class="lvl-4"><p>圆锥花序高1-1.5米，花下垂，白或淡黄白色</p></li></ul><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/f871d708de0ed9a44fa33b29ca7bcc13/202310071439801.png" alt="image-20231007143912697"></p><ul class="lvl-0"><li class="lvl-3"><p>叶线状披针形，长40-80厘米，坚硬刺状</p></li></ul><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/fc86c5da2045d38dffb33e6ec30a07b5/202310071443947.png" alt="image-20231007144304658"></p><h2 id="40-中文名：锦带花">40.中文名：锦带花</h2><p>学名：<strong>Weigela</strong> <strong>florida</strong></p><p>分布地位（科名，属名）：忍冬科 锦带花属</p><p>观察地点：主楼前广场</p><ul class="lvl-0"><li class="lvl-3"><p>花单生或成聚伞花序，萼筒长圆柱形，花冠紫红色或玫瑰红色</p></li></ul><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/30f4fb1e0187caf8af07d18aa8c1ce46/202310071440995.png" alt="image-20231007144026699"></p><ul class="lvl-0"><li class="lvl-3"><p>叶矩圆形、椭圆形至倒卵状椭圆形，叶顶端渐尖，边缘有锯齿</p></li></ul><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/11e7c439539de977380aaa2ad6930f83/202310071440418.png" alt="image-20231007144009177"></p><h2 id="41-中文名：华北珍珠梅">41.中文名：华北珍珠梅</h2><p>学名：<strong>Sorbaria</strong> <strong>kirilowii</strong></p><p>分布地位（科名，属名）：蔷薇科-珍珠梅属</p><p>观察地点：荷塘中荒岛</p><ul class="lvl-0"><li class="lvl-3"><p>圆锥花序密集，花瓣白色，倒卵形或宽卵形，长4-5毫米；雄蕊20，与花瓣等长或稍短</p></li></ul><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/289b9a290ba4cd40a363a7b0d2705941/202310071442633.png" alt="image-20231007144249324"></p><ul class="lvl-0"><li class="lvl-3"><p>羽状复叶具小叶13-21，小叶披针形</p></li></ul><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/60e6539969eefca5d725c4162252eda0/202310071440915.png" alt="image-20231007144048456"></p><h2 id="42-中文名：紫薇">42.中文名：紫薇</h2><p>学名：</p><p>分布地位（科名，属名）：</p><p>观察地点：</p><ul class="lvl-0"><li class="lvl-2"><p>果/花</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/53eea2348e3a63a9197eeec909dde097/202310071444711.png" alt="image-20231007144420401"></p></li><li class="lvl-2"><p>叶</p></li></ul><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/35449f7465c2c4bde5aa5dfe8f8e9600/202310071444156.png" alt="image-20231007144428937"></p><h2 id="43-中文名：木槿">43.中文名：木槿</h2><p>学名：</p><p>分布地位（科名，属名）：</p><p>观察地点：</p><ul class="lvl-0"><li class="lvl-2"><p>花单生枝端叶腋，花冠钟形，淡紫色，花瓣5，雄蕊柱长约3厘米</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/9252f4c4d0f1c148f1d1e0da46bd9c80/202310071444635.png" alt="image-20231007144452389"></p></li><li class="lvl-2"><p>叶菱形或三角状卵形，具不整齐缺齿</p></li></ul><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/d2e245c240508d6de4fec48481ecd82f/202310071445275.png" alt="image-20231007144507896"></p><h2 id="44-中文名：紫藤">44.中文名：紫藤</h2><p>学名：<strong>Wisteria</strong> <strong>sinensis</strong></p><p>分布地位（科名，属名）：豆科 紫藤属</p><p>观察地点：生物馆南紫藤架，主楼后</p><ul class="lvl-0"><li class="lvl-2"><p>荚果线状倒披针形，成熟后不脱落，密被灰色茸毛</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/b5f9fa2accdc79972618af489e4f0f24/202310071445789.png" alt="image-20231007144520666"></p></li><li class="lvl-3"><p>羽状复叶长15-25厘米，小叶9-13</p></li></ul><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/9780b71d56326f60a76836f463526346/202310071445661.png" alt="image-20231007144530408"></p><h2 id="45-中文名：玉兰">45.中文名：玉兰</h2><p>学名：<strong>Yulania</strong> <strong>denudata</strong></p><p>分布地位（科名，属名）：玉兰科 玉兰属</p><p>观察地点：主楼后</p><ul class="lvl-0"><li class="lvl-2"><p>聚合果圆柱形</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/9b35204deb967b55f6500a66e35b776a/202310071445751.png" alt="image-20231007144555514"></p></li><li class="lvl-2"><p>叶脉（8-10）较望春玉兰少，先端宽圆、平截或稍凹</p></li></ul><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/04de6e88c3261b8ba9e594033e73fc5c/202310071446597.png" alt="image-20231007144620440"></p><h2 id="46-中文名：紫薇">46.中文名：紫薇</h2><p>学名：</p><p>分布地位（科名，属名）：</p><p>观察地点：</p><ul class="lvl-0"><li class="lvl-2"><p>果/花</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/fd1dca064b1c0c8c58da1cb1014fbb47/202310071447475.png" alt="image-20231007144726227"></p></li><li class="lvl-2"><p>叶</p></li></ul><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/0d11185f2dc8af8eeeb5a17c614503c9/202310071447906.png" alt="image-20231007144743721"></p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/71639ef4833cf412ac9d52ec66ed765d/202310071448743.png" alt="image-20231007144811505"></p><h2 id="47-中文名：菊芋">47.中文名：菊芋</h2><p>学名：<strong>Helianthus</strong> <strong>tuberosus</strong></p><p>分布地位（科名，属名）：菊科 向日葵属</p><p>观察地点：北馆北侧</p><ul class="lvl-0"><li class="lvl-3"><p>头状花序单生枝端，舌片黄色，长椭圆形</p></li></ul><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/008439e368b6558a8cf6b8f0485199f2/202310071448621.png" alt="image-20231007144851370"></p><ul class="lvl-0"><li class="lvl-3"><p>叶对生，卵圆形或卵状椭圆形，有粗锯齿，离基3出脉，上面被白色粗毛</p></li></ul><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/8979c1e576e889ebb0651e8ec38160fd/202310071448026.png" alt="image-20231007144843769"></p><h2 id="48-中文名：">48.中文名：</h2><p>学名：</p><p>分布地位（科名，属名）：</p><p>观察地点：</p><ul class="lvl-0"><li class="lvl-2"><p>果/花</p></li><li class="lvl-2"><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/f3fecf69d170fb737ef488ddde3aad40/202310071450678.png" alt="image-20231007145041403"></p></li><li class="lvl-2"><p>叶</p></li><li class="lvl-2"><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/73a9b314612f4d6a39d3fd734f313dc2/202310071450581.png" alt="image-20231007145031431"></p></li></ul><h2 id="49-中文名：糯米条">49.中文名：糯米条</h2><p>学名：<strong>Abelia</strong> <strong>chinensis</strong></p><p>分布地位（科名，属名）：忍冬科 六道木属</p><p>观察地点：紫荆宿舍区</p><ul class="lvl-0"><li class="lvl-2"><p>花芳香，具3对小苞片，花丝细长，伸出花冠筒外</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/0b05716831631ebffd00c64dd90f215f/202310071450115.png" alt="image-20231007145053920"></p></li><li class="lvl-2"><p>叶圆卵形至椭圆状卵形，顶端急尖或长渐尖</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/bd92ba584dddab41dae493535a5abdd9/202310071451597.png" alt="image-20231007145113476"></p></li></ul><h2 id="50-中文名：蛇莓">50.中文名：蛇莓</h2><p>学名：<strong>Duchesnea</strong> <strong>indica</strong></p><p>分布地位（科名，属名）：蔷薇科 蛇莓属</p><p>观察地点：北馆北草地</p><ul class="lvl-0"><li class="lvl-2"><p>花瓣倒卵形，黄色，雄蕊多枚</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/695dd322363236534807fa9824e835c3/202310071451516.png" alt="image-20231007145139398"></p></li><li class="lvl-3"><p>匍匐茎多数， 小叶倒卵形或菱状长圆形，先端圆钝，有钝锯齿</p></li></ul><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/da0db188082a9ca42a5472538e977472/202310071451210.png" alt="image-20231007145155936"></p><h2 id="51-中文名：假龙头花">51.中文名：假龙头花</h2><p>学名：<strong>Physostegia</strong> <strong>virginiana</strong></p><p>分布地位（科名，属名）：唇形科 假龙头花属</p><p>观察地点：情人坡</p><ul class="lvl-0"><li class="lvl-3"><p>穗状花序顶生，花冠唇形，花色淡紫红</p></li></ul><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/a33837faf4c13ed0e24d8775cd6b180d/202310071452404.png" alt=""></p><ul class="lvl-0"><li class="lvl-2"><p>单叶对生，披针形，亮绿色，边缘具锯齿</p></li></ul><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/6460904dc152d5d531389508b03889a2/202310071452390.png" alt="image-20231007145233149"></p><h2 id="52-中文名：">52.中文名：</h2><p>学名：</p><p>分布地位（科名，属名）：</p><p>观察地点：</p><ul class="lvl-0"><li class="lvl-2"><p>果/花</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/8d6f9dc9d608810da46d6eaac1f3f719/202310072302328.png" alt="image-20231007230217208"></p></li><li class="lvl-2"><p>叶</p><p><img src="https://gitlab.com/ggx-blog/imglab/uploads/0bac39370988090208f457c3040e0f88/202310072302879.png" alt="image-20231007230233775"></p></li></ul><h2 id="53-中文名：">53.中文名：</h2><p>学名：</p><p>分布地位（科名，属名）：</p><p>观察地点：</p><ul class="lvl-0"><li class="lvl-2"><p>果/花</p></li><li class="lvl-2"><p>叶</p></li></ul><h2 id="54-中文名：">54.中文名：</h2><p>学名：</p><p>分布地位（科名，属名）：</p><p>观察地点：</p><ul class="lvl-0"><li class="lvl-2"><p>果/花</p></li><li class="lvl-2"><p>叶</p></li></ul><h2 id="55-中文名：">55.中文名：</h2><p>学名：</p><p>分布地位（科名，属名）：</p><p>观察地点：</p><ul class="lvl-0"><li class="lvl-2"><p>果/花</p></li><li class="lvl-2"><p>叶</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> homework </category>
          
          <category> 花卉鉴赏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> homework </tag>
            
            <tag> 花卉鉴赏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>slides</title>
      <link href="/slides/"/>
      <url>/slides/</url>
      
        <content type="html"><![CDATA[<h1>这里会放上我的一些slides</h1><ul class="lvl-0"><li class="lvl-2"><a href="/slide/demo">slide-demo</a></li><li class="lvl-2"><a href="/slide/slide">团日pre</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> slides </category>
          
      </categories>
      
      
        <tags>
            
            <tag> slides </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CH7-0</title>
      <link href="/notes/network/week12/"/>
      <url>/notes/network/week12/</url>
      
        <content type="html"><![CDATA[<h1>传输层基础</h1><h2 id="传输层概述">传输层概述</h2><p>传输层（Transport Layer）主要关注在网络中的两个主机之间的数据传输，提供端到端的可靠性和服务质量。</p><div class="tips"><p>网络层（Network Layer）位于传输层下方，主要负责处理数据在网络中的路由和转发。</p><p>总结来说，传输层主要关注主机之间的端到端数据传输，确保数据的可靠性和服务质量，而网络层则更关注在网络中的路由和转发，决定数据在网络中的路径和目标地址。</p></div><h3 id="传输层功能">传输层功能</h3><p><strong>传输层基本服务</strong>：将主机间交付扩展到进程间交付，通过<strong>复用</strong>和<strong>分用</strong>实现</p><ul class="lvl-0"><li class="lvl-2"><p>(发送端)复用:传输层从多个应用收集数据，交给网络层发送</p></li><li class="lvl-2"><p>(接收端)分用:传输层将从网络层收到的数据，交付给正确的应用</p></li></ul><h5 id="传输层的主要功能包括：">传输层的主要功能包括：</h5><ol><li class="lvl-3"><p>分段和重组：传输层将来自应用层的数据分割成更小的数据块，称为分段。这些分段包括序列号，以便在目标主机上正确地重组数据。在接收端，传输层根据序列号重新组装分段，还原为完整的数据。</p></li><li class="lvl-3"><p>可靠的数据传输：传输层使用可靠的传输协议（如TCP）来确保数据的可靠传输。它通过使用确认和重传机制来处理丢失的数据、损坏的数据和乱序的数据，以确保数据在网络中正确地到达目标主机。</p></li><li class="lvl-3"><p>流量控制：传输层通过流量控制机制来协调发送方和接收方之间的数据传输速率，以防止接收方因处理过多数据而不堪重负。这样可以确保在网络中的各个部分之间平衡数据的流动。</p></li><li class="lvl-3"><p>拥塞控制：传输层还负责控制数据在网络中的拥塞程度。通过使用拥塞控制算法，传输层可以检测到网络中的拥塞情况，并采取相应的措施来减少数据的发送速率，以避免拥塞进一步恶化。</p></li></ol><h3 id="UDP">UDP</h3><p>提供的额外功能很少,只是标记了</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span>                   <span class="number">1</span>                   <span class="number">2</span>                   <span class="number">3</span></span><br><span class="line"> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="operator">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="operator">|</span>          <span class="variable">Source</span> <span class="variable">Port</span>          <span class="operator">|</span>       <span class="variable">Destination</span> <span class="variable">Port</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="operator">|</span>            <span class="built_in">Length</span>             <span class="operator">|</span>           <span class="variable">Checksum</span>            <span class="operator">|</span></span><br><span class="line"><span class="operator">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="operator">|</span>                             <span class="variable">Data</span>                              <span class="operator">|</span></span><br><span class="line"><span class="operator">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul class="lvl-0"><li class="lvl-2"><p>Source Port：16位字段，表示源端口号，标识发送方的应用程序或进程。</p></li><li class="lvl-2"><p>Destination Port：16位字段，表示目标端口号，标识接收方的应用程序或进程。</p></li><li class="lvl-2"><p>Length：16位字段，表示UDP头加上UDP数据的总长度，以字节为单位。</p></li><li class="lvl-2"><p>Checksum：16位字段，用于校验UDP头和数据的完整性。校验和的计算涉及UDP头、UDP数据以及伪首部的部分。</p></li></ul><p>所以实际上只能提供进程标识与校验两个新功能.</p><p>所以UPD有以下几个特点是显然的.</p><h4 id="udp特点">udp特点</h4><ul class="lvl-0"><li class="lvl-2"><p>无连接,不可靠</p><p>发送前不需建立链接,想发就发.减小开销与时延;</p><p>不限制发送速率(没有拥塞控制和流量控制)</p></li><li class="lvl-2"><p>面向报文:</p><p>一次交付一整个完整的报文,不合并也不拆分</p></li><li class="lvl-2"><p>支持一对多\多对一</p></li><li class="lvl-2"><p>首部开销小</p></li></ul><h3 id="TCP">TCP</h3><p>TCP基本可看做UDP互补</p><h4 id="TCP特点">TCP特点</h4><ol><li class="lvl-3"><p>可靠性：TCP通过序列号、确认应答、重传和超时机制等方法来确保数据传输的可靠性。它可以处理丢失、乱序或重复的数据，并保证数据的正确性和顺序性。</p></li><li class="lvl-3"><p>流量控制和拥塞控制：TCP通过滑动窗口和拥塞控制算法来控制数据的发送速率，以防止网络拥塞和接收方不堪重负。</p></li><li class="lvl-3"><p>面向字节流：TCP将应用层的数据作为字节流进行传输，不保留应用程序发送数据的边界。接收端会将接收到的字节流重新组装成应用层可用的数据。(<strong>分段)</strong></p></li><li class="lvl-3"><p>较慢的连接建立和关闭：与UDP相比，TCP需要进行三次握手和四次挥手的连接建立和关闭过程，这增加了一定的延迟。</p></li><li class="lvl-3"><p><strong>全双工通信</strong></p></li><li class="lvl-3"><p>只能<strong>一对一</strong></p></li></ol><h4 id="以下是一个使用RFC标准格式的TCP头的示例代码块：">以下是一个使用RFC标准格式的TCP头的示例代码块：</h4><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span>                   <span class="number">1</span>                   <span class="number">2</span>                   <span class="number">3</span></span><br><span class="line"> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="operator">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="operator">|</span>          <span class="variable">Source</span> <span class="variable">Port</span>          <span class="operator">|</span>       <span class="variable">Destination</span> <span class="variable">Port</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="operator">|</span>                        <span class="built_in">Sequence</span> <span class="built_in">Number</span>                        <span class="operator">|</span></span><br><span class="line"><span class="operator">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="operator">|</span>                    <span class="variable">Acknowledgment</span> <span class="built_in">Number</span>                      <span class="operator">|</span></span><br><span class="line"><span class="operator">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="operator">|</span>  <span class="variable">Data</span> <span class="operator">|</span>           <span class="operator">|</span><span class="variable">U</span><span class="operator">|</span><span class="variable">A</span><span class="operator">|</span><span class="variable">P</span><span class="operator">|</span><span class="variable">R</span><span class="operator">|</span><span class="variable">S</span><span class="operator">|</span><span class="variable">F</span><span class="operator">|</span>                               <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="built_in">Offset</span><span class="operator">|</span> <span class="variable">Reserved</span>  <span class="operator">|</span><span class="variable">R</span><span class="operator">|</span><span class="built_in">C</span><span class="operator">|</span><span class="variable">S</span><span class="operator">|</span><span class="variable">S</span><span class="operator">|</span><span class="variable">Y</span><span class="operator">|</span><span class="built_in">I</span><span class="operator">|</span>            <span class="variable">Window</span>             <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="operator">|</span>           <span class="operator">|</span><span class="variable">G</span><span class="operator">|</span><span class="built_in">K</span><span class="operator">|</span><span class="variable">H</span><span class="operator">|</span><span class="variable">T</span><span class="operator">|</span><span class="built_in">N</span><span class="operator">|</span><span class="built_in">N</span><span class="operator">|</span>                               <span class="operator">|</span></span><br><span class="line"><span class="operator">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="operator">|</span>           <span class="variable">Checksum</span>            <span class="operator">|</span>         <span class="variable">Urgent</span> <span class="variable">Pointer</span>        <span class="operator">|</span></span><br><span class="line"><span class="operator">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br><span class="line"><span class="operator">|</span>                    <span class="built_in">Options</span>                    <span class="operator">|</span>    <span class="built_in">Padding</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span></span><br></pre></td></tr></table></figure><p>在上述代码块中，我们可以看到TCP头的结构，具体字段如下：</p><ul class="lvl-0"><li class="lvl-2"><p>Source Port：16位字段，表示源端口号，标识发送方的应用程序或进程。</p></li><li class="lvl-2"><p>Destination Port：16位字段，表示目标端口号，标识接收方的应用程序或进程。</p></li><li class="lvl-2"><p>Sequence Number：32位字段，用于对TCP数据流中的字节进行编号，用于排序和重组数据。</p></li><li class="lvl-2"><p>Acknowledgment Number：32位字段，表示期望接收方接收到的下一个字节的编号。用于确认已经成功接收到的数据。</p><div class="tips"><p>注意这里的编号是面对字节流而不是报文,所以在下面滑动窗口里,下一个包的ACK是上一个包的ACK加上接收包的报文长度</p></div></li><li class="lvl-2"><p>Data Offset：4位字段，表示TCP头的长度，以32位字（4字节）为单位。</p></li><li class="lvl-2"><p>Reserved：6位字段，保留位，未使用，必须为0。</p></li><li class="lvl-2"><p>Control Flags：6位字段，包括URG（紧急数据标志）、ACK（确认标志）、PSH（推送标志）、RST（重置标志）、SYN（同步标志）和FIN（结束标志）。</p></li><li class="lvl-2"><p>Window：16位字段，表示接收窗口大小，用于流量控制。</p></li><li class="lvl-2"><p>Checksum：16位字段，用于校验TCP头和数据的完整性。校验和的计算涉及TCP头、TCP数据以及伪首部的部分。</p></li><li class="lvl-2"><p>Urgent Pointer：16位字段，指示紧急数据的位置，仅在URG标志被设置时有效。</p></li><li class="lvl-2"><p>Options：可变长度字段，用于携带可选的TCP选项，如最大段大小（MSS）、窗口扩大因子等。</p></li><li class="lvl-2"><p>Padding：可变长度字段，用于填充，以保证TCP头长度是32位字的倍数。</p></li></ul><h4 id="面向流">面向流</h4><img src="/img/network/week12.assets/image-20230522185158157.png" alt="image-20230522185158157" style="zoom: 80%;" /><ul class="lvl-0"><li class="lvl-2"><p>TCP 不关心应用进程一次把多长的报文发送到 TCP 缓存</p></li><li class="lvl-2"><p>TCP 对连续的字节流进行分段，形成 TCP</p></li></ul><h3 id="tcp的三次握手-四次挥手">tcp的三次握手,四次挥手</h3><p>TCP连接的握手过程通常称为&quot;三次握手&quot;。下面是简单的描述：</p><ol><li class="lvl-3"><p>第一次握手：客户端向服务器发送一个同步序列编号（SYN）标志的TCP数据包，表示客户端想要建立连接。客户端选择一个随机的初始序列号，并将其放在数据包中。</p></li><li class="lvl-3"><p>第二次握手：服务器接收到客户端发送的TCP数据包后，会回复一个带有确认序列编号（ACK）和同步序列编号（SYN）标志的数据包。服务器将确认序列编号设置为客户端的初始序列号加1，并选择自己的随机初始序列号。</p></li><li class="lvl-3"><p>第三次握手：客户端收到服务器发送的确认数据包后，会向服务器发送一个带有确认序列编号（ACK）标志的数据包，确认服务器的初始序列号。客户端将确认序列编号设置为服务器的初始序列号加1。</p></li></ol><p>通过这个三次握手过程，客户端和服务器都确认彼此已准备好进行通信，建立了可靠的TCP连接。</p><div class="tips"><p>我想,原理是双方通过序列编号互相确认传到哪了.</p></div><p>在关闭连接时，TCP使用四次挥手过程。下面是简单的描述：</p><ol><li class="lvl-3"><p>第一次挥手：当客户端决定关闭连接时，它发送一个带有结束（FIN）标志的数据包给服务器。客户端不再发送数据，但仍然可以接收数据。</p></li><li class="lvl-3"><p>第二次挥手：服务器接收到来自客户端的结束数据包后，会发送一个带有确认（ACK）标志的数据包给客户端，表示它已收到了结束请求。</p></li><li class="lvl-3"><p>第三次挥手：服务器发送一个带有结束（FIN）标志的数据包给客户端，表示服务器也准备关闭连接。服务器不再发送数据，但仍然可以接收数据。</p></li><li class="lvl-3"><p>第四次挥手：客户端收到服务器发送的结束数据包后，发送一个带有确认（ACK）标志的数据包给服务器，确认收到了结束请求。此时，客户端和服务器都完成了关闭连接的过程。</p></li></ol><div class="tips"><p>我想,原理是双方FIN后不立即停止接受,这样保证了不错过.</p><p>FIN后得不到确认,过一段时间自己终止.</p></div><h3 id="拥塞">拥塞</h3><ul class="lvl-0"><li class="lvl-2"><p>当 短暂发生 输入&gt; 输出 速率时， 利用队列吸收突发到来的分组</p></li><li class="lvl-3"><p>但是如果 输入&gt;输出 速率持续存在，队列将溢出，即发生拥塞</p></li></ul><p>➢网络层<strong>见证</strong>拥塞<br>• 只有它可以提供直接反馈<br>➢传输层<strong>导致</strong>拥塞<br>• 只有它可以减少提供的负载</p><h4 id="最大-最小公平分配">最大-最小公平分配</h4><div class="danger"><p>计算:</p></div><ol><li class="lvl-3"><p>所有流量从速率为0开始</p></li><li class="lvl-3"><p>增加流量，直到网络中出现新的瓶颈</p></li><li class="lvl-3"><p>固定瓶颈流量的速率</p></li><li class="lvl-3"><p>转到步骤2，查看是否有剩余流量</p></li></ol><h4 id="TCP拥塞控制">TCP拥塞控制</h4><ol><li class="lvl-3"><p><strong>慢启动</strong>（Slow Start）：在TCP连接刚建立时，发送方会以较小的拥塞窗口（Congestion Window）开始发送数据。然后，每当收到一个确认（ACK）时，拥塞窗口会按指数增加，这导致发送方逐渐加大发送的数据量。</p></li><li class="lvl-3"><p>拥塞避免（Congestion Avoidance）：当拥塞窗口达到一个阈值（拥塞避免阈值）时，发送方会采用<strong>线性增加</strong>的方式增加拥塞窗口，而不是指数增加。这有助于避免过快地占用网络资源，以减少拥塞的发生。</p></li><li class="lvl-3"><p>快速重传（Fast Retransmit）：如果发送方连续收到3个重复的确认，这表明有一个数据包丢失，发送方会立即重传该数据包，而不必等待超时。</p><div class="tips"><p>重复的ACK：当接收方收到乱序的数据包时，它会发送重复的ACK，其中确认序列号与之前已经确认过的数据包的序列号相同。这是因为接收方只需告知发送方它已经收到数据，并期望接收(按照顺序的)下一个数据包。</p><p>接收方只在收到连续的、按顺序的数据包时才会发送连续的ACK。如果发送方接收到重复的ACK，意味着接收方收到了后续的数据包，但未收到之前的某个数据包。</p></div></li><li class="lvl-3"><p><strong>快速恢复</strong>（Fast Recovery）：在进行快速重传后，发送方会将<strong>拥塞窗口减半</strong>，然后逐渐增加。这有助于减少拥塞的影响，并在不必等待超时的情况下恢复发送速率。</p></li><li class="lvl-3"><p>拥塞超时（Timeout）：如果发送方在一段时间内没有收到确认，就认为有一个数据包丢失，并将拥塞窗口减半，然后重新开始慢启动过程。</p></li></ol><div class="tips"><p>拥塞窗口(CWND congestion window)的目标是带宽延迟乘积（Bandwidth Delay Product）</p><p>带宽延迟乘积在 TCP 拥塞控制中用于确定合适的发送窗口大小。它由网络链路的带宽和往返时延（Round-Trip Time，RTT）的乘积得出。带宽延迟乘积代表了在网络链路中可以容纳的未确认数据量。通过设置拥塞窗口大小为带宽延迟乘积，TCP 可以在不超过链路容量的情况下充分利用网络带宽。</p><p>具体来说，带宽延迟乘积等于链路的传输速率（以比特/秒为单位）乘以 RTT（以秒为单位）。例如，如果链路的带宽是 1 Mbps，RTT 是 100 毫秒，那么带宽延迟乘积就是 1 Mbps * 0.1 秒 = 100,000 比特。这意味着 TCP 发送窗口的大小应该与此相当，以便充分利用链路容量。</p></div><p><strong>AIMD</strong>是加法增大乘法减小的缩写，是一种用于TCP拥塞控制的算法<a href="https://finisky.github.io/2019/11/17/aimdapp/">1</a>它的基本思想是：当网络没有出现拥塞时，就逐渐增大拥塞窗口，使发送速率按线性规律增长；当网络出现拥塞时，就大幅减小拥塞窗口，使发送速率按指数规律下降<a href="https://zh.wikipedia.org/wiki/%E5%92%8C%E6%80%A7%E5%A2%9E%E9%95%BF/%E4%B9%98%E6%80%A7%E9%99%8D%E4%BD%8E">2</a>AI和MD分别指的是加法增大和乘法减小的过程。加法增大是指每经过一个往返时间RTT，就把拥塞窗口增加一个最大报文段的大小；乘法减小是指当发生超时或连续三个重复确认时，就把拥塞窗口减半</p><table><thead><tr><th>客户端状态名</th><th>客户端状态解释</th><th>服务器端状态名</th><th>服务器端状态解释</th></tr></thead><tbody><tr><td>CLOSED</td><td>初始状态，没有活动的TCP连接</td><td>CLOSED</td><td>初始状态，没有活动的TCP连接</td></tr><tr><td>SYN_SENT</td><td>客户端发送SYN报文请求建立连接</td><td>SYN_RECEIVED</td><td>服务器端接收到SYN报文，等待对应的ACK报文</td></tr><tr><td>ESTABLISHED</td><td>连接已建立，双方可以传输数据</td><td>ESTABLISHED</td><td>连接已建立，双方可以传输数据</td></tr><tr><td>FIN_WAIT_1</td><td>客户端发送了连接释放请求（FIN报文）</td><td>CLOSE_WAIT</td><td>服务器端接收到连接释放请求（FIN报文）</td></tr><tr><td>FIN_WAIT_2</td><td>客户端接收到服务器端的连接释放确认（ACK报文）</td><td>LAST_ACK</td><td>服务器端发送了（FIN报文），等待关闭</td></tr><tr><td>TIME_WAIT</td><td>收到服务器端的（FIN报文）等待可能的延迟报文重传结束</td><td>LAST_ACK</td><td></td></tr><tr><td>CLOSED</td><td>连接已关闭，无活动的TCP连接</td><td>CLOSED</td><td>收到客户端的ACK,连接已关闭，无活动的TCP连接</td></tr></tbody></table><ol><li class="lvl-3"><p>主动关闭：主动关闭是指发起关闭连接的一方，通常是客户端。在主动关闭中，客户端发送连接释放请求（FIN报文），并等待服务器端的确认（ACK报文）。主动关闭的一方会主动发起关闭操作，即主动发送关闭请求。</p></li><li class="lvl-3"><p>被动关闭：被动关闭是指接收到关闭请求的一方，通常是服务器端。在被动关闭中，服务器端接收到客户端发送的连接释放请求（FIN报文），并发送确认（ACK报文）。被动关闭的一方会被动地接受关闭请求，并发送确认响应。</p></li></ol><h3 id="ACK时钟">ACK时钟</h3><p>滑动窗口的 ACK 时钟是指在 TCP 协议中，接收方使用的一种机制，用于确定何时发送确认（ACK）以确认已接收的数据。</p><p>在 TCP 的滑动窗口协议中，接收方会维护一个接收窗口（Receive Window），用于指示发送方可以发送的数据量。发送方根据接收方的接收窗口大小来确定发送的数据量，并将数据分成多个数据段发送。</p><p>接收方收到数据后，会使用 ACK 时钟来决定何时发送确认。ACK 时钟是一个计时器，接收方会在收到数据后启动该计时器。计时器的持续时间通常是一个较小的时间间隔，例如几毫秒。</p><p>接收方会在 ACK 时钟计时器到期之前收集接收到的数据，并将一个确认（ACK）发送给发送方。这样可以减少确认的数量，并提高传输效率。当 ACK 时钟到期时，接收方会发送确认，即使接收窗口中还有一些数据尚未完全接收。</p><p>通过使用 ACK 时钟，接收方可以尽量将多个 ACK 集中发送，以减少网络中的确认流量。这有助于提高网络的利用率和传输效率。</p><div class="tips"><p>ACK保持确定的速率传回发送端  (这个速率基本撒谎给你等于最慢链路的速率,这样链路中的队列就不存在了,传输更加稳定.)</p></div><div class="danger"><p>计算:TCP拥塞控制</p><p>• 例如，网络： 10Mbps， RTT=100ms<br>• 目标：拥塞窗口cwnd = 带宽延迟积 =10×0.1= 1Mb = 网络中能够承载的数据量</p><blockquote><p>或者说,速率大致为 cwnd/RTT</p></blockquote></div><h1>传输层进阶</h1><div class="tips"><p>我估计主要是了解…可以对比着知道每一种新协议采取什么手段解决了什么问题大概就ok了</p></div><h2 id="拥塞控制">拥塞控制</h2><h3 id="原有tcp拥塞控制有什么问题">原有tcp拥塞控制有什么问题?</h3><ul class="lvl-0"><li class="lvl-2"><h5 id="tahoe-重新慢启动–-下凸">tahoe:重新慢启动–&gt;下凸</h5></li><li class="lvl-2"><h5 id="reno-MD-窗口减半–-锯齿状">reno MD:窗口减半–&gt;锯齿状</h5></li></ul><p>如果带宽时延积(BDP)比较大,加性探测时间较长,窗口呈锯齿状,很多带宽未利用</p><p>考虑TCP-BIC</p><h3 id="TCP-BIC-Binary-Increase-Congestio–-上凸">TCP-BIC: Binary Increase Congestio–&gt;上凸</h3><p>折半查找,大大快于线性查找</p><h5 id="BIC存在带宽不公平性问题">BIC存在带宽不公平性问题</h5><p>BIC以ACK时钟驱动拥塞窗口的更新， RTT较短的连接会更快到达满载窗口，占据更多的带宽，产生不公平性问题（RTT-fairness）</p><h4 id="CUBIC">CUBIC</h4><p>不再根据RTT间隔调整窗口,而是将BIC连续化用三次函数拟合BIC算法曲线.</p><p>拥塞窗口从RTT的函数变成时间t的函数</p><h3 id="新的BDP-BBR">新的BDP:BBR</h3><p>BBR: Bottleneck Bandwidth and Round-trip time，</p><p>带宽时延积： BDP=BtlBw*RTprop</p><p>BBR的优化思路<br>• 试图测量最佳点（即BtlBw）<br>• 尽量将cwnd收敛到BtlBw<br>• 从而避免拥塞丢包和<strong>排队</strong></p><p>但是</p><h5 id="Max-BW和min-RTT不能同时被测得">Max BW和min RTT不能同时被测得</h5><p>• 要测最低延迟RTprop ，就要保证链路队列为空，网络中分组越少越好， cwnd较小<br>• 要测最大带宽BtlBw ， 就要把瓶颈链路填满，此时buffer中存在排队分组，延迟较高</p><h2 id="新型传输层协议QUIC">新型传输层协议QUIC</h2><p>建立相互独立的多个子流,一个子流数据包丢失不影响其他子流</p><p>以Connection ID识别连接，即使IP地址/端口发生变化也无需重连</p><h4 id="TCP存在的问题">TCP存在的问题</h4><p>RTO造成队头阻塞，严重降低传输性能  \</p><div class="tips"><p>RTO（Retransmission Time Out）是 TCP（传输控制协议）中的一个参数，用于确定在未收到确认的情况下，发送方重传数据的等待时间。</p></div><p>TCP多流复用加剧了队头阻塞</p><div class="tips"><p>如网页传输中，每个单独的图片即为一个数据流，不同数据流之间相互独立,为每个数据建立一个TCP连接很低效/因此出现了多流复用</p></div><p>多流复用时,任何一个流被阻塞所有流都会被阻塞</p><h4 id="QUIC解决方案">QUIC解决方案</h4><p>建立相互独立的多个子流,一个子流数据包丢失不影响其他子流</p><h4 id="TCP重传歧义">TCP重传歧义</h4><p>TCP的重传包使用和原包相同的序号,返回的ACK不能确定是对原包还是重传包,导致RTT计算错误.</p><h4 id="quic解决方案">quic解决方案</h4><p>• QUIC的packet number单调递增，对于重传包也会递增packet number， 避免RTO<br>• 每个packet number只会出现一次， ACK没有歧义！<br>• QUIC接收端记录收到包与发出ACK之间的时延，并发馈给发送端，方便发送端更准确地测量RTT</p><h4 id="TCP基于ip-端口">TCP基于ip:端口</h4><h4 id="QUIC基于connection-id">QUIC基于connection id</h4><p>• QUIC使用Connection ID来表示每个连接<br>• IP地址或端口的变化不影响对原有连接的识别<br>• 客户IP地址或端口发生变化时， QUIC可以快速恢复</p><p>支持wifi到数据的链接</p><h3 id="传输协议QUIC-小结">传输协议QUIC-小结</h3><h4 id="➢为什么需要QUIC：-TCP存在的问题">➢为什么需要QUIC： TCP存在的问题</h4><ul class="lvl-0"><li class="lvl-2"><p>• RTO队头阻塞问题，多流复用加剧</p></li><li class="lvl-2"><p>• TCP握手过程引入很大的时延</p></li><li class="lvl-2"><p>• 移动用户底层短连接，难以支撑上层业务的长连接</p></li><li class="lvl-2"><p>• 应用优化TCP的难度高</p></li></ul><h4 id="➢QUIC协议">➢QUIC协议</h4><ul class="lvl-0"><li class="lvl-2"><p>• 基于UDP在跨层优化的用户态实现</p></li><li class="lvl-2"><p>• 优化了TLS加密建连的握手过程</p></li><li class="lvl-2"><p>• 优化重传，包序号持续递增，避免RTO并实现精准RTT测量</p></li><li class="lvl-2"><p>• 以Connection ID识别连接，即使IP地址/端口发生变化也无需重连</p></li><li class="lvl-2"><p>• 各个流的传输相互独立，消除了队头阻塞问题</p></li></ul><h3 id="多路径传输协议MPTCP-小结">多路径传输协议MPTCP-小结</h3><h4 id="➢动机：-网络设备通常有多个接口">➢动机： 网络设备通常有多个接口</h4><h4 id="➢优势">➢优势</h4><p>• 带宽聚合、可靠性、平滑切换链路</p><h4 id="➢MPTCP连接管理">➢MPTCP连接管理</h4><p>• 基于TCP实现，单个路径上运行一个TCP流<br>• 未改变TCP头的基础定义，仅添加新的选项<br>• 连接过程：初始化、附加子流、路径管理、关闭连接</p><h4 id="➢MPTCP数据调度">➢MPTCP数据调度</h4><p>• 将属于同一个数据流的数据包调度到不同的路径上传输<br>• 降低数据乱序到达对网络性能产生的不利影响</p><blockquote><p>就是说,既然一个网络设备有多个接口,我就全用上,多一个总比少一个好</p></blockquote><h3 id="DC-Data-Center-TCP核心思想">DC(Data Center)TCP核心思想</h3><h4 id="➢根据交换机队列的瞬时长度标记ECN-Explicit-Congestion-Notification">➢根据交换机队列的瞬时长度标记ECN (Explicit Congestion Notification)</h4><p>• 使用显式的拥塞反馈能够更好地控制突发流量</p><h4 id="➢根据拥塞程度精细调整发送窗口">➢根据拥塞程度精细调整发送窗口</h4><p>• TCP: 𝑐𝑤𝑛𝑑 ← 𝑐𝑤𝑛𝑑/2<br>• DCTCP: 𝑐𝑤𝑛𝑑 ← 𝑐𝑤𝑛𝑑 × 1 - 𝛼/2<br>• 𝛼: 使用显示拥塞信号得到的“拥塞程度–+*47\</p><p>*±99999999999999999999999999999999</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>echart</title>
      <link href="/others/echart/"/>
      <url>/others/echart/</url>
      
        <content type="html"><![CDATA[<!DOCTYPE html><html>  <body>    <div id="main" style="width: 600px;height:600px;"></div><script type="text/javascript">  // 基于准备好的dom，初始化echarts实例  var myChart = echarts.init(document.getElementById('main'));  // 指定图表的配置项和数据      var option = {  tooltip: {    trigger: 'axis',    axisPointer: {      type: 'cross',      label: {        backgroundColor: '#6a7985'      }    }  },  legend: {    data: ['Email', 'Union Ads', 'Video Ads', 'Direct', 'Search Engine']  },  toolbox: {    feature: {      saveAsImage: {}    }  },  grid: {    left: '3%',    right: '4%',    bottom: '3%',    containLabel: true  },  xAxis: [    {      type: 'category',      boundaryGap: false,      data: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']    }  ],  yAxis: [    {      type: 'value'    }  ],  series: [    {      name: 'Email',      type: 'line',      stack: 'Total',      areaStyle: {},      emphasis: {        focus: 'series'      },      data: [120, 132, 101, 134, 90, 230, 210]    },    {      name: 'Union Ads',      type: 'line',      stack: 'Total',      areaStyle: {},      emphasis: {        focus: 'series'      },      data: [220, 182, 191, 234, 290, 330, 310]    },    {      name: 'Video Ads',      type: 'line',      stack: 'Total',      areaStyle: {},      emphasis: {        focus: 'series'      },      data: [150, 232, 201, 154, 190, 330, 410]    },    {      name: 'Direct',      type: 'line',      stack: 'Total',      areaStyle: {},      emphasis: {        focus: 'series'      },      data: [320, 332, 301, 334, 390, 330, 320]    },    {      name: 'Search Engine',      type: 'line',      stack: 'Total',      label: {        show: true,        position: 'top'      },      areaStyle: {},      emphasis: {        focus: 'series'      },      data: [820, 932, 901, 934, 1290, 1330, 1320]    }  ]};  // 使用刚指定的配置项和数据显示图表。  myChart.setOption(option);  // 刷新调整  window.onresize = function () {    myChart.resize();  }</script>  </body></html>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> comment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DLC12</title>
      <link href="/notes/DLC/week12/"/>
      <url>/notes/DLC/week12/</url>
      
        <content type="html"><![CDATA[<h1>t</h1><h1>同步时序电路的分析与设计方法</h1><ul class="lvl-0"><li class="lvl-2"><p>作原始状态表👈</p><blockquote><p>就是一大状态机？</p></blockquote></li><li class="lvl-2"><p>化简原始状态表</p><blockquote><p>就是自动机化简?</p></blockquote></li><li class="lvl-2"><p>求出激励函数</p><blockquote><p>根据化简后的状态机给出$input,Q_i与Q_i’$的关系</p><p>从而反推出$D_i$,(对于JK触发器,当然是$J_i,K_i$)</p><p>给一个JK触发器的表?–&gt;easy实际上也就是4种情况.不难</p><p>卡诺图,给出$D_i与input,Q_i$之间的关系</p></blockquote></li><li class="lvl-2"><p>画逻辑图</p><blockquote><p>给出$D_i与input,Q_i$之间的关系后,用组合逻辑电路表达这个关系</p></blockquote></li></ul><h3 id="设计计数器时应该注意的问题">设计计数器时应该注意的问题</h3><ul class="lvl-0"><li class="lvl-2"><p>将技术循环外的状态修改后,自动进入计数循环/</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
          <category> DLC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DLC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>network-E3</title>
      <link href="/homework/network/network-E3/"/>
      <url>/homework/network/network-E3/</url>
      
        <content type="html"><![CDATA[<h1>网原第三次小实验</h1><p>郭高旭 2021010803 <a href="mailto:ggx21@mails.tsinghua.edu.cn">ggx21@mails.tsinghua.edu.cn</a></p><h2 id="抓包实验-1：">抓包实验 1：</h2><img src="/img/homeworks/network-E3.assets/image-20230508182726680.png" alt="image-20230508182726680" style="zoom: 80%;" /><p>Type字段为11，Code字段为0</p><h2 id="抓包实验2">抓包实验2</h2><h3 id="观察ICMPv4请求">观察ICMPv4请求</h3><img src="/img/homeworks/network-E3.assets/image-20230508184458514.png" alt="image-20230508184458514" style="zoom:67%;" /><p>Type字段是8，Code是0</p><h3 id="观察回显数据包头">观察回显数据包头</h3><img src="/img/homeworks/network-E3.assets/image-20230508184710176.png" alt="image-20230508184710176" style="zoom:67%;" /><p>Type字段为0，Code字段也为0</p><h3 id="观察一对请求和回显">观察一对请求和回显</h3><img src="/img/homeworks/network-E3.assets/image-20230508185019527.png" alt="image-20230508185019527" style="zoom:67%;" /><p>标识符，序号，Data都相等</p><h2 id="抓包实验-3：-观察-ARP-分组各式">抓包实验 3： 观察 ARP 分组各式</h2><h3 id=""><img src="/img/homeworks/network-E3.assets/image-20230508185440661.png" alt="image-20230508185440661"></h3><ol><li class="lvl-3"><p>ARP 协议在以太网帧头中载荷类型的编号是 ？</p><img src="/img/homeworks/network-E3.assets/image-20230508185700796.png" alt="image-20230508185700796" style="zoom:67%;" /><p>答：0x0806</p></li><li class="lvl-3"><p>ARP 分组头中，以太网硬件类型编号和 IP 协议类型编号分别是？</p><img src="/img/homeworks/network-E3.assets/image-20230508185717796.png" alt="image-20230508185717796" style="zoom:67%;" /><p>答：   arp.hw.type（Hardware type）：1；protocol type 0x0800</p></li><li class="lvl-3"><p>ARP 请求分组中，操作码（Opcode）值是？源 IP 地址及 MAC地址，目的 IP 地址及 MAC 地址是多少？</p>  <img src="/img/homeworks/network-E3.assets/image-20230508185831466.png" alt="image-20230508185831466" style="zoom:67%;" /><ul class="lvl-2"><li class="lvl-5"><p>Opcode是1，</p></li><li class="lvl-5"><p>源IP和MAC地址是本机地址</p></li><li class="lvl-5"><p>目的IP地址是请求的IP地址；MAC地址是广播地址</p></li></ul></li><li class="lvl-3"><p>ARP 回复分组中，操作码（Opcode）值是？源 IP 地址及 MAC地址，目的 IP 地址及 MAC 地址是多少？</p><img src="/img/homeworks/network-E3.assets/image-20230508185731913.png" alt="image-20230508185731913" style="zoom:80%;" /><p>答：</p><ul class="lvl-2"><li class="lvl-5"><p>Opcode是2</p></li><li class="lvl-5"><p>源IP和MAC是请求的IP地址和回复的MAC</p></li><li class="lvl-5"><p>目的IP和MAC是本机</p></li></ul></li></ol><h2 id="简述题：">简述题：</h2><h3 id="icmpv4的安全隐患">icmpv4的安全隐患</h3><ol><li class="lvl-3"><p>Ping Flood 攻击：黑客可以发送大量的 Ping 请求（ICMP Echo Request），导致被攻击的目标主机网络堵塞，以至于无法正常通信。</p></li><li class="lvl-3"><p>Smurf 攻击：黑客可以利用广播地址发送 ICMPv4 Request，让目标网络中的所有主机都回应，导致目标网络瘫痪。</p></li><li class="lvl-3"><p>ICMPv4 Redirect 攻击：黑客可以伪造 ICMPv4 Redirect 消息，使目标主机将数据包发送到攻击者的设备上，从而实现中间人攻击。</p></li><li class="lvl-3"><p>ICMPv4 Time Exceeded 攻击：黑客可以发送大量 ICMPv4 Time Exceeded 消息，让目标网络的路由器被迫处理大量无用信息而瘫痪。</p></li><li class="lvl-3"><p>Ping of Death 攻击：黑客可以向目标主机发送一个特别制作的超大 ICMPv4 报文（超过 65536 字节），导致目标主机崩溃或者重启。</p></li></ol><p>处于上述安全问题，很多系统都默认禁止发送某些icmpv4消息。比如</p><ol><li class="lvl-3"><p>Cisco 路由器默认情况下会禁止发送 ICMP Redirect 消息，以避免中间人攻击。</p></li><li class="lvl-3"><p>Solaris 操作系统默认情况下会禁止发送 ICMPv4 Timestamp 和 ICMPv4 Address Mask 消息。</p></li><li class="lvl-3"><p>Windows 防火墙默认情况下会阻止多个 ICMPv4 消息，比如 ICMP Echo Request（ping）、ICMP Timestamp，ICMP Traceroute 等。</p></li></ol><h3 id="ping-局域网内外的主机产生的arp报文有何不同">ping 局域网内外的主机产生的arp报文有何不同</h3><p>这是我ping局域网内（连接到我同一个路由器的ipad设备）的arp</p><p><img src="/img/homeworks/network-E3.assets/image-20230508192914176.png" alt="image-20230508192914176"></p><p>ping局域网外的主机不会产生arp报文。arp的作用范围在局域网内。</p><h3 id="arp滥用的危害及预防">arp滥用的危害及预防</h3><h4 id="arp滥用的例子">arp滥用的例子</h4><ol><li class="lvl-3"><p>网络拥塞：过量的 ARP 请求会增加网络的负载，导致网络拥塞，从而影响网络性能和吞吐量。</p></li><li class="lvl-3"><p>ARP 洪泛攻击：攻击者利用大量伪造的 ARP 请求数据包向网络广播，欺骗物理地址表中的信息，从而导致网络拥塞或服务故障，影响网络安全。</p></li><li class="lvl-3"><p>ARP 欺骗攻击：攻击者伪造 ARP 请求数据包，使其包含正确的 IP 地址和错误的 MAC 地址。当 ARP 请求被接收并响应时，攻击者就能欺骗网络设备，从而执行中间人攻击，获取敏感信息，甚至劫持通信。</p></li></ol><h4 id="预防">预防</h4><ol><li class="lvl-3"><p>监控网络流量：使用网络分析工具监测网络流量，识别异常的 ARP 请求和响应，判断是否存在 ARP 洪泛攻击或 ARP 欺骗攻击。</p></li><li class="lvl-3"><p>过滤不必要的广播：在网络设备上设置合理的 ACL（访问控制列表），过滤不必要的广播。例如，可以限制 ARP 请求的范围，只允许目标设备响应有效的 ARP 请求。</p></li><li class="lvl-3"><p>配置静态 ARP 表项：在网络设备上配置静态 ARP 表项，避免频繁地进行 ARP 请求，降低网络负载和运行的安全风险。</p></li><li class="lvl-3"><p>使用防火墙：在网络的边界处使用防火墙，限制不必要的 ARP 请求和回应，防止 ARP 洪泛攻击和 ARP 欺骗攻击。</p></li><li class="lvl-3"><p>更新网络设备和操作系统：最新版本的网络设备和操作系统中会修复已知的安全漏洞，更新这些设备和系统可以降低不必要的攻击和风险。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> homework </category>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> homework </tag>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>network-homework-10</title>
      <link href="/homework/network/network10/"/>
      <url>/homework/network/network10/</url>
      
        <content type="html"><![CDATA[<h1>网原第10次作业</h1><p>郭高旭 2021010803 <a href="mailto:ggx21@mails.tsinghua.edu.cn">ggx21@mails.tsinghua.edu.cn</a></p><h2 id="第一题">第一题</h2><blockquote><p>这是否意味着虚电路网络不需要具备将单个数据包从任意源端路由到任意接收方的能力呢？</p></blockquote><p>答:不是,如果某一源端路由到某一接收方没有建立虚电路.对于这单个数据包仍然要进行虚电路入口到出口的路由选择。</p><h2 id="第二题">第二题</h2><blockquote><p>设网络采用区分服务模型。考虑使用加速转发服务的用户。试问是否可以保证加速型数据包比常规数据包的延迟更短？为什么是，或者为什么不是？</p></blockquote><p>答:不一定能保证.</p><p>区分服务模型可能为加速转发服务预留一些带宽,所以加速型数据包通常延迟较短.</p><p>但实际情况比较复杂,不能保证加速型数据包延迟一定短,比如:</p><ul class="lvl-0"><li class="lvl-2"><p>区分服务模型为加速转发服务预留的带宽较小.</p></li><li class="lvl-2"><p>同时使用加速转发服务的用户非常多,导致网络拥塞.</p></li><li class="lvl-2"><p>常规数据包经过路径较短</p></li><li class="lvl-2"><p>链路质量、网络设备性能等因素的影响</p></li></ul><h2 id="第三题">第三题</h2><blockquote><p>IPv6 使用 16 个字节的地址。如果每隔 ps 就分配掉一百万个地址，试问整个地址空间可以持续分配多久？</p></blockquote><p>答:16个字节约有$2^{128}\approx 10<sup>{38.4}$个地址,可以分配$10</sup>{32.4}ps \approx 2.5\times 10^ {20}s \approx 10^{13}y$</p><p>大概能分配10万亿年</p><h2 id="第四题">第四题</h2><blockquote><p>IPv6 协议被引入时， ARP 协议需要作相应的改变吗？如果需要，这种改变是概念性的还是技术性的</p></blockquote><p>答:技术上的改变.</p><p>arp协议的作用是将IP翻译成MAC.概念上不发生变化.</p><p>但是IPV6的地址变长了,所以ARP协议需要区分IPv6与IPv4</p>]]></content>
      
      
      <categories>
          
          <category> homework </category>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> homework </tag>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Somniloquy-5</title>
      <link href="/Somniloquy/dream-5/"/>
      <url>/Somniloquy/dream-5/</url>
      
        <content type="html"><![CDATA[<p>这是什么?<a href="/2023/04/28/Somniloquy/dream-0/">这篇README</a>大概也不能告诉你.</p><h2 id="01：30">01：30</h2><p>又是熬夜debug的一天。</p><p>头痛，哥几个在边上叽叽喳喳，为了明天的ddl而烦恼。</p><p>我在为什么烦恼呢？</p><img src="/img/dream-5.assets/43c413a0eb28b8022006e3ad03c3d6a.jpg" alt="43c413a0eb28b8022006e3ad03c3d6a" style="zoom: 33%;" /><img src="/img/dream-5.assets/494e46ac3c5119e636969a698a2db8b.jpg" alt="494e46ac3c5119e636969a698a2db8b" style="zoom:33%;" /><p>算了，睡觉吧</p><h2 id="3：30">3：30</h2><p>真没睡。。。</p><p>昨天猛干，到了4：30//</p><p>实际上效率很低，虽然没有分心，但是制造了好多bug。让我一直de了两天，或许写c++时头脑应该清醒点，，，毕竟和python不一样</p><img src="/img/dream-5.assets/7cb34bbc4c9add0cae53bfb77b3e868.jpg" alt="7cb34bbc4c9add0cae53bfb77b3e868" style="zoom:33%;" /><p>想起多年前的这个清晨。。。</p><h2 id="13：00">13：00</h2><p>她等了我，和我一起来了，但是抛下我走了。</p><p>但我是赚了的，至少我学了一下午，还de完了bug</p><p>她走是她的事，，，</p><p>我不理解//</p><p>也许陌生人也不行，她还是走了。我迟了一步、、</p><p>图书馆坐坐真不错。</p><img src="/img/dream-5.assets/3c294bef447dc6b43036c9928459409.jpg" alt="3c294bef447dc6b43036c9928459409" style="zoom: 33%;" /><p>我想给人分享我的喜悦，好久没有体验过一点点成就感了。。。</p><p>环顾了四周还是算了。给妈妈打个电话吧</p><h2 id="17：00">17：00</h2><img src="/img/dream-5.assets/6f078288c956c220d3a3cc1bf01567f.jpg" alt="6f078288c956c220d3a3cc1bf01567f" style="zoom:33%;" /><img src="/img/dream-5.assets/4cab0fe65c6b43b98bb202a27577717.jpg" alt="4cab0fe65c6b43b98bb202a27577717" style="zoom:33%;" /><p>工字厅门口这小树林真不错，以后多来散散心。</p><p>还是能约到人一起吃饭的，开心。</p><h2 id="18：30">18：30</h2><p>吃完饭发现又有新的作业了，没那么开心了。。。。</p><h2 id="23：00">23：00</h2><img src="/img/dream-5.assets/a6b8f7fbc8862d86f2244427dcbd9d1.jpg" alt="a6b8f7fbc8862d86f2244427dcbd9d1" style="zoom:33%;" /><p>relax</p><p>😋😋😋</p><p>陈粒好贵，而且这一对比那一对还少400</p>]]></content>
      
      
      <categories>
          
          <category> Somniloquy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> THU </tag>
            
            <tag> Somniloquy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cobra</title>
      <link href="/others/cobra/"/>
      <url>/others/cobra/</url>
      
        <content type="html"><![CDATA[<!DOCTYPE html><html>  <head>    <title>Snake Game</title>    <style>      html, body {        overflow: hidden;      }      body {        display: flex;        justify-content: center;        align-items: center;        height: 100vh;        overflow: hidden;      }      canvas {        border: 1px solid black;        background-color: #f2f2f2;        font-family: Arial, sans-serif;      }    </style>  </head>  <body>    <canvas id="canvas" width="400" height="400"></canvas>    <script src="/js/snake.js"></script>  </body></html>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> game </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2048</title>
      <link href="/others/game-2048/"/>
      <url>/others/game-2048/</url>
      
        <content type="html"><![CDATA[<!DOCTYPE html><html lang="en">  <head>    <meta charset="UTF-8" />    <title>2048 Game</title>    <link rel="stylesheet" type="text/css" href="/2048/style.css" />  </head>  <body>    <div class="container">      <div class="header">        <h1>2048 Game</h1>        <div class="score">Score: <span id="score">0</span></div>      </div>      <div class="game-grid"></div>      <div class="game-over">        <p>Game Over!</p>        <button id="retry" onclick="restartGame()">Retry</button>      </div>    </div>    <script src="/2048/app.js"></script>  </body></html>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> game </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Somniloquy-4</title>
      <link href="/Somniloquy/dream-4/"/>
      <url>/Somniloquy/dream-4/</url>
      
        <content type="html"><![CDATA[<p>这是什么?<a href="/2023/04/28/Somniloquy/dream-0/">这篇README</a>大概也不能告诉你.</p><h2 id="22：18">22：18</h2><p>昨天去爬了香山。</p><p>在双清公寓坐了一会儿，有一搭没一搭地聊着。感觉很是惬意。</p><p>以后可以多去，远离屏幕远离人群</p><p>没被她从山上推下去，真是万幸。。。</p><img src="\img\dream-4\1.jpg" style="zoom: 25%;" /><img src="\img\dream-4\2.jpg" style="zoom: 25%;" /><img src="\img\dream-4\3.jpg" style="zoom: 25%;" /><p>今天起了床就写ai-pa2的文档，写了一天，啥也没干。现在是写作业呢还是开摆呢？</p><h2 id="19：00">19：00</h2><p>柯洁这棋都能输？打出那一勺后是什么感觉呢？尝试搅局的时候又是什么感觉。</p><h2 id="23：00">23：00</h2><h3 id="dd丢了">dd丢了</h3><p>dd走丢了，他去哪里了呢？她妈妈报了警。等一等看看警察叔叔是不是要来把我们抓走了。<br><img src="\img\dream-4\4.jpg" style="zoom: 25%;" /></p>]]></content>
      
      
      <categories>
          
          <category> Somniloquy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> THU </tag>
            
            <tag> Somniloquy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人智导PA2实验报告</title>
      <link href="/notes/pytorch/pa2report/"/>
      <url>/notes/pytorch/pa2report/</url>
      
        <content type="html"><![CDATA[<ul class="lvl-0"><li class="lvl-2"><p><a href="https://github.com/Ggx21/IAI2">作业仓库</a></p></li><li class="lvl-2"><p><a href="https://ggx21.github.io/2023/05/03/notes/pytorch/learn_torch/">pytorch学习笔记</a></p></li><li class="lvl-2"><p><a href="https://cloud.tsinghua.edu.cn/f/91b9791557cb4e1f9821/">代码文件</a></p></li></ul><p>本次实验实现了下面的module</p><table><thead><tr><th>模型名称</th><th>测试准确率</th><th>测试f值</th></tr></thead><tbody><tr><td>CNN_simple</td><td>83.46%</td><td>0.8322</td></tr><tr><td>CNN_complex</td><td>81.75%</td><td>0.8167</td></tr><tr><td>RNN</td><td>82.54%</td><td>0.8247</td></tr><tr><td>DenseNet</td><td>75.95%</td><td>0.7546</td></tr><tr><td>ResNet</td><td>77.43%</td><td>0.7725</td></tr><tr><td>LSTM</td><td>80.21%</td><td>0.8010</td></tr><tr><td>BiLSTM</td><td>81.68%</td><td>0.8158</td></tr><tr><td>GoogLeNet</td><td>74.40%</td><td>0.7367</td></tr><tr><td>MLP</td><td>70.94%</td><td>0.7047</td></tr><tr><td>MLP_with_Dropout</td><td>74.82%</td><td>0.7464</td></tr></tbody></table><h2 id="0-实验流程">0.实验流程</h2><h3 id="文件结构图">文件结构图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">D:.</span><br><span class="line"></span><br><span class="line">│  dataprocess.py#------数据预处理</span><br><span class="line">│  DLongpu.py#-----------main.py</span><br><span class="line">│  module.py#---储存,调用module的类</span><br><span class="line">│</span><br><span class="line">├─Dataset#提供的数据</span><br><span class="line">│      test.txt</span><br><span class="line">│      train.txt</span><br><span class="line">│      validation.txt</span><br><span class="line">│      wiki_word2vec_50.bin</span><br><span class="line">│      word_freq.txt</span><br><span class="line">├─input#预处理后的数据</span><br><span class="line">│      test_input.pkl</span><br><span class="line">│      train_input.pkl</span><br><span class="line">│      validation_input.pkl</span><br><span class="line">│      word2vec.pkl</span><br><span class="line">│</span><br><span class="line">├─module#储存的模型</span><br><span class="line">│      BiLSTM.pkl</span><br><span class="line">│      CNN_complex.pkl</span><br><span class="line">│      CNN_simple.pkl</span><br><span class="line">│      ...</span><br><span class="line">|</span><br><span class="line">├─plot#生成的图片</span><br><span class="line">│      all_acc_F1.png</span><br><span class="line">|...</span><br></pre></td></tr></table></figure><h3 id="执行过程">执行过程</h3><h4 id="一-数据预处理-DataProcesser-类">一.数据预处理:<strong>DataProcesser</strong>()类</h4><ol><li class="lvl-3"><p>构建词表vocab:</p><ul class="lvl-2"><li class="lvl-5">取得词频表,保留出现频率高于treshold(我取了10,一共获得8072个词)的词</li><li class="lvl-5">为词频表中的词建立索引</li><li class="lvl-5">对于词频表中每一个词,利用提供的转换文件,转换为50维词向量(如果转换表中没有这个词,我的做法是随机一个,实际上由于我们只保留了一定出现频率的词,没有出现过的词占比很少,对结果影响不大)</li></ul></li><li class="lvl-3"><p>读取句子:</p><ul class="lvl-2"><li class="lvl-5">读取句子,记录label与commet</li><li class="lvl-5">通过索引,将comment从词列表转化为索引列表(如果没有索引,转换成pad_char对应的id,这里把中性词&quot;把&quot;作为pad_char)</li><li class="lvl-5">统一句子长度:<ul class="lvl-4"><li class="lvl-7">通过统计手段,97.5%的评论次数在96个词以内,统一句子长度为96(当然也可以是别的长度)</li><li class="lvl-7">超过96的句子则截断</li><li class="lvl-7">低于96的句子,我的操作是重复这个句子直到长度为96.(另一种方法是填充pad_id,但是要注意不要训练pad_id)</li></ul></li></ul></li><li class="lvl-3"><p>转换为词向量</p><ul class="lvl-2"><li class="lvl-5">在构建词表时已经完成了索引,根据词的索引找到词向量即可.</li></ul></li></ol><p><strong>DataProcesser</strong>使用方法,执行该类示例的<code>run</code>方法即可.最终生成了<code>input</code>文件夹下转换成词向量列表的句子.(分别有训练集,测试集,验证集,和word2vec的索引)</p><h4 id="二-获得模型GetModule-类">二.获得模型<strong>GetModule</strong>()类</h4><p>module.py文件中定义了<strong>GetModule</strong>()类,它会调用参数<code>module_name</code>对应的模型,并用我调整过的参数初始化这个模型,对于某些模型起到adapter的作用,对输入加以处理,使得可以在主函数中使用统一的输入模式而不加以修改.可以在module.py文件中方便地注册更多的模型</p><h4 id="三-主函数DLongpu-py"><a href="http://xn--ehq.xn--DLongpu-m73kj3zuw4c.py">三.主函数DLongpu.py</a></h4><p>主要是定义了<strong>PredictClass</strong>()</p><ol><li class="lvl-3"><p>通过上述<strong>GetModule</strong>()初始化自己的模型(包括了对应的<em>损失函数和优化器</em>)</p></li><li class="lvl-3"><p>读取预处理的数据,并通过pytorch的Dataset和Dataloader准备好数据</p></li><li class="lvl-3"><p>开始训练epoch次数</p><ol><li class="lvl-6">分batch训练：将训练数据随机划分为多个batch，每个batch被输入到模型中进行训练。(Dataloader的功能)</li><li class="lvl-6">正向传播：将当前batch的数据输入到模型中，进行正向传播计算得到输出结果。</li><li class="lvl-6">计算loss：根据输出结果和标签，计算模型的损失函数（loss）。</li><li class="lvl-6">反向传播：根据损失函数，使用链式法则计算每个参数的梯度，然后传回模型中更新参数，以减小损失函数。</li><li class="lvl-6">重复迭代：重复以上步骤直到所有batch都被训练过一遍，一个epoch训练结束。</li><li class="lvl-6">训练结束后开启eval模式,利用验证集对效果进行验证</li></ol></li><li class="lvl-3"><p>训练结束后展示在测试集的效果</p></li><li class="lvl-3"><p>储存模型</p></li></ol><p>实际上,可以通过main函数中的Mode标签,切换成test模式,读取已经储存的模型.</p><p>此外,还可使用<strong>PredictClass</strong>()中的real_test方法,利用了jieba分词对用户真实的输入进行预测.经过我的实验,效果还挺不错的.</p><p><img src="/img/ai_pa2/image-20230505190124084.png" alt="image-20230505190124084"></p><p>​效果还是不错的</p><h2 id="1-模型的结构图">1.模型的结构图</h2><p>下面分别介绍模型的结构图</p><ul class="lvl-0"><li class="lvl-2"><h4 id="CNN-simple">CNN_simple</h4><pre class="mermaid">  graph TB    A(batch_X) -->|Conv2d| C(Batch,通道数=卷积核数目,)    C -->|BatchNorm2d| D(Batch,对每一通道数据归一化处理)    D -->|ReLU,MaxPool2d|F(Batch, kernel_num, 1, 1)    F -->|View| G(Batch, kernel_num将输出拼接起来)    G -->|Dropout| H(Batch, kernel_num)    H -->|Linear and Softmax| I(全连接,将输出长度变为2,并对输出softmax)</pre></li></ul><img src="/img/ai_pa2/image-20230505191146457.png" alt="image-20230505191146457" style="zoom:50%;" /><p>注意我和课本不同的是我使用了n个相同大小卷积核,在池化的时候由于卷积后仍是2维,所以是二维的最大池化(图源课件ppt,稍作修改)</p><h4 id="CNN-complex">CNN_complex</h4><p>使用了ppt中原始cnn模型前半部分作为一个模块cnn_net</p><img src="/img/ai_pa2/image-20230505191959273.png" alt="image-20230505191959273" style="zoom: 33%;" /><pre class="mermaid">graph LR    A(batch_X) -->C(cnn_net1)-->E(flattern)-->G(maxpool1D)-->I(view拼接)    A-->B(cnn_net2)-->F(flattern)-->H(maxpool1D)-->I-->Z(全连接+softmax)</pre><ol><li class="lvl-3"><p><em>将两个形状是(批量大小, 词数, 词向量维度)的嵌入层的输出按词向量连结</em></p></li><li class="lvl-3"><p><em>根据Conv1D要求的输入格式，将词向量维，即一维卷积层的通道维(即词向量那一维)，变换到前一维</em></p></li><li class="lvl-3"><p><em>对于每个一维卷积层，在时序最大池化后会得到一个形状为(批量大小, 通道大小, 1)的</em> <em>Tensor。</em></p></li><li class="lvl-3"><p>拼接在一起后通过全连接层得到输出</p></li></ol><h4 id="RNN-我的实现也就是单层的LSTM">RNN(我的实现也就是单层的LSTM)</h4><pre class="mermaid">graph LRinput[Input] --> encoder[LSTM layer]encoder --> output[Output]encoder --> concatenation[Concatenation]concatenation --> decoder[Linear layer]decoder --> result[Result]</pre><p>具体结构解释：</p><ul class="lvl-0"><li class="lvl-2"><p>输入：输入数据，形状为 $batch \times seq_length \times embed_size$</p></li><li class="lvl-2"><p>LSTM layer：包含多层LSTM的编码器，将输入数据序列传入编码器后，得到输出序列和最终时间步的隐藏状态 -</p></li><li class="lvl-3"><p>输出：输出序列 $output_seq$，形状为 $seq_length \times batch \times num_hiddens$</p></li><li class="lvl-4"><p>Concatenation：将最终时间步的隐藏状态 $h$ 和初始时间步的隐藏状态 $c$ 沿最后一个维度拼接起来，形状为 $batch \times 2*num_hiddens$</p></li><li class="lvl-4"><p>Linear layer：线性层，将拼接后的向量输入，输出一个二元向量</p></li><li class="lvl-4"><p>Result：模型的输出，输出层的结果，形状为 $batch \times 2$</p></li></ul><img src="/img/ai_pa2/image-20230505192857489.png" alt="image-20230505192857489" style="zoom:50%;" /><p>其中depth为1,如果在torch中设置<code>bidirectional==true</code>,可以得到双向RNN</p><h4 id="MLP">MLP</h4><img src="/img/ai_pa2/image-20230505193124875.png" alt="image-20230505193124875" style="zoom:50%;" /><p>很多层的全连接+激活函数.</p><p>激活函数是必要的,否则多层会退化为单层</p><h4 id="GoogLeNet">GoogLeNet</h4><p>主要是inception模块</p><img src="/img/ai_pa2/image-20230505193239795.png" alt="image-20230505193239795" style="zoom:33%;" /><p>串联多个inception模块,最后池化+全连接</p><h4 id="DenseNet-ResNet等不再画出-完全参照ppt">DenseNet\ResNet等不再画出,完全参照ppt</h4><h2 id="2-实验结果">2.实验结果</h2><ul class="lvl-0"><li class="lvl-2"><h4 id="所有模型最终在测试集上表现的结果">所有模型最终在测试集上表现的结果.</h4></li></ul><img src="/img/ai_pa2/all_acc_F1.png" alt="all_acc_F1" style="zoom: 67%;" /><p>​可以看见CNN,RNN都达到了f值高于0.8的要求</p><ul class="lvl-0"><li class="lvl-2"><p>所有模型训练准确率随epoch的变化</p><img src="/img/ai_pa2/train_acc.png" alt="train_acc" style="zoom:72%;" /></li><li class="lvl-2"><p>所有模型训练f值随epoch的变化</p><img src="/img/ai_pa2/train_f1.png" alt="train_f1" style="zoom:67%;" /><p>本题给的数据中正负标签的比例差不多,而且我的模型看上去对正负完全不敏感.所以最终f值的计算结果和准确率差别不大.</p></li><li class="lvl-2"><p>所有模型训练f值随epoch的变化</p><img src="/img/ai_pa2/train_loss.png" alt="train_loss" style="zoom:72%;" /></li></ul><p>处于对计算力和时间的综合考虑,还有对我可怜的1650的保护,我选取的epoch比较小(16)可以看见各种模型的loss值仍有下降趋势,在对单个模型的测试过程中,增加epoch数确实可能增加训练准确率,减小loss.但有的模型已经出现比较明显的过拟合现象</p><ul class="lvl-0"><li class="lvl-2"><p>所有模型验证准确率随epoch的变化</p><img src="/img/ai_pa2/val_acc.png" alt="val_acc" style="zoom:72%;" /></li><li class="lvl-2"><p>所有模型验证准确率随epoch的变化</p><img src="/img/ai_pa2/val_f1.png" alt="val_f1" style="zoom:67%;" /><p>明显地,在验证集上,随epoch增加,准确率并不一定增加,甚至不升反降</p></li></ul><h2 id="3-使用的不同参数效果，并分析原因">3.使用的不同参数效果，并分析原因</h2><p>主要的参数</p><ul class="lvl-0"><li class="lvl-2"><p>epoch：太低达不到效果，太高出现过拟合</p></li><li class="lvl-2"><p>learrning-rate：太高波动太大，表现为准确率根本不能提升。设太低学习太慢，训练需epoch轮数多</p></li><li class="lvl-2"><p>Dropout：Dropout是指在模型训练时，随机将一部分神经元输出设置为0，从而防止模型过拟合的一种技术。在PyTorch中，我们可以通过调整Dropout概率来控制每个神经元输出为0的概率。Dropout概率过低可能会导致过拟合，而概率过高则可能会影响模型的表现。</p></li><li class="lvl-2"><p>Batch Size：指每次模型训练时参与训练的样本数量。如果Batch Size设置过小，可能会出现训练时间过长的问题；而如果Batch Size过大，可能会出现内存不足的问题。</p></li><li class="lvl-2"><p>kernel_nums：对于我表现最好的cnn-simple。我的卷积核数目增加（100–&gt;256），准确率提升较明显</p></li></ul><h2 id="4-不同模型之间的简要比较">4.不同模型之间的简要比较</h2><ul class="lvl-0"><li class="lvl-2"><p>在我对每个模型分别进行测试时,达到最高效果的实际上是CNN-complex模型</p></li><li class="lvl-2"><p>我实现的CNN,RNN模型确实在测试时表现比Baseline模型(MLP模型)强</p></li><li class="lvl-2"><p>但是MLP模型在训练集上的表现非常好,很快到达了95%+</p></li><li class="lvl-2"><p>认为MLP模型太容易过拟合,因此给他加上几个dropout,确实有点用,在测试集上表现略有变好</p></li><li class="lvl-2"><p>在我没有实现MLP的时候,实验表明我DenseNet,GoogleNet等几个复杂模型过拟合程度比较高</p></li><li class="lvl-2"><p>但是最简单的MLP的训练与测试表现差异反而最大.</p></li></ul><h2 id="5-问题思考">5.问题思考</h2><ul class="lvl-0"><li class="lvl-2"><h4 id="实验训练什么时候停止是最合适的？">实验训练什么时候停止是最合适的？</h4><p><strong>Early Stop</strong>:理论上讲可以通过验证集动态调整停止时间,在验证集效果达到最好时就停止训练.操作上可以在验证集几轮epoch都没有增长时停止.</p><p>但是earlystop有几个问题:</p><ul class="lvl-2"><li class="lvl-4"><p>比较复杂,不方便我实验框架下统一的实现.</p></li><li class="lvl-4"><p>有时候模型准确率会突变,比如googleNet</p><img src="/img/ai_pa2/The%20accuracy%20of%20GoogLeNet%20module.png" alt="The accuracy of GoogLeNet module" style="zoom: 50%;" /><p>所以我最终采用了固定epoch数的方式.</p><p>但是实际上几个我调过参数模型在epoch数为40左右表现最好</p></li></ul></li><li class="lvl-2"><h4 id="实验参数的初始化是怎么做的？">实验参数的初始化是怎么做的？</h4><ul class="lvl-2"><li class="lvl-4"><p>模型的参数基本上是pytorch默认方法.</p></li><li class="lvl-4"><p>例如：nn.Linear 和 nn.Conv2D，都是在 [-limit, limit] 之间的均匀分布（Uniform distribution），其中 limit 是 $1. / sqrt(fan_{in}) ，fan_{in}$ 是指参数张量（<a href="https://so.csdn.net/so/search?q=tensor&amp;spm=1001.2101.3001.7020">tensor</a>）的输入单元的数量。</p></li><li class="lvl-4"><p>此外对于RNN可以考虑正交初始化（Orthogonal Initialization）</p><p>主要用以解决深度网络下的梯度消失、梯度爆炸问题，是在RNN中经常使用的参数初始化方法。<code>nn.init.orthogonal</code>但实际上差别没有感觉</p></li></ul></li><li class="lvl-2"><h4 id="有什么方法可以方式训练过程陷入过拟合。">有什么方法可以方式训练过程陷入过拟合。</h4><p>下面是按照我实验中的效果明显程度排序</p><ol><li class="lvl-5"><p>选取更加合适的模型:</p><p>这个是</p></li><li class="lvl-5"><p>调整epoch,在合理时机停止</p></li><li class="lvl-5"><p>增加dropout层,调整dropout概率</p><p>看baseline模型,认为MLP模型太容易过拟合,因此给他加上几个dropout,确实有点用,在测试集上表现确实略有变好.但是对其他比较复杂的模型来说,dropout影响有限</p></li><li class="lvl-5"><p>参数正则化</p><p>计算loss时添加正则化项</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">L1_reg = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> param <span class="keyword">in</span> self.module.parameters():</span><br><span class="line">     L1_reg += torch.<span class="built_in">sum</span>(torch.<span class="built_in">abs</span>(param))</span><br><span class="line">loss += <span class="number">0.001</span> * L1_reg  <span class="comment"># lambda=0.001</span></span><br></pre></td></tr></table></figure><p>这样可以惩罚某些较大的参数.按照我的理解就是防止考试偏科.</p><p>但实在是没什么用</p></li><li class="lvl-5"><p>调整参数.</p><p>dropout\learning-rate等等都会影响过拟合</p></li><li class="lvl-5"><p>增加训练集大小</p><p>一个操作是可以通过k-折,将原有训练集与验证集合并后随机分成k份.这样可以增加训练集大小</p></li><li class="lvl-5"><p>动态停止epoch</p></li><li class="lvl-5"><p>动态调整</p></li></ol><h2 id="6-试分析CNN，RNN，全连接神经网络（MLP）三者的优缺点。">6.试分析CNN，RNN，全连接神经网络（MLP）三者的优缺点。</h2></li></ul><p>多层感知机在单层神经网络的基础上引入了一到多个隐藏层（hidden layer）。隐藏层位于输入层和输出层之间。</p><p>如果把CNN的核的大小看成和输入一样,那么实际上MLP可以看作是CNN的一个特例.</p><ul class="lvl-0"><li class="lvl-2"><p>MLP</p><ul class="lvl-2"><li class="lvl-4">全连接神经网络（MLP）的优点在于比较简单,它可以捕捉到输入数据的非线性关系，能够应用于各种领域。</li><li class="lvl-4">参数较多,单层计算起来比较复杂,容易过拟合…正则化等技术在MLP上的效果比较好</li><li class="lvl-4">单层只能表示一个维度的信息.对空间的敏感性不如CNN</li></ul></li><li class="lvl-2"><p>RNN</p><ul class="lvl-2"><li class="lvl-4"><p>对于序列数据的处理具有很强的能力，尤其在语音识别、自然语言处理和语音合成等任务中表现优异。</p></li><li class="lvl-4"><p>RNN具有记忆能力，它可以传递信息并保留之前输入的状态，从而在处理时序信息时取得较好的效果。</p></li><li class="lvl-4"><p>RNN的缺点在于，训练复杂度高，而且受梯度消失/爆炸问题的限制，其在长序列的语音和自然语言任务中表现可能较差。</p></li></ul></li><li class="lvl-2"><p>CNN</p><ul class="lvl-2"><li class="lvl-4">单层计算量比全连接小</li><li class="lvl-4">参数共享和稀疏交通,能够以较小的计算和储存成本生成大量参数。</li><li class="lvl-4">可以捕捉到多个层级的特征,比如宽高.对空间敏感性更好,因此常常应用在计算机视觉中</li><li class="lvl-4">但是CNN还是有两个非常危险的缺陷：平移不变性和池化层。我的理解是CNN对位置太敏感了,一个卷积核的神经元识别一只猫,猫动一动就认不出来了.池化层虽然可以一定程度上削弱这个问题,但是带来了数据信息丢失等新问题.</li></ul></li></ul><h2 id="7-实验心得">7.实验心得</h2><ul class="lvl-0"><li class="lvl-2"><p>利用五一假期,我从零认真学习了一波pytorch,所有的心得体会记录在了我的<a href="https://ggx21.github.io/2023/05/03/notes/pytorch/learn_torch/">这篇博客</a>里</p></li><li class="lvl-2"><p>感觉这个实验解释性实在是有点低,哪个参数更好,哪个模型更好,什么层可以解决什么问题,基本上还是要靠实验.书本的知识往往并不一定适用</p></li><li class="lvl-2"><p><a href="https://github.com/Ggx21/IAI2">作业仓库</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
          <category> PyTorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PyTorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dive-into-DL-PyTorch</title>
      <link href="/notes/pytorch/learn_torch/"/>
      <url>/notes/pytorch/learn_torch/</url>
      
        <content type="html"><![CDATA[<h2 id="1-准备数据">1.准备数据</h2><p>在使用pytorch进行深度学习时，首先需要准备好数据。一般来说，数据需要按照一定的格式组织，例如可以使用Dataset和DataLoader将数据读入内存，并按照批次进行划分。</p><h4 id="读写数据-save-load">读写数据:(save&amp;load)</h4><ul class="lvl-0"><li class="lvl-2"><p><code>torch.save(x, 'x.pt')</code>:将x存在文件名同为<code>x.pt</code>的文件里。</p></li><li class="lvl-2"><p>将数据从存储的文件读回内存<code>x2 = torch.load('x.pt')</code></p><p>不仅是tensor.dict啥啥的数据都能这么存储.</p><p>无论是文件大小还是读写速度都完爆json</p></li></ul><h4 id="读写模型">读写模型:</h4><ul class="lvl-0"><li class="lvl-2"><p>两个方式:仅保存和加载模型参数(<code>state_dict</code>)(推荐)；保存和加载整个模型。</p><p>差别就是,第一种方法在SL时候只SL参数,下次L时先建一个新model,然后把参数L进去就好了.</p></li></ul><h5 id="代码-slData模式">代码(slData模式):</h5><p>保存：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.save(model.state_dict(), PATH) <span class="comment"># 推荐的文件后缀名是pt或pthCopy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure><p>加载：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model = TheModelClass(*args, **kwargs)</span><br><span class="line">model.load_state_dict(torch.load(PATH))</span><br></pre></td></tr></table></figure><p>一个小问题在于不同设备(CPU与GPU,不同GPU之间.具体遇到问题再说吧)</p><h2 id="2-创建模型">2.创建模型</h2><p>模型是深度学习的核心，它决定了最终学习的效果。在pytorch中，可以通过继承nn.Module类来创建模型，并在其中定义前向计算函数。</p><blockquote><p>我的理解是,模型就是一个千层饼.每一层有个什么功能.下面就是一层饼的例子.</p><p>实际上并不是层数越多越好.</p><ul class="lvl-1"><li class="lvl-2"><p>当神经网络的层数较多时，模型的数值稳定性容易变差:$0.99^ {365}=?;1.01^{365=?}$</p></li><li class="lvl-2"><p>如何解决?批量归一化</p></li></ul><p>通过不停地tensor运算联立方程,是不是可以把千层饼等效为单层?</p></blockquote><h4 id="多层感知机的设计">多层感知机的设计</h4><p>如果千层饼被等效为单层,那么对层的设计就失去了意义.上面的问题在于.</p><blockquote><p>全连接层只是对数据做仿射变换（affine transformation），而多个仿射变换的叠加仍然是一个仿射变换。</p></blockquote><p>解决方法是我们加入一些非线性变换的层</p><h5 id="例子">例子:</h5><ul class="lvl-0"><li class="lvl-2"><p>ReLU（rectified linear unit）函数<br>$$<br>ReLU(x)=max(x,0).<br>$$</p></li><li class="lvl-2"><p>sigmoid<br>$$<br>sigmoid(x)= \frac 1 {1+exp(−x)}<br>$$<br><img src="/img/learn_torch.assets/3.8_sigmoid.png" alt="img" style="zoom:33%;" /></p><img src="/img/learn_torch.assets/3.8_sigmoid_grad.png" alt="img" style="zoom:33%;" /></li><li class="lvl-2"><p>tanh函数(双曲正切)<br>$$<br>tanh(x)= \frac{1+exp(−2x)}{1−exp(−2x)}<br>$$<br>图像和sigmoid差不多,但是0附近更陡峭一些</p></li></ul><h4 id="一个flattenlayer的例子">一个flattenlayer的例子</h4><p>这里有一个把(batchsize,*,*,…)的多维tensor转换为(batchsize,***)的二维tensor的例子.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FlattenLayer</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(FlattenLayer, self).__init__()</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>): <span class="comment"># x shape: (batch, *, *, ...)</span></span><br><span class="line">        <span class="keyword">return</span> x.view(x.shape[<span class="number">0</span>], -<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h4 id="一个模型的例子">一个模型的例子</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">net = nn.Sequential(</span><br><span class="line">    OrderedDict([</span><br><span class="line">        (<span class="string">&#x27;flatten&#x27;</span>, FlattenLayer()),<span class="comment">#看,就是这样一层层搭起来...</span></span><br><span class="line">        (<span class="string">&#x27;linear&#x27;</span>, nn.Linear(num_inputs, num_outputs))</span><br><span class="line">    ])</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="初始化模型参数">初始化模型参数:</h3><p>构建好了模型,我们得有初始参数啊.</p><p>**太好了!**PyTorch中<code>nn.Module</code>的模块参数都采取了较为合理的初始化策略,一般不用我们考虑;如果你真的想知道可参考pytorch<a href="https://github.com/pytorch/pytorch/tree/master/torch/nn/modules">源代码)</a></p><h3 id="总结">总结:</h3><ol><li class="lvl-3"><p>继承Module类</p><p><code>Module</code>类是<code>nn</code>模块里提供的一个模型构造类，是所有神经网络模块的基类</p><p>一般来说,我们重载<code>Module</code>类的<code>__init__</code>函数和<code>forward</code>函数。它们分别用于创建模型参数和定义前向计算。无须定义反向传播函数。系统将通过自动求梯度而自动生成反向传播所需的<code>backward</code>函数。</p><p>注意:重载<code>__init__</code>函数时应该首先调用父类<code>module</code>的初始化函数e.g.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MLP</span>(nn.Module):</span><br><span class="line">    <span class="comment"># 声明带有模型参数的层，这里声明了两个全连接层</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, **kwargs</span>):</span><br><span class="line">        <span class="comment"># 调用MLP父类Module的构造函数来进行必要的初始化。这样在构造实例时还可以指定其他函数</span></span><br><span class="line">        <span class="comment"># 参数，如“模型参数的访问、初始化和共享”一节将介绍的模型参数params</span></span><br><span class="line">        <span class="built_in">super</span>(MLP, self).__init__(**kwargs)</span><br></pre></td></tr></table></figure></li><li class="lvl-3"><p>module的子类:还有一些<code>Sequential</code>,<code>ModuleDict</code>,<code>ModuleList</code>之类的东西.我感觉没什么用啊.好像只是让我把一堆Module以一种整齐的方式凑在一起.<code>Sequential</code>好像还挺有用的,至少他要保证层之间输入输出维度匹配,可以直接forward.</p></li><li class="lvl-3"><p>共享模型参数: <code>Module</code>类的<code>forward</code>函数里多次调用同一个层,层之间参数共享。此外，如果我们传入<code>Sequential</code>的模块是同一个<code>Module</code>实例的话参数也是共享的</p><blockquote><p>真的有人在乎参数究竟是什么吗?</p></blockquote></li><li class="lvl-3"><p>自定义层:见[flattenlayer](#### 一个flattenlayer的例子)的例子,这是一个不带参数的层,你当然也可以带参数.但意义是?</p></li><li class="lvl-3"><p>我想:module就是层的累加.一个头进一个头出.<code>人体蜈蚣.</code></p></li></ol><h2 id="3-定义损失函数">3.定义损失函数</h2><p>常见的损失函数有交叉熵损失函数、均方误差损失函数等，可以根据不同的任务选择不同的损失函数。</p><blockquote><p>例子:</p><p>PyTorch提供了一个包括softmax运算和交叉熵损失计算的函数。它的数值稳定性更好。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loss = nn.CrossEntropyLoss()</span><br></pre></td></tr></table></figure></blockquote><h2 id="4-定义优化器和学习率">4.定义优化器和学习率</h2><p>在训练的过程中，需要使用优化器来更新模型参数。常见的优化器有梯度下降法、Adam等。同时，由于学习率对训练效果影响较大，所以需要定义学习率的初始值以及变化规则。</p><blockquote><p>e.g.</p><p>我们使用学习率为0.1的小批量随机梯度下降作为优化算法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">optimizer = torch.optim.SGD(net.parameters(), lr=<span class="number">0.1</span>)</span><br></pre></td></tr></table></figure></blockquote><h2 id="5-训练模型">5.训练模型</h2><p>将数据、模型、损失函数、优化器和学习率等组合在一起，循环执行前向计算、损失计算、反向传播和参数更新等步骤，即可训练模型。在每个epoch结束后，还需要对模型进行评估。</p><div class="tips"><p>在训练之前可以测试输入形状比如：</p><p>在训练ResNet之前，我们来观察一下输入形状在ResNet不同模块之间的变化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X = torch.rand((<span class="number">1</span>, <span class="number">1</span>, <span class="number">224</span>, <span class="number">224</span>))</span><br><span class="line"><span class="keyword">for</span> name, layer <span class="keyword">in</span> net.named_children():</span><br><span class="line">    X = layer(X)</span><br><span class="line">    <span class="built_in">print</span>(name, <span class="string">&#x27; output shape:\t&#x27;</span>, X.shape)</span><br></pre></td></tr></table></figure></div><h2 id="6-使用模型进行预测">6.使用模型进行预测</h2><p>在训练好模型后，可以使用它对新的数据进行预测，并输出预测结果或概率。</p><h2 id="7-模型选择">7.模型选择</h2><p>我们怎么评价模型的好坏呢?</p><h3 id="模型欠拟合与过拟合">模型欠拟合与过拟合</h3><h4 id="简单地"><strong>简单地:</strong></h4><ul class="lvl-0"><li class="lvl-2"><p><strong>给定训练数据集，如果模型的复杂度过低，很容易出现欠拟合；如果模型复杂度过高，很容易出现过拟合。</strong></p></li><li class="lvl-2"><p><strong>过少的训练样本</strong>也会导致过拟合</p></li></ul><h4 id="训练误差（training-error）和泛化误差（generalization-error）">训练误差（training error）和泛化误差（generalization error）</h4><p>当模型在训练数据集上更准确时，它在测试数据集上却不一定更准确。这是为什么呢？</p><p>以高考为例来直观地解释训练误差和泛化误差这两个概念。训练误差可以认为是做往年高考试题（训练题）时的错误率，泛化误差则可以通过真正参加高考（测试题）时的答题错误率来近似。</p><p>训练的时候是根据往年题的表现来的(通过减小训练误差).所以往年题做的好不一定代表着高考考的好.(一般来说训练误差的期望$\leq$泛化误差)</p><p>但我们关注的是<strong>泛化误差</strong></p><h4 id="训练集-验证集-测试集">训练集\验证集\测试集</h4><p>高考只能考一次,我们没有办法从训练集(看着答案做题)中知道自己的高考表现.所以我们可以拿一些测试集训练集之外的数据作为<strong>验证集</strong>(模考).</p><p>操作上,我们可以从给定的训练集中随机选取一小部分作为验证集，而将剩余部分作为真正的训练集。</p><blockquote><p><em>K</em>折交叉验证（K-<em>K</em>-fold cross-validation）</p><p>分出K个子集来.这样可以测K次</p></blockquote><p>但实际上,由于数据不容易获取，测试数据极少只使用一次就丢弃。因此，实践中验证数据集和测试数据集的界限可能比较模糊.</p><h3 id="应对过拟合">应对过拟合:</h3><h4 id="1-权重衰减（weight-decay）">1.权重衰减（weight decay）</h4><blockquote><p>可以定义多个优化器实例对不同的模型参数使用不同的迭代方法。</p></blockquote><p>权重衰减等价于$L_2$范数正则化（regularization）</p><p><strong>我的理解</strong>:就是在计算损失函数的时候加上一项$λ\times L_2$其中λ是一个超参。$L_2$：参数权重越大，$L_2$越大。这样大概保证了各参数大小都差不多，不偏科。</p><h5 id="实现代码：">实现代码：</h5><p>直接在构造优化器实例时通过<code>weight_decay</code>参数来指定权重衰减超参数。默认下，PyTorch会对权重和偏差同时衰减。我们可以分别对权重和偏差构造优化器实例，从而只对权重衰减。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">optimizer_w = torch.optim.SGD(params=[net.weight], lr=lr, weight_decay=wd) <span class="comment"># 对权重参数衰减</span></span><br><span class="line">optimizer_b = torch.optim.SGD(params=[net.bias], lr=lr)  <span class="comment"># 不对偏差参数衰减</span></span><br><span class="line"><span class="comment">#...在optimize时</span></span><br><span class="line"><span class="comment"># 对两个optimizer实例分别调用step函数，从而分别更新权重和偏差</span></span><br><span class="line">            optimizer_w.step()</span><br><span class="line">            optimizer_b.step()</span><br></pre></td></tr></table></figure><h4 id="2-丢弃法-dropout">2.丢弃法(dropout)</h4><img src="/img/learn_torch.assets/3.13_dropout.svg" alt="img" style="zoom: 80%;" /><p>在隐藏层随机丢弃一个单元.比如上图,隐藏层原来有$h_1,h_2,…,h_5.h_2,h_5 $被丢弃了.</p><p>这样计算时不会过度依赖某一个隐藏单元</p><ul class="lvl-0"><li class="lvl-2"><blockquote><p>(和权重衰减的目的大概是一样的),都是保证不偏科.要不然模考物理总是很难,就你一个考100,人家都是0分.到了高考一赋分大家都考90,你傻眼了.</p></blockquote></li></ul><h5 id="实现">实现:</h5><p>在PyTorch中，我们只需要在全连接层后添加<code>Dropout</code>层并指定丢弃概率。在训练模型时，<code>Dropout</code>层将以指定的丢弃概率随机丢弃上一层的输出元素</p><p>在测试模型时（即<code>model.eval()</code>后），<code>Dropout</code>层并不发挥作用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">net = nn.Sequential(</span><br><span class="line">        d2l.FlattenLayer(),</span><br><span class="line">        nn.Linear(num_inputs, num_hiddens1),</span><br><span class="line">        nn.ReLU(),</span><br><span class="line">        nn.Dropout(drop_prob1),<span class="comment">#设定一个丢弃概率</span></span><br><span class="line">        nn.Linear(num_hiddens1, num_hiddens2),</span><br><span class="line">        nn.ReLU(),</span><br><span class="line">        nn.Dropout(drop_prob2),<span class="comment">#设定一个丢弃概率</span></span><br><span class="line">        nn.Linear(num_hiddens2, <span class="number">10</span>)</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><blockquote><p>丢弃法只在训练模型时使用。</p></blockquote><h2 id="CNN">CNN</h2><p>卷积层的输入和输出通常是四维数组（样本，通道，高，宽），而全连接层的输入和输出则通常是二维数组（样本，特征）。</p><h3 id="0-前置知识">0.前置知识</h3><p>在net里加上一个卷积层就形成了<strong>CNN</strong></p><p>一个小翻译:<code>Kernel</code>在pytorch的卷积计算时就叫做<code>filter</code>.</p><p>CNN的学习就是学习这个<code>kernel</code>,(相应的,上面在学习一个参数tensor)</p><p>那个经典的图像边缘检测实际上在互相关.kernel走一步,算一圈,下个蛋…</p><p>卷积运算与互相关运算类似。<strong>为了得到卷积运算的输出，我们只需将核数组左右翻转并上下翻转，再与输入数组做互相关运算</strong>.有什么区别?**没有区别!**反正都是学出来的,学出来的核再上下左右转换一下那么两种运算就交换了.所以根本不需要知道什么是卷积就能CNN.</p><h4 id="优势">优势?</h4><p>考虑图像分类问题。每张图像高和宽均是28像素。我们将图像中的像素逐行展开，得到长度为784的向量，并输入进全连接层中。然而，这种分类方法有一定的局限性。</p><ol><li class="lvl-3"><p>图像在同一列邻近的像素在这个向量中可能相距较远。它们构成的模式可能难以被模型识别。</p></li><li class="lvl-3"><p>对于大尺寸的输入图像，使用全连接层容易造成模型过大。假设输入是高和宽均为1000像素的彩色照片（含3个通道）。即使全连接层输出个数仍是256，该层权重参数的形状是3,000,000×2563,000,000×256：它占用了大约3 GB的内存或显存。这带来过复杂的模型和过高的存储开销。</p></li></ol><p>一方面，卷积层保留输入形状，使图像的像素在高和宽两个方向上的相关性均可能被有效识别；另一方面，卷积层通过滑动窗口将同一卷积核与不同位置的输入重复计算，从而避免参数尺寸过大。</p><h3 id="1-填充和步幅">1.填充和步幅:</h3><p>要想使用一个卷积层,操作上显见的问题就是我们要知道这个卷积层输入输出的形状.</p><p>一般来说,对于第i维来说,如果输入在第i维长度?<code>有没有更好的名字</code>是$n_i$,核长度是$k_i$那么输出在第i维长度就是($n_i-k_i+1$),显然,$k_i$不应该超过$n_i$,否则会报错</p><h5 id="填充padding">填充padding</h5><p>**太长不看:**取padding=({$\frac {kernelsize_i-1} 2$,…})可以保证输入输出形状相同</p><p>填充（padding）是指在输入高和宽的两侧填充元素（通常是0元素）。</p><p>如果在第i维的两侧<strong>一共填充$p_i$行</strong></p><p>那么输出形状第i维将会是($n_i-k_i+p_i+1$)</p><p>所以通常可以把$p_i设置为k_i-1$来使输入输出具有相同形状</p><p>当卷积核的高和宽不同时，我们也可以通过设置高和宽上不同的填充数使输出和输入具有相同的高和宽。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用高为5、宽为3的卷积核。在高和宽两侧的填充数分别为2和1</span></span><br><span class="line">conv2d = nn.Conv2d(in_channels=<span class="number">1</span>, out_channels=<span class="number">1</span>, kernel_size=(<span class="number">5</span>, <span class="number">3</span>), padding=(<span class="number">2</span>, <span class="number">1</span>))</span><br><span class="line">comp_conv2d(conv2d, X).shape</span><br></pre></td></tr></table></figure><p><mark>注意</mark>:操作上<code>padding=(2, 1)</code>padding的参数代表着在kernel两侧分别填充多少.也就是说$=p_i/2$,所以尽量也把核的每一维长度取奇数,这样保证了$p_i/2$是个整数.否则还得考虑两边分别取floor和ceiling,<strong>麻烦死了</strong></p><h5 id="步幅stride">步幅stride</h5><p>卷积窗口从输入数组的最左上方开始，按从左往右、从上往下的顺序，依次在输入数组上滑动。我们将每次滑动的行数和列数称为步幅（stride）。</p><p>步幅可以按比例缩小形状</p><p>如果按上一步设置理想的padding，同时如果输入的高和宽能分别被高和宽上的步幅整除，那么输出形状将缩为原来的1/stride倍.其他情况自己算去,但何必为难自己.</p><h3 id="2-多输入通道与多输出通道">2.多输入通道与多输出通道.</h3><h4 id="多输入通道">多输入通道</h4><p>实际上不就是多了一维吗?比如彩色图像在高和宽2个维度外还有RGB（红、绿、蓝）3个颜色通道。就是新增了一个长度为3(r,g,b)的一维.然后我们用三个卷积核叠一块,发现在色彩维度上insize和kernersize都是3,然后这一维长度就变成1,退化了.</p><p>实现含多个输入通道的互相关运算。我们只需要对每个通道做互相关运算，然后通过<code>add_n</code>函数来进行累加。</p><h4 id="多输出通道">多输出通道</h4><p>哎呀我一阵头晕目眩,不想知道它是怎么算的了.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义输入张量</span></span><br><span class="line">input_tensor = torch.randn(<span class="number">16</span>, <span class="number">3</span>, <span class="number">32</span>, <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义卷积层----------------------------------------看这里</span></span><br><span class="line">conv_layer = nn.Conv2d(in_channels=<span class="number">3</span>, out_channels=<span class="number">10</span>, kernel_size=<span class="number">3</span>, stride=<span class="number">1</span>, padding=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 前向计算</span></span><br><span class="line">output_tensor = conv_layer(input_tensor)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出张量形状</span></span><br><span class="line"><span class="built_in">print</span>(output_tensor.shape)  <span class="comment"># torch.Size([16, 10, 32, 32])</span></span><br></pre></td></tr></table></figure><p>直接来看示例代码吧.知道它怎么算干嘛呢?</p><p>在上面的代码中，<code>input_tensor</code> 是一个批次大小为 16、通道数为 3、高度为 32、宽度为 32 的输入张量，<code>conv_layer</code> 是一个输出通道数为 10、卷积核大小为 3x3、步幅为 1、填充为 1 的卷积层，<code>output_tensor</code> 是卷积层的输出张量，它的形状为 <code>[16, 10, 32, 32]</code>。</p><p>这是gpt说的啊,我觉着挺对的.可以自己跑着试试.</p><h4 id="1-1卷积层">1*1卷积层</h4><p>一个长宽都是1的核</p><p>1×1卷积失去了卷积层可以识别高和宽维度上相邻元素构成的模式的功能。实际上，1×1卷积的主要计算发生在通道维上。图5.5展示了使用输入通道数为3、输出通道数为2的1×1卷积核的互相关计算。值得注意的是，输入和输出具有相同的高和宽。输出中的每个元素来自输入中在高和宽上相同位置的元素在不同通道之间的按权重累加。</p><p>假设我们将通道维当作特征维，将高和宽维度上的元素当成数据样本，<strong>那么1×1卷积层的作用与全连接层等价</strong>。</p><p>通过这个来调整参数的通道数,控制模型复杂度.e.g.语数外+理综to语数外+三门选科</p><h3 id="2-池化">2.池化</h3><p><strong>缓解卷积层对位置的过度敏感性</strong>。(想想抗锯齿操作,都是通过采样来使得过渡更加平滑??)</p><p>池化窗口形状为p<em>×</em>q<em>的池化层称为p</em>×<em>q</em>池化层，其中的池化运算叫作p<em>×</em>q池化。</p><ul class="lvl-0"><li class="lvl-2"><p>池化层的输出通道数跟输入通道数相同。</p></li><li class="lvl-2"><p>默认情况下，<code>MaxPool2d</code>实例里步幅和池化窗口形状相同。当然可以自己设定.但是池化后的形状又要算一算了吗?</p></li></ul><h3 id="一些例子">一些例子</h3><p><strong>下面的例子,即使是LeNet,都完全够应付作业了</strong>完全没有必要看</p><h4 id="LeNet">LeNet</h4><p><img src="/img/learn_torch.assets/5.5_lenet.png" alt="img"></p><p><strong>卷积层块里的基本单位是卷积层后接最大池化层</strong>：卷积层用来识别图像里的空间模式，如线条和物体局部，之后的最大池化层则用来降低卷积层对位置的敏感性。卷积层块由两个这样的基本单位重复堆叠构成。</p><h5 id="实现-2">实现</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn, optim</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">&quot;..&quot;</span>)</span><br><span class="line"><span class="keyword">import</span> d2lzh_pytorch <span class="keyword">as</span> d2l</span><br><span class="line">device = torch.device(<span class="string">&#x27;cuda&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LeNet</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(LeNet, self).__init__()</span><br><span class="line">        self.conv = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>), <span class="comment"># in_channels, out_channels, kernel_size</span></span><br><span class="line">            nn.Sigmoid(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>), <span class="comment"># kernel_size, stride</span></span><br><span class="line">            nn.Conv2d(<span class="number">6</span>, <span class="number">16</span>, <span class="number">5</span>),</span><br><span class="line">            nn.Sigmoid(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">        )</span><br><span class="line">        self.fc = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">16</span>*<span class="number">4</span>*<span class="number">4</span>, <span class="number">120</span>),</span><br><span class="line">            nn.Sigmoid(),</span><br><span class="line">            nn.Linear(<span class="number">120</span>, <span class="number">84</span>),</span><br><span class="line">            nn.Sigmoid(),</span><br><span class="line">            nn.Linear(<span class="number">84</span>, <span class="number">10</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, img</span>):</span><br><span class="line">        feature = self.conv(img)</span><br><span class="line">        output = self.fc(feature.view(img.shape[<span class="number">0</span>], -<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure><p>先conv再flatten,大概都是这么个套路</p><h4 id="AlexNet">AlexNet</h4><p>很多分类工作流程是:获取数据集–&gt;获得特征–&gt;进行分类.</p><p>之前认为DL的工作只是使用机器学习模型对特征分类。使用较干净的数据集和较有效的特征甚至比机器学习模型的选择对图像分类结果的影响更大。</p><p>特征可以学习吗?&gt;&gt; AlexNet</p><p><img src="/img/learn_torch.assets/5.6_alexnet.png" alt="img"></p><h5 id="稍微简化的AlexNet">稍微简化的AlexNet</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn, optim</span><br><span class="line"><span class="keyword">import</span> torchvision</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">&quot;..&quot;</span>)</span><br><span class="line"><span class="keyword">import</span> d2lzh_pytorch <span class="keyword">as</span> d2l</span><br><span class="line">device = torch.device(<span class="string">&#x27;cuda&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AlexNet</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>(AlexNet, self).__init__()</span><br><span class="line">        self.conv = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">1</span>, <span class="number">96</span>, <span class="number">11</span>, <span class="number">4</span>), <span class="comment"># in_channels, out_channels, kernel_size, stride, padding</span></span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">3</span>, <span class="number">2</span>), <span class="comment"># kernel_size, stride</span></span><br><span class="line">            <span class="comment"># 减小卷积窗口，使用填充为2来使得输入与输出的高和宽一致，且增大输出通道数</span></span><br><span class="line">            nn.Conv2d(<span class="number">96</span>, <span class="number">256</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">3</span>, <span class="number">2</span>),</span><br><span class="line">            <span class="comment"># 连续3个卷积层，且使用更小的卷积窗口。除了最后的卷积层外，进一步增大了输出通道数。</span></span><br><span class="line">            <span class="comment"># 前两个卷积层后不使用池化层来减小输入的高和宽</span></span><br><span class="line">            nn.Conv2d(<span class="number">256</span>, <span class="number">384</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Conv2d(<span class="number">384</span>, <span class="number">384</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Conv2d(<span class="number">384</span>, <span class="number">256</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line">        )</span><br><span class="line">         <span class="comment"># 这里全连接层的输出个数比LeNet中的大数倍。使用丢弃层来缓解过拟合</span></span><br><span class="line">        self.fc = nn.Sequential(</span><br><span class="line">            nn.Linear(<span class="number">256</span>*<span class="number">5</span>*<span class="number">5</span>, <span class="number">4096</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Dropout(<span class="number">0.5</span>),</span><br><span class="line">            nn.Linear(<span class="number">4096</span>, <span class="number">4096</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Dropout(<span class="number">0.5</span>),</span><br><span class="line">            <span class="comment"># 输出层。由于这里使用Fashion-MNIST，所以用类别数为10，而非论文中的1000</span></span><br><span class="line">            nn.Linear(<span class="number">4096</span>, <span class="number">10</span>),</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, img</span>):</span><br><span class="line">        feature = self.conv(img)</span><br><span class="line">        output = self.fc(feature.view(img.shape[<span class="number">0</span>], -<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>真的,体验上来说,LeNet做作业就完全够了…</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>AlexNet跟LeNet结构类似，但使用了更多的卷积层和更大的参数空间来拟合大规模数据集ImageNet。它是浅层神经网络和深度神经网络的分界线。</p></li><li class="lvl-2"><p>虽然看上去AlexNet的实现比LeNet的实现也就多了几行代码而已，但这个观念上的转变和真正优秀实验结果的产生令学术界付出了很多年。</p></li></ul><h3 id="VGG块"><a href="https://tangshusen.me/Dive-into-DL-PyTorch/#/chapter05_CNN/5.7_vgg?id=_571-vgg%E5%9D%97">VGG块</a></h3><p>VGG块的组成规律是：连续使用数个相同的填充为1、窗口形状为3×33×3的卷积层后接上一个步幅为2、窗口形状为2×22×2的最大池化层。卷积层保持输入的高和宽不变，而池化层则对其减半。我们使用<code>vgg_block</code>函数来实现这个基础的VGG块，它可以指定卷积层的数量和输入输出通道数。</p><blockquote><p>对于给定的感受野（与输出有关的输入图片的局部大小），采用堆积的小卷积核优于采用大的卷积核，因为可以增加网络深度来保证学习更复杂的模式，而且代价还比较小（参数更少）。例如，在VGG中，使用了3个3x3卷积核来代替7x7卷积核，使用了2个3x3卷积核来代替5*5卷积核，这样做的主要目的是在保证具有相同感知野的条件下，提升了网络的深度，在一定程度上提升了神经网络的效果。</p></blockquote><h3 id="NiN块"><a href="https://tangshusen.me/Dive-into-DL-PyTorch/#/chapter05_CNN/5.8_nin?id=_581-nin%E5%9D%97">NiN块</a></h3><p>我们知道，卷积层的输入和输出通常是四维数组（样本，通道，高，宽），而全连接层的输入和输出则通常是二维数组（样本，特征）。如果想在全连接层后再接上卷积层，则需要将全连接层的输出变换为四维。回忆在5.3节（多输入通道和多输出通道）里介绍的1×11×1卷积层。它可以看成全连接层，其中空间维度（高和宽）上的每个元素相当于样本，通道相当于特征。因此，NiN使用1×11×1卷积层来替代全连接层，从而使空间信息能够自然传递到后面的层中去。图5.7对比了NiN同AlexNet和VGG等网络在结构上的主要区别。</p><p>上面这俩我回头再看,头晕😵‍💫😵‍💫😵‍💫😵‍💫</p><h3 id="5-9-含并行连结的网络（GoogLeNet）"><a href="https://tangshusen.me/Dive-into-DL-PyTorch/#/chapter05_CNN/5.9_googlenet?id=_59-%E5%90%AB%E5%B9%B6%E8%A1%8C%E8%BF%9E%E7%BB%93%E7%9A%84%E7%BD%91%E7%BB%9C%EF%BC%88googlenet%EF%BC%89">5.9 含并行连结的网络（GoogLeNet）</a></h3><p>如果说上面两个是网络之间串行,那么GoogLeNet的基本块Inception块是并行的(并行里套了串行)</p><img src="/img/learn_torch.assets/5.9_inception.svg" alt="inception块" /><p>Inception块里有4条并行的线路。前3条线路使用窗口大小分别是1×1、3×3和5×5的卷积层来抽取不同空间尺寸下的信息，其中中间2个线路会对输入先做1×1卷积来减少输入通道数，以降低模型复杂度。第四条线路则使用3×3最大池化层，后接1×1卷积层来改变通道数。4条线路都使用了合适的填充来使输入与输出的高和宽一致。最后我们将每条线路的输出在通道维上连结，并输入接下来的层中去。</p><p>这个更复杂了😵‍💫😵‍💫😵‍💫😵‍💫具体实现抄抄链接里的吧.我真的好奇他怎么保证每次输入输出通道匹配的</p><h3 id="批量归一化">批量归一化</h3><ul class="lvl-0"><li class="lvl-2"><p>在模型训练时，批量归一化利用小批量上的均值和标准差，不断调整神经网络的中间输出，从而使整个神经网络在各层的中间输出的数值更稳定。</p></li><li class="lvl-2"><p>对全连接层和卷积层做批量归一化的方法稍有不同。</p></li><li class="lvl-2"><p>批量归一化层和丢弃层一样，在训练模式和预测模式的计算结果是不一样的。</p></li><li class="lvl-2"><p>PyTorch提供了BatchNorm类方便使用。</p></li></ul><p>Pytorch中<code>nn</code>模块定义的<code>BatchNorm1d</code>和<code>BatchNorm2d</code>类使用起来更加简单，二者分别用于全连接层和卷积层，都需要指定输入的<code>num_features</code>参数值。下面我们用PyTorch实现使用批量归一化的LeNet。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">net = nn.Sequential(</span><br><span class="line">            nn.Conv2d(<span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>), <span class="comment"># in_channels, out_channels, kernel_size</span></span><br><span class="line">            nn.BatchNorm2d(<span class="number">6</span>),</span><br><span class="line">            nn.Sigmoid(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>), <span class="comment"># kernel_size, stride</span></span><br><span class="line">            nn.Conv2d(<span class="number">6</span>, <span class="number">16</span>, <span class="number">5</span>),</span><br><span class="line">            nn.BatchNorm2d(<span class="number">16</span>),</span><br><span class="line">            nn.Sigmoid(),</span><br><span class="line">            nn.MaxPool2d(<span class="number">2</span>, <span class="number">2</span>),</span><br><span class="line">            d2l.FlattenLayer(),</span><br><span class="line">            nn.Linear(<span class="number">16</span>*<span class="number">4</span>*<span class="number">4</span>, <span class="number">120</span>),</span><br><span class="line">            nn.BatchNorm1d(<span class="number">120</span>),</span><br><span class="line">            nn.Sigmoid(),</span><br><span class="line">            nn.Linear(<span class="number">120</span>, <span class="number">84</span>),</span><br><span class="line">            nn.BatchNorm1d(<span class="number">84</span>),</span><br><span class="line">            nn.Sigmoid(),</span><br><span class="line">            nn.Linear(<span class="number">84</span>, <span class="number">10</span>)</span><br><span class="line">        )</span><br></pre></td></tr></table></figure><p>可以试试把这个加到自己的module里,</p><blockquote><p>它就是个插件,可以加上它,而不用对其他东西做任何修改,我觉着挺好的</p></blockquote><h3 id="残差网络ResNet">残差网络ResNet</h3><p>我饿了🥱🥱🥱不学了.</p><h2 id="RNN">RNN</h2><h3 id="RNN的一个重要应用就是语言模型">RNN的一个重要应用就是语言模型</h3><p>假设一段长度为$T$的文本中的词依次为$w_1, w_2, \ldots, w_T$，那么在离散的时间序列中，$w_t$（$1 \leq t \leq T$）可看作在时间步（time step）$t$的输出或标签。给定一个长度为$T$的词的序列$w_1, w_2, \ldots, w_T$，语言模型将计算该序列的概率：</p><p>$$<br>P(w_1, w_2, \ldots, w_T).<br>$$<br>假设序列$w_1, w_2, \ldots, w_T$中的每个词是依次生成的，我们有</p><p>$$<br>P(w_1, w_2, \ldots, w_T) = \prod_{t=1}^T P(w_t \mid w_1, \ldots, w_{t-1}).<br>$$</p><h4 id="n元语法">n元语法</h4><p>当序列长度增加时，计算和存储多个词共同出现的概率的复杂度会呈指数级增加。$n$元语法通过马尔可夫假设（虽然并不一定成立）简化了语言模型的计算。这里的马尔可夫假设是指一个词的出现只与前面$n$个词相关，即$n$阶马尔可夫链（Markov chain of order $n$）。如果$n=1$，那么有$P(w_3 \mid w_1, w_2) = P(w_3 \mid w_2)$。如果基于$n-1$阶马尔可夫链，我们可以将语言模型改写为</p><p>$$<br>P(w_1, w_2, \ldots, w_T) \approx \prod_{t=1}^T P(w_t \mid w_{t-(n-1)}, \ldots, w_{t-1}) .<br>$$</p><h3 id="我理解的RNN">我理解的RNN</h3><p>上面的例子:把一个句子看做词序列,每个时间步产生一个词…当序列长度增加时，计算和存储多个词共同出现的概率的复杂度会呈指数级增加。但是,我们可以通过一个隐藏变量来传递前面几个时间步的信息…该隐藏变量也称为隐藏状态。由于隐藏状态在当前时间步的定义使用了上一时间步的隐藏状态，上式的计算是循环的。</p><h4 id="例子-2">例子</h4><p>引入一个新的权重参数${W}_{hh} \in {R}^{h \times h}$，该参数用来描述在当前时间步如何使用上一时间步的隐藏变量。具体来说，时间步$t$的隐藏变量的计算由当前时间步的输入和上一时间步的隐藏变量共同决定：</p><p>$$<br>{H}<em>t = \phi({X}<em>t{W}</em>{xh}+{H}</em>{t-1}{W}_{hh}+{b}_h)<br>$$</p><p>其中${H}_{t-1}$就是上一个时间步的隐藏变量</p><p><img src="/img/learn_torch.assets/6.2_rnn.svg" alt="img"></p><h3 id="构建数据集">构建数据集</h3><p>对时序数据的采样方式有如下两种(采样就是选取batchsize个样本,如果batchsize=1,那么就不需要考虑如何采样了)</p><ol><li class="lvl-3"><h5 id="随机采样">随机采样</h5><p>在数据集中随机选取batchsize个样本,由于不同样本之间是独立的,所以不能直接把上个样本计算后的隐藏状态传给下个样本作为初始隐藏状态</p></li><li class="lvl-3"><h5 id="相邻采样">相邻采样</h5><p>字面意思,在数据集中选取相邻的batchsize个样本,这样只需在每一个迭代周期开始时初始化隐藏状态.</p><p>但是这样计算梯度时会依赖所有序列??</p><p>为了使模型参数的梯度计算只依赖一次迭代读取的小批量序列，我们可以在每次读取小批量前将隐藏状态从计算图中分离出来。</p></li></ol><h3 id="RNN的实现">RNN的实现</h3><blockquote><p>我终于明白了,我们好像只需要关注不同layer的输入输出形状…</p><p>至于我的net为什么有他们,who ™ cares??</p></blockquote><p>PyTorch中的<code>nn</code>模块提供了循环神经网络的实现。下面构造一个含单隐藏层、隐藏单元个数为256的循环神经网络层<code>rnn_layer</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num_hiddens = <span class="number">256</span></span><br><span class="line">rnn_layer = nn.RNN(input_size=vocab_size, hidden_size=num_hiddens)</span><br></pre></td></tr></table></figure><h5 id="native-rnn-layer的输入">native rnn_layer的输入</h5><p><code>rnn_layer</code>的输入形状为(时间步数, 批量大小,<mark>input_size</mark>)</p><p>就是有点别扭.</p><ul class="lvl-0"><li class="lvl-2"><p>第一个时间步数就是句子长度</p></li><li class="lvl-2"><p>第二个批量大小,我真无语,为什么要把批量大小放在第二个,感觉不是很直观.所以cnn和rnn的数据不能直接通用,要view一下交换一下前两个维度?还是别的什么维度</p></li><li class="lvl-2"><p>第三个inut_size;这里和cnn不同,如果说cnn的input单元是句子整体.那么RNN的input实际上是词向量.所以说如果是one-hot,那么就是vocab_size;如果已经word2vec后,就是<strong>词向量的长度</strong>…这里注意一下不同教程的区别.</p></li></ul><h5 id="native-rnn-layer的输出">native rnn_layer的输出</h5><p>形状为(时间步数, 批量大小, 隐藏单元个数)。</p><p>前向计算后会分别返回输出和隐藏状态h，其中输出指的是隐藏层在<strong>各个时间步</strong>上计算并输出的隐藏状态，它们通常作为后续输出层的输入。参考下图(这是LSTM,和RNN本身不很一样)</p><p><img src="/img/learn_torch.assets/6.5.png" alt="img"></p><h3 id="门控循环单元GRU">门控循环单元GRU</h3><p>当时间步数较大或者时间步较小时，循环神经网络的梯度较容易出现衰减或爆炸。虽然裁剪梯度可以应对梯度爆炸，但无法解决梯度衰减的问题。通常由于这个原因，循环神经网络在实际中较难捕捉时间序列中时间步距离较大的依赖关系。</p><p><strong>GRU</strong>就是为了解决上述问题</p><p>GRU包含重置门和更新门,计算图如下</p><p><img src="/img/learn_torch.assets/6.7_gru_3.svg" alt="img"></p><blockquote><p>简单来说,就是如果前面时间步的输入已经和这次输出没太大关系,重置门会重置隐藏状态</p><p>如果这次输入不太影响后面内容,更新门会把之前的隐藏状态传递下去.</p><ul class="lvl-1"><li class="lvl-2"><p>重置门有助于捕捉时间序列里短期的依赖关系；</p></li><li class="lvl-2"><p>更新门有助于捕捉时间序列里长期的依赖关系。</p></li></ul></blockquote><p><mark>注意</mark>:上面完全不需要理解.反正有native的GRU模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lr = <span class="number">1e-2</span> <span class="comment"># 注意调整学习率</span></span><br><span class="line">gru_layer = nn.GRU(input_size=vocab_size, hidden_size=num_hiddens)</span><br></pre></td></tr></table></figure><h3 id="长短期记忆LSTM">长短期记忆LSTM</h3><p>另一种门控循环神经网络是LSTM（long short-term memory,长短期记忆)</p><blockquote><p>你看这名字,这不是和刚才的门干了一样的事吗??</p></blockquote><p>LSTM 中引入了3个门，即输入门（input gate）、遗忘门（forget gate）和输出门（output gate），以及与隐藏状态形状相同的记忆细胞，从而记录额外的信息。</p><p><mark>同样地</mark>,可以直接调用<code>rnn</code>模块中的<code>LSTM</code>类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lr = <span class="number">1e-2</span> <span class="comment"># 注意调整学习率</span></span><br><span class="line">lstm_layer = nn.LSTM(input_size=vocab_size, hidden_size=num_hiddens)</span><br></pre></td></tr></table></figure><p><img src="/img/learn_torch.assets/6.8_lstm_2.svg" alt="img"></p><p>如果你想理解,我把图放这了.</p><p>我的理解是,这其实就是显示地干了GRU的活.</p><blockquote><ul class="lvl-1"><li class="lvl-2"><p>如果遗忘门与记忆细胞做$\odot$趋于1,那么就会倾向于保存下之前的记忆,如果趋于0就会遗忘</p></li><li class="lvl-2"><p>如果输入门与候选记忆细胞做$\odot$趋于1,那么就会倾向于更新记忆,如果趋于0就不会更新</p></li></ul></blockquote><h3 id="更复杂的模型">更复杂的模型</h3><h4 id="深度循环神经网络">深度循环神经网络</h4><p>目前为止介绍的循环神经网络只有一个单向的隐藏层，在深度学习应用里，我们通常会用到含有多个隐藏层的循环神经网络，也称作深度循环神经网络。下图演示了一个有L个隐藏层的深度循环神经网络，每个隐藏状态不断传递至当前层的下一时间步和当前时间步的下一层。</p><p><img src="/img/learn_torch.assets/6.9_deep-rnn.svg" alt="img"></p><h4 id="双向循环神经网络">双向循环神经网络</h4><p>之前介绍的循环神经网络模型都是假设当前时间步是由前面的较早时间步的序列决定的，因此它们都将信息通过隐藏状态从前往后传递。有时候，当前时间步也可能由后面时间步决定。例如，当我们写下一个句子时，可能会根据句子后面的词来修改句子前面的用词。双向循环神经网络通过增加从后往前传递信息的隐藏层来更灵活地处理这类信息。</p><p><img src="/img/learn_torch.assets/6.10_birnn.svg" alt="img"></p><blockquote><p>上面两个我感觉挺靠谱的,但是没有示例代码,所以我就不管了</p></blockquote><blockquote><p>update:其实双向循环网络就是加个参数的事</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BiRNN</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, vocab, embed_size, num_hiddens, num_layers</span>):</span><br><span class="line">        <span class="built_in">super</span>(BiRNN, self).__init__()</span><br><span class="line">        self.embedding = nn.Embedding(<span class="built_in">len</span>(vocab), embed_size)</span><br><span class="line">        <span class="comment"># bidirectional设为True即得到双向循环神经网络</span></span><br><span class="line">        self.encoder = nn.LSTM(input_size=embed_size,</span><br><span class="line">                                hidden_size=num_hiddens,</span><br><span class="line">                                num_layers=num_layers,</span><br><span class="line">                                bidirectional=<span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># 初始时间步和最终时间步的隐藏状态作为全连接层输入</span></span><br><span class="line">        self.decoder = nn.Linear(<span class="number">4</span>*num_hiddens, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, inputs</span>):</span><br><span class="line">        <span class="comment"># inputs的形状是(批量大小, 词数)，因为LSTM需要将序列长度(seq_len)作为第一维，所以将输入转置后</span></span><br><span class="line">        <span class="comment"># 再提取词特征，输出形状为(词数, 批量大小, 词向量维度)</span></span><br><span class="line">        embeddings = self.embedding(inputs.permute(<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">        <span class="comment"># rnn.LSTM只传入输入embeddings，因此只返回最后一层的隐藏层在各时间步的隐藏状态。</span></span><br><span class="line">        <span class="comment"># outputs形状是(词数, 批量大小, 2 * 隐藏单元个数)</span></span><br><span class="line">        outputs, _ = self.encoder(embeddings) <span class="comment"># output, (h, c)</span></span><br><span class="line">        <span class="comment"># 连结初始时间步和最终时间步的隐藏状态作为全连接层输入。它的形状为</span></span><br><span class="line">        <span class="comment"># (批量大小, 4 * 隐藏单元个数)。</span></span><br><span class="line">        encoding = torch.cat((outputs[<span class="number">0</span>], outputs[-<span class="number">1</span>]), -<span class="number">1</span>)</span><br><span class="line">        outs = self.decoder(encoding)</span><br><span class="line">        <span class="keyword">return</span> outs</span><br></pre></td></tr></table></figure><blockquote><p>而多层就更不用教了…</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
          <category> PyTorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PyTorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>four-adder</title>
      <link href="/homework/DLCE/%E5%9B%9B%E4%BD%8D%E5%8A%A0%E6%B3%95%E5%99%A8REPORT/"/>
      <url>/homework/DLCE/%E5%9B%9B%E4%BD%8D%E5%8A%A0%E6%B3%95%E5%99%A8REPORT/</url>
      
        <content type="html"><![CDATA[<h1>四位加法器REPORT</h1><p>郭高旭 <a href="mailto:ggx21@mails.tsinghua.edu.cn">ggx21@mails.tsinghua.edu.cn</a> 2021010803</p><h2 id="实验目的">实验目的</h2><ul class="lvl-0"><li class="lvl-2"><p>掌握组合逻辑电路的基本分析方法与设计方法；</p></li><li class="lvl-2"><p>理解半加器、全加器、加法器的分析与设计方法；</p></li><li class="lvl-2"><p>学会元件例化；</p></li><li class="lvl-2"><p>学会利用软件仿真实现对数字电路的验证与分析</p></li></ul><h2 id="实验内容">实验内容</h2><ul class="lvl-0"><li class="lvl-2"><p>设计半加器</p></li><li class="lvl-2"><p>利用半加器构建全加器</p></li><li class="lvl-2"><p>使用全加器构造逐次进位加法器，超前进位加法器</p></li><li class="lvl-2"><p>使用 VHDL自带的加法运算实现一个 4 位全加器</p></li><li class="lvl-2"><p>查看逐次进位加法器、超前进位加法器和 VHDL 自带加法器在CPLD中生成的电路,并比较这三者的异同</p></li></ul><h2 id="不同加法器的RTL与仿真结果">不同加法器的RTL与仿真结果</h2><h4 id="超前进位加法器">超前进位加法器</h4><h5 id="仿真结果">仿真结果</h5><img src="/img/fouradder.assets/1.png" alt="image-20230502202851109" style="zoom:65%;" /><p>超前进位加法器延迟：End-Start=17.33ns</p><h5 id="RTL">RTL</h5><img src="/img/fouradder.assets/2.png" alt="image-20230502202851109" style="zoom:65%;" /><h4 id="简单进位加法器">简单进位加法器</h4><h5 id="RTL-2">RTL</h5><img src="/img/fouradder.assets/3.png" alt="image-20230502202851109" style="zoom:65%;" />##### 仿真结果<img src="/img/fouradder.assets/4.png" alt="image-20230502202851109" style="zoom:65%;" /><p>超前进位加法器延迟：End-Start=17.96ns</p><h4 id="原生加法器">原生加法器</h4><h5 id="RTL-3">RTL</h5><img src="/img/fouradder.assets/5.png" alt="image-20230502202851109" style="zoom:65%;" /><h4 id="代码">代码</h4><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LIBRARY</span> ieee;</span><br><span class="line"><span class="keyword">USE</span> ieee.std_logic_1164.<span class="keyword">ALL</span>;</span><br><span class="line"><span class="keyword">USE</span> ieee.std_logic_arith.<span class="keyword">ALL</span>;</span><br><span class="line"><span class="keyword">USE</span> ieee.std_logic_unsigned.<span class="keyword">ALL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTITY</span> native_adder <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">PORT</span> (</span><br><span class="line">a, b : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line">c0 : <span class="keyword">IN</span> <span class="built_in">STD_LOGIC</span>;</span><br><span class="line">f : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line">c3 : <span class="keyword">OUT</span> <span class="built_in">STD_LOGIC</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">END</span> nativee_adder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ARCHITECTURE</span> plus <span class="keyword">OF</span> native_adder <span class="keyword">IS</span></span><br><span class="line"><span class="keyword">signal</span> buf: <span class="built_in">STD_LOGIC_VECTOR</span>(<span class="number">4</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="keyword">process</span>(a, b, c0)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">buf &lt;= <span class="string">&quot;00000&quot;</span>+ a + b + c0;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">process</span>;</span><br><span class="line"><span class="keyword">process</span> (buf)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">f &lt;= buf(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>);</span><br><span class="line">c3 &lt;= buf(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">process</span>;</span><br><span class="line"><span class="keyword">END</span> plus;</span><br></pre></td></tr></table></figure><h5 id="仿真结果-2">仿真结果</h5><img src="/img/fouradder.assets/6.png" alt="image-20230502202851109" style="zoom:65%;" /><p>原生加法器延时：10.03ns</p><h3 id="总结：">总结：</h3><p>我实现的超前进位加法器比普通进位加法器延迟略小。但原生加法器延时远小于我实现的。</p><h2 id="电路功能测试的结果">电路功能测试的结果</h2><ul class="lvl-0"><li class="lvl-2"><p>实际功能测试结果从计算结果上来说和仿真测试结果相同</p></li><li class="lvl-2"><p>实验时的延迟效果几乎都无法感知</p></li></ul><h2 id="调试中遇到的问题">调试中遇到的问题</h2><ul class="lvl-0"><li class="lvl-2"><p>对仿真操作不够熟悉，在学习仿真时花费了很多时间。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> homework </category>
          
          <category> DLCE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> homework </tag>
            
            <tag> DLCE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DLC</title>
      <link href="/notes/DLC/%E8%A7%A6%E5%8F%91%E5%99%A8/"/>
      <url>/notes/DLC/%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="触发器">触发器</h2><h3 id="基本R-S触发器">基本R-S触发器</h3><h3 id="电位触发方式的触发器">电位触发方式的触发器</h3><h3 id="边沿触发方式的触发器">边沿触发方式的触发器</h3><ul class="lvl-0"><li class="lvl-2"><p>正边沿触发方式？</p><blockquote><p>分析电路？我还不会。什么阻塞不阻塞的</p></blockquote></li><li class="lvl-2"><p>负边沿触发方式？jk触发</p><blockquote><p>可以等同于jk触发方式吗?讨厌jk,完全不会</p></blockquote></li></ul><h3 id="主－从触发方式的触发器">主－从触发方式的触发器</h3><p>由两级电位触发器（主触发器和从触发器）串连而成</p><ul class="lvl-0"><li class="lvl-2"><p>CP=1期间，主触发器接收数据，从触发器封锁</p></li><li class="lvl-2"><p>在负跳变到来时，主触发器封锁，从触发器将接收CP负跳变时主触发器的状态。</p></li></ul><h4 id="主从R-S触发器的功能表">主从R-S触发器的功能表</h4><p>和基本R-S一样，（cp一个正脉冲，一个负脉冲）。大概只是为了保证触发器的稳定。</p><h2 id="同步时序逻辑电路的分析">同步时序逻辑电路的分析</h2><ol><li class="lvl-3"><p>列出状态关系</p><p>大概就是列出${Q_i}_{n+1}与{Q_i}_n$之间的递推关系</p><blockquote><ul class="lvl-3"><li class="lvl-2"><p>对于D触发器来说$Q_i’=D_i$</p></li><li class="lvl-2"><p>对于JK触发器来说$Q_i’=J\bar Q+\bar KQ$</p><blockquote><p>因为我并不会jk触发器,这一条实在是难以理解.死记硬背吧</p></blockquote></li><li class="lvl-2"><p>至于D\J\K等于什么就再说了</p><blockquote><p>你D可以和输入以及$Q_i$有关.J和K有必要吗?有.下标漏掉了应该是$Q_i’=J\bar Q_i+\bar KQ_i$还有$Q_j$呢</p></blockquote></li></ul></blockquote></li><li class="lvl-3"><p>列出状态表</p><p>根据上面内容可以列出状态表</p></li><li class="lvl-3"><p>画出状态图</p><ul class="lvl-2"><li class="lvl-5">如果有输入,那么就是一个状态机(自动机)</li><li class="lvl-5">否则就是一个退化了的状态机(每个结点只有一个出边)</li></ul></li><li class="lvl-3"><p>画出时序图</p><ul class="lvl-2"><li class="lvl-5">每一帧CP都是高低</li><li class="lvl-5">每一帧输入最多变一次</li><li class="lvl-5">根据状态图画时序图</li></ul><blockquote><p>这又不考虑延迟.都是理想状态,大概还挺简单的</p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
          <category> DLC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DLC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Somniloquy-3</title>
      <link href="/Somniloquy/dream-3/"/>
      <url>/Somniloquy/dream-3/</url>
      
        <content type="html"><![CDATA[<p>这是什么?<a href="/2023/04/28/Somniloquy/dream-0/">这篇README</a>大概也不能告诉你.</p><h2 id="10：18">10：18</h2><p>昨天晚上调整了本地文件的组织方式。这导致我页面的permalink基本全改变了。本来还有些评论的，这下全没了😢😢😢</p><h2 id="16：00">16：00</h2><p>太依赖gpt，已经丧失了动脑子的能力了。再也不能从代码里获得什么成就感了。是好是坏呢？总归是把graphics pa2干完了。这不就是把给的python参考翻译一遍。</p><h2 id="19：20">19：20</h2><p>桃李吃晚饭，土豆炖牛肉给我上了个夹生的。看在他给我换了两道菜的情况下就不骂了。<br><img src="\img\dream-3\1.jpg" style="zoom: 15%;" /></p><p>土豆烧牛肉换辣子鸡+西红柿炒鸡蛋，还可以吗？</p><p><strong>妈的，iai就给我92分。凭什么。</strong></p><h2 id="22-32">22:32</h2><p>心情突然很down，游戏也打不动了。意义是什么呢？在紫操溜溜，没有变好。<br>😿😿😿<br><img src="\img\dream-3\2.jpg" style="zoom: 25%;" /></p><h2 id="35-32">35:32</h2><p>爬了会儿格子，感到心情平静了些。竟然有这闲心。🚭🚭🚭</p>]]></content>
      
      
      <categories>
          
          <category> Somniloquy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> THU </tag>
            
            <tag> Somniloquy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>留言板</title>
      <link href="/others/comment/"/>
      <url>/others/comment/</url>
      
        <content type="html"><![CDATA[<p>这里专门为了评论.</p><p>但是你需要登录一下GitHub.</p><p>有没有更好的方式呢?</p><p>😶‍🌫️😶‍🌫️😶‍🌫️😶‍🌫️😶‍🌫️</p>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> comment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Somniloquy_2</title>
      <link href="/Somniloquy/dream-2/"/>
      <url>/Somniloquy/dream-2/</url>
      
        <content type="html"><![CDATA[<p>这是什么?<a href="/2023/04/28/Somniloquy/dream-0/">这篇README</a>大概也不能告诉你.</p><h2 id="8：00">8：00</h2><p>昨天晚上被g44拉了壮丁，练了一晚上拔河。今早上勇夺亚军。挺好的，有点事干总比天天胡思乱想好.<br><img src="/img/dream-2/1.jpg" style="zoom: 25%;" /></p><h2 id="11-36">11:36</h2><p>天天搞这前端玩物丧志，搞个<a href="/2023/04/30/homework/deadlines/">deadline页面</a>搞到现在。<br><strong>又没人看。</strong><br>一天到晚写些小学生流水帐😄中厅很安静。突然觉着这样写markdown与typora相比也挺舒服的。</p><h2 id="12：00">12：00</h2><p>看着窗外的云发呆。小时候天天看着云从这边飘到那边，现在一天到晚对着电子屏幕，为了什么呢？</p><p>昨天晚上还在和人说，感觉自己还是很有耐心。今天干了些事，发现耐心消耗殆尽了。<br>🤡🤡🤡<br><img src="/img/dream-2/2.jpg" style="zoom: 25%;" /></p><h2 id="15-05">15:05</h2><p>再写前端我就是那个<br>🐒🐒🐒🐒</p><h2 id="19：36">19：36</h2><p>本月只点了3次外卖。感觉生活变健康了。</p><p>但我是统计了红包使用次数得出来的数据，感觉大亏特亏。😿</p>]]></content>
      
      
      <categories>
          
          <category> Somniloquy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> THU </tag>
            
            <tag> Somniloquy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PA2 REPORT</title>
      <link href="/homework/graphics/PA2REPORT/"/>
      <url>/homework/graphics/PA2REPORT/</url>
      
        <content type="html"><![CDATA[<h1>图形学PA2 REPORT</h1><p>郭高旭 <a href="mailto:ggx21@mails.tsinghua.edu.cn">ggx21@mails.tsinghua.edu.cn</a> 2021010803</p><h2 id="曲线性质">曲线性质</h2><h3 id="两种曲线的异同">两种曲线的异同</h3><p>相同点：</p><ol><li class="lvl-3"><p>都是基于控制点构造出的曲线；</p></li><li class="lvl-3"><p>都是多项式参数曲线，不能表示圆等曲线</p></li><li class="lvl-3"><p>都可以表示一条平滑的曲线。</p></li></ol><p>不同点：</p><ol><li class="lvl-3"><p>局部修改：</p><ul class="lvl-2"><li class="lvl-5">B 样条是局部的，容易对曲线进行修改、扩展和截断，而这些修改对曲线的其他部分几乎没有影响。</li><li class="lvl-5">Bezier曲线/曲面不支持局部的修改和编辑。</li></ul></li><li class="lvl-3"><p>拼接：B样条曲线可以拼接，Bezier曲线/曲面拼接时，满足几何连续性条件是十分困难的。</p></li><li class="lvl-3"><p>B样条曲线具有下面一系列好的性质</p><ul class="lvl-2"><li class="lvl-5">仿射不变性</li><li class="lvl-5">直线保持性</li><li class="lvl-5">凸包性</li><li class="lvl-5">变差缩减性</li><li class="lvl-5">几何不变性</li><li class="lvl-5">etc.</li></ul></li></ol><h3 id="怎样绘制一个首尾相接且接点处也有连续性质的-B-样条">怎样绘制一个首尾相接且接点处也有连续性质的 B 样条</h3><ul class="lvl-0"><li class="lvl-2"><p>首尾相接：</p><p>将控制点复制一遍，在第一组控制点前面加入最后一组控制点，最后一组控制点后面加入第一组控制点。</p></li><li class="lvl-2"><p>保持连续性质</p><p>通过设置相邻控制顶点的位置和导数值相等来保证一阶连续性</p></li></ul><h2 id="代码逻辑">代码逻辑</h2><ol><li class="lvl-3"><p>首先通过discretize获取我刚刚实现的curve（一系列点的三维坐标V以及曲线在这一点的切向量T）</p></li><li class="lvl-3"><p>指定旋转步数step，进而获得每次旋转的角度θ</p></li><li class="lvl-3"><p>旋转：</p><ol><li class="lvl-6">构造一个绕y轴（<strong>Vector3f</strong>::UP）旋转、$\theta$的rot</li><li class="lvl-6">获得曲线在该点的法向</li><li class="lvl-6">点的位置向量和法向量同rot进行乘法运算，得到新的点的位置向量和法向量</li><li class="lvl-6">循环上述过程一周</li></ol></li><li class="lvl-3"><p>将修改后控制点坐标pnew和法向量nnew存入到新构造的曲面数组(<a href="http://surface.xn--vvsurface-rw9o.vn/">surface.VV和surface.VN</a>)中，用于面片的绘制</p></li><li class="lvl-3"><p>生成的顶点和法向量，通过三角化将曲面中的所有三角面片存入一个面片数组(surface.VF)中</p></li><li class="lvl-3"><p>将面片数组输入opengl，就可以画出整个曲面</p></li></ol><h2 id="代码参考">代码参考</h2><p>本次实验代码几乎完全仿照了提供的python代码实现。</p><p>具体来说，两种曲线类has a <strong>Bernstein</strong> B；通过构造一个Bernstein类实例来进行计算。</p><p>除此之外没有和其他同学进行讨论/参考其他代码。</p>]]></content>
      
      
      <categories>
          
          <category> homework </category>
          
          <category> graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> homework </tag>
            
            <tag> graphics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>network-homework-9</title>
      <link href="/homework/network/network9/"/>
      <url>/homework/network/network9/</url>
      
        <content type="html"><![CDATA[<h1>网原第九次作业</h1><p>郭高旭 2021010803 <a href="mailto:ggx21@mails.tsinghua.edu.cn">ggx21@mails.tsinghua.edu.cn</a></p><p>区域边界路由器ABR是跨越区域的，而自治系统边界路由器ASBR则不跨越AS</p><h2 id="第一题">第一题</h2><p>一个路由器刚接收到如下新的 IP 地址： 57.6.96.0/21, 57.6.104.0/21, 57.6.112.0/21 和<br>57.6.120.0/21。如果所有这些地址都使用同一条出境线路，试问它们可以被聚合吗？如果可以，它们被聚合到哪个地址上？如果不可以，请问为什么？</p><table><thead><tr><th>00111001</th><th>00000110</th><th>01100000</th><th>00000000</th></tr></thead><tbody><tr><td>00111001</td><td>00000110</td><td>01101000</td><td>00000000</td></tr><tr><td>00111001</td><td>00000110</td><td>01110000</td><td>00000000</td></tr><tr><td>00111001</td><td>00000110</td><td>01111000</td><td>00000000</td></tr></tbody></table><p>这几个地址的最长公共前缀为19，又公用一条出境线路，因此可以被聚合成57.6.96.0/19</p><h2 id="第二题">第二题</h2><ul class="lvl-0"><li class="lvl-2"><p>更新后的路由表</p><table><thead><tr><th>目的网络</th><th>距离</th><th>下一跳</th></tr></thead><tbody><tr><td>N1</td><td>7</td><td>A</td></tr><tr><td>N3</td><td>3</td><td>C</td></tr><tr><td>N4</td><td>9</td><td>C</td></tr><tr><td>N6</td><td>8</td><td>F</td></tr><tr><td>N7</td><td>5</td><td>C</td></tr><tr><td>N8</td><td>3</td><td>C</td></tr><tr><td>N9</td><td>4</td><td>D</td></tr></tbody></table><ol><li class="lvl-5"><p>路由器 B 接收到路由器 C 发送的距离向量报文，该报文包含了目的网络 N2、N3、N4、N7 和 N8 的距离信息，以及这些网络的下一跳路由器 C 的信息。</p></li><li class="lvl-5"><p>路由器 B 在更新它的路由表前，需要计算距离向量。</p></li><li class="lvl-5"><p>$$<br>\pi(i){\leftarrow} min[\pi(i),min(\pi(i)+w_{ji})]<br>$$</p></li></ol></li><li class="lvl-2"><p>路由器 B 收到从路由器 C 发往网络 N2 的 IP 分组时，会发现距离 N2 的距离为 16，显然这已经超出了最大跳数（默认最大跳数为 15），因此路由器 B 会丢弃该分组。路由器 B 会将这条信息告知其它相邻路由器，以便它们也能更新自己的路由表。</p></li></ul><h2 id="第三题">第三题</h2><table><thead><tr><th>目的网络</th><th>下一跳</th><th>接口</th></tr></thead><tbody><tr><td>AS1</td><td>153.14.3.2</td><td>S0</td></tr><tr><td>194.17.5.128/25</td><td></td><td>E0</td></tr><tr><td>194.17.20.0/23</td><td>194.17.24.2</td><td>S1</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>根据最长前缀匹配原则，通过E0接口</p></li><li class="lvl-2"><p>BGP（eBGP），TCP协议，</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> homework </category>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> homework </tag>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有趣的事</title>
      <link href="/articles/funny-things/"/>
      <url>/articles/funny-things/</url>
      
        <content type="html"><![CDATA[<h1>文采不错</h1><p>二零二一年的夏天，<s>xxx</s>十七岁，第一次鼓起勇气，和喜欢的女孩子告白。那是生命中美丽的一天，阳光还算得上明媚，楼宇间轻风阵阵，远处悠扬的蝉鸣声，抚慰少年胸怀。两人肩并肩坐在公园的长椅上，观察一张张年轻和老去的面孔。东风一劲，女孩身体靠近，发丝飞舞。几个月后，<s>xxx</s>发现对方不喜欢吃新鲜的胡萝卜，感到兴味索然，和她提出分手。霓虹灯下的哨兵 2023-04-28</p>]]></content>
      
      
      <categories>
          
          <category> articles </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nsfw </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Somniloquy_1</title>
      <link href="/Somniloquy/dream-1/"/>
      <url>/Somniloquy/dream-1/</url>
      
        <content type="html"><![CDATA[<p>这是什么?<a href="2023/04/28/Somniloquy/dream-0/">这篇README</a>大概也不能告诉你.</p><h1>周五</h1><img src="/img/dream-talk-1.assets/rainInBeijing.jpg" style="zoom: 25%;" /><p>北京下了大暴雨。我没有带伞，淋成了落汤鸡。</p><p>最近有些无聊了，淋雨、洗澡、敲代码时明明跟自己说了很多话，结果只剩上面两句了。</p><img src="/img/dream-talk-1.assets/breakfast.jpg" style="zoom: 25%;" /><p>对了，连着两天吃了早饭，挺好的；但是连着两天四小时充足睡眠，不太妙。<em>出现幻觉头晕目眩1:11</em> 😵</p><p>同学生日，大家聚餐了。我没去。</p><p>😄</p><h2 id="light-up-my-day">light up my day</h2><img src="\img\dream-talk-1.assets\Snipaste_2023-04-28_23-46-31.png" style="zoom: 85%;" /><h2 id="life-goes-on">life goes on</h2><blockquote><p>玩物丧志</p></blockquote><ul class="lvl-0"><li class="lvl-2"><p>这一切的意义是？</p></li><li class="lvl-2"><p>可听到雷声阵阵，可感到危险来临</p></li><li class="lvl-2"><p>真是下贱</p></li><li class="lvl-2"><p>微笑着就倒在血泊中,还在担心别人比我疼</p></li><li class="lvl-2"><p>其实我是个<a href="https://tool.liumingye.cn/music/#/search/M/song/%E8%A0%A2%E8%B4%A7">蠢货</a></p></li><li class="lvl-2"><p>time is up,deal is over</p></li><li class="lvl-2"><p>我应该更关注爱我的人才对</p></li><li class="lvl-2"><p>我被这么多人爱着,我真是天底下最幸福的小孩</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Somniloquy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> THU </tag>
            
            <tag> Somniloquy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Somniloquy_README</title>
      <link href="/Somniloquy/dream-0/"/>
      <url>/Somniloquy/dream-0/</url>
      
        <content type="html"><![CDATA[<h1>README-README</h1><p>正经人谁写日记呢？</p><blockquote><p>Create this blog just in case I want to write anything (well that may never happen 😃)</p></blockquote><p>我想每周更新一个文件是一个合理的频率。</p><p>大概想到什么就写点什么。</p><p>我是不是可以给自己评论一下，这样你不登录github也能给我点赞？</p><p>我不知道。我不知道。</p><p>意义是？……</p><p>估计也不会有什么排版。</p><p>也许以后我会把梦话和梦里的内容分开。</p><p>这个category完全是梦中的情节，都是假的，不是真的。</p>]]></content>
      
      
      <categories>
          
          <category> Somniloquy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> THU </tag>
            
            <tag> Somniloquy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello 沸羊羊</title>
      <link href="/articles/feiyangyang/"/>
      <url>/articles/feiyangyang/</url>
      
        <content type="html"><![CDATA[<p>我是沸羊羊，一只聪明又机智的羊。在这草原上，我被称为小霸王。可是，我有一颗温柔的心，曾经深深地爱上了美羊羊。</p><p>可惜，美羊羊看不到我这颗真挚的心。她总是被那些华丽而无脑的花瓶吸引，哪怕他们只会说些毫无意义的话语。我才不会像他们那样肤浅呢。</p><p>我曾经为了她的芳心不惜一切，可是她却视而不见。我想起这段经历，不禁感叹美羊羊真是没有眼光。毕竟，在这么多羊中，我沸羊羊才是最出色的啊！</p><p>不过，没关系，因为我也许早就准备好了面对这个结果。沸羊羊也许只有美羊羊才能陪伴我，可有些羊比美羊羊更加值得我去爱。我会欣然接受这个事实，因为我自信有一个真正的爱情会出现在我的身边。</p>]]></content>
      
      
      <categories>
          
          <category> articles </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 沸羊羊 </tag>
            
            <tag> 美羊羊 </tag>
            
            <tag> gpt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello YUX</title>
      <link href="/articles/hello-YUX/"/>
      <url>/articles/hello-YUX/</url>
      
        <content type="html"><![CDATA[<h1>我在华清大学的“快乐”</h1><p>如果你问我在华清大学是否很快乐，那么我要告诉你，非常快乐。当然，这种快乐并不是所有人都能理解的。</p><p>在华清大学，我曾经快乐地熬了一个通宵写论文，因为我很享受那种极度的疲惫和奋斗的感觉。我还快乐地经历了一场期末考试，因为我发现自己完全不懂老师讲的内容，这让我有机会尝试新的解题方法。</p><p>当然，我在华清大学也曾经快乐地经历了各种各样的挫折，比如我一次考试只得了50分，就当做了一次锻炼自己的心态。还有一次莫名其妙被拒绝的实习机会，就让我意识到了自己要更加努力才能达到期望。</p><p>总之，在华清大学的这几年，我真的很快乐。虽然每天都要面对各种形形色色的压力和不确定性，但这些经历让我成长了许多。所以，我要感谢华清大学这个“快乐”的地方，让我有机会成为更好的自己。</p><!-- About Me --><div class="container">    <div class="row">        <div class="col-md-12">            <h2>About Me</h2>        </div>    </div>    <div class="row">        <div class="col-md-4">            <img src="/img/profile.png" alt="Profile Image">        </div>        <div class="col-md-8">            <p>Hi, I am YUX and I am passionate about NOTHING. </p>        </div>    </div></div>]]></content>
      
      
      <categories>
          
          <category> articles </category>
          
      </categories>
      
      
        <tags>
            
            <tag> THU </tag>
            
            <tag> THU-daily </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>crawler-sample</title>
      <link href="/others/code-test/"/>
      <url>/others/code-test/</url>
      
        <content type="html"><![CDATA[<h1>code-test</h1><blockquote><p>这是一个用来测试代码显示效果的页面。</p><p>你也可以用它爬点东西</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.service <span class="keyword">import</span> Service <span class="keyword">as</span> ChromeService</span><br><span class="line"><span class="keyword">from</span> webdriver_manager.chrome <span class="keyword">import</span> ChromeDriverManager</span><br><span class="line"><span class="comment"># from fake_useragent import UserAgent</span></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DynCrawler</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,url,theme</span>):</span><br><span class="line">        self.url = url</span><br><span class="line">        self.theme = theme</span><br><span class="line">        self.options=webdriver.ChromeOptions() <span class="comment"># 无头模式</span></span><br><span class="line">        self.options.add_argument(<span class="string">&#x27;--headless&#x27;</span>)</span><br><span class="line">        self.driver = webdriver.Chrome(service=ChromeService(executable_path=ChromeDriverManager().install()),options=self.options)</span><br><span class="line">        self.href_list=[]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_whole_page</span>(<span class="params">self</span>):</span><br><span class="line">        html_page=self.driver.find_elements(By.XPATH,<span class="string">&#x27;//*[@class=&quot;list-t&quot;]/a&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> page <span class="keyword">in</span> html_page:</span><br><span class="line">            url =page.get_attribute(<span class="string">&#x27;href&#x27;</span>)</span><br><span class="line">            title=page.text</span><br><span class="line">            data = &#123;<span class="string">&quot;url&quot;</span>:<span class="built_in">str</span>(url),<span class="string">&quot;title&quot;</span>:<span class="built_in">str</span>(title)&#125;</span><br><span class="line">            self.href_list.append(data)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;get page: &quot;</span>,url)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_images</span>(<span class="params">self,url,title</span>):</span><br><span class="line">        self.driver.get(url)</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line">        images=self.driver.find_elements(By.XPATH,<span class="string">&#x27;//div[@class=&quot;content&quot;]/a/img&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> index,image <span class="keyword">in</span> <span class="built_in">enumerate</span>(images):</span><br><span class="line">            image_url=image.get_attribute(<span class="string">&#x27;src&#x27;</span>)</span><br><span class="line">            <span class="built_in">print</span>(image_url)</span><br><span class="line">            <span class="keyword">if</span> image_url:</span><br><span class="line">                image_name=index+<span class="number">1</span></span><br><span class="line">                image_name=<span class="built_in">str</span>(image_name)+<span class="string">&#x27;.jpg&#x27;</span></span><br><span class="line">                image_path=<span class="string">f&#x27;./<span class="subst">&#123;self.theme&#125;</span>/<span class="subst">&#123;title&#125;</span>/<span class="subst">&#123;image_name&#125;</span>&#x27;</span></span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(image_path,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    <span class="keyword">try</span>:</span><br><span class="line">                        f.write(requests.get(image_url).content)</span><br><span class="line">                    <span class="keyword">except</span>:</span><br><span class="line">                        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_title</span>(<span class="params">self,url</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;get title: &quot;</span>,url)</span><br><span class="line">        self.driver.get(url)</span><br><span class="line">        time.sleep(<span class="number">0.5</span>)</span><br><span class="line">        title=self.driver.find_element(By.XPATH,<span class="string">&#x27;//*[@id=&quot;app&quot;]/div/div[3]/div[1]/div[1]/h1&#x27;</span>)</span><br><span class="line">        title=title.text</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;title: &quot;</span>,title)</span><br><span class="line">        <span class="keyword">return</span> title</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(self.theme):</span><br><span class="line">            os.mkdir(self.theme)</span><br><span class="line">        self.driver.get(self.url)</span><br><span class="line">        self.driver.implicitly_wait(<span class="number">2</span>)</span><br><span class="line">        self.get_whole_page()</span><br><span class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> self.href_list:</span><br><span class="line">            url=data[<span class="string">&#x27;url&#x27;</span>]</span><br><span class="line">            title=data[<span class="string">&#x27;title&#x27;</span>]</span><br><span class="line">            title=title.replace(<span class="string">&#x27;/&#x27;</span>,<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            title=title.replace(<span class="string">&#x27;|&#x27;</span>,<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            title=title.replace(<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            title=title.replace(<span class="string">&#x27;：&#x27;</span>,<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            <span class="comment"># make dir</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(<span class="string">f&#x27;./<span class="subst">&#123;self.theme&#125;</span>/<span class="subst">&#123;title&#125;</span>&#x27;</span>):</span><br><span class="line">                os.mkdir(<span class="string">f&#x27;./<span class="subst">&#123;self.theme&#125;</span>/<span class="subst">&#123;title&#125;</span>&#x27;</span>)</span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">f&#x27;./<span class="subst">&#123;self.theme&#125;</span>/<span class="subst">&#123;title&#125;</span>/url.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    f.write(url)</span><br><span class="line">                self.get_images(url,title)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;请输入歌手名字：&#x27;</span>)</span><br><span class="line">    singername=<span class="built_in">input</span>()</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">8</span>):</span><br><span class="line">        url=<span class="string">f&#x27;http://www.echangwang.com/singer/<span class="subst">&#123;singername&#125;</span>_<span class="subst">&#123;index&#125;</span>.html&#x27;</span></span><br><span class="line">        crawler=DynCrawler(url,singername)</span><br><span class="line">        crawler.run()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> homework </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>fool</title>
      <link href="/others/fool/"/>
      <url>/others/fool/</url>
      
        <content type="html"><![CDATA[<div class="danger"><p>时间紧，任务重，I’m f**ked up</p></div><div class="warning"><p>时间不多了,under pressure</p></div><div class="tips"><p>时间还早,totally under control</p></div><div class="success"><p>写完了😄</p></div><ul class="lvl-0"><li class="lvl-2"><p><input type="checkbox" id="checkbox32"><label for="checkbox32">uog</label><br><input type="checkbox" id="checkbox31"><label for="checkbox31">sdf</label></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test-markdown</title>
      <link href="/others/ful-test/"/>
      <url>/others/ful-test/</url>
      
        <content type="html"><![CDATA[<h1>标题示例</h1><h2 id="二级标题">二级标题</h2><h3 id="三级标题">三级标题</h3><h4 id="四级标题">四级标题</h4><h5 id="五级标题">五级标题</h5><h6 id="六级标题">六级标题</h6><h2 id="段落和换行">段落和换行</h2><p>这是一个段落，可以写一些文字。这个段落有两行。</p><p>这是第二个段落。使用两个以上的空格加上一个回车可以进行换行。</p><p>这是一个段落，可以写一些文字。这个段落有两行。</p><p>这是第二个段落。使用两个以上的空格加上一个回车可以进行换行。</p><p>使用 <code>**</code> 包裹的文字会变成 <strong>加粗</strong>。使用 <code>_</code> 包裹的文字会变成 <em>斜体</em>。可以在一段文字中混合使用。</p><p>使用 <code>~</code> 包裹的文字会变成 <s>删除线</s>。</p><p>使用 <code>==</code> 包裹的文字会变成高亮，如： <mark>高亮</mark>。</p><h2 id="列表示例">列表示例</h2><h3 id="无序列表">无序列表</h3><ul class="lvl-0"><li class="lvl-2"><p>项目一</p></li><li class="lvl-2"><p>项目二</p></li><li class="lvl-2"><p>项目三</p></li></ul><h3 id="有序列表">有序列表</h3><ol><li class="lvl-3"><p>第一项</p></li><li class="lvl-3"><p>第二项</p></li><li class="lvl-3"><p>第三项</p></li></ol><h3 id="可以使用嵌套列表：">可以使用嵌套列表：</h3><ol><li class="lvl-3"><p>第一项</p><ul class="lvl-2"><li class="lvl-5">嵌套项目</li><li class="lvl-5">嵌套项目</li></ul></li><li class="lvl-3"><p>第二项</p><ol><li class="lvl-6">嵌套有序项目</li><li class="lvl-6">嵌套有序项目</li></ol></li><li class="lvl-3"><p>第三项</p></li></ol><h2 id="引用示例">引用示例</h2><blockquote><p>这是一个引用。引用可以有多行。</p><blockquote><p>引用可以嵌套。</p></blockquote></blockquote><h2 id="粗体和斜体示例">粗体和斜体示例</h2><p>这里是 <strong>粗体</strong> 和 <em>斜体</em> 的示例。同样可以使用 <strong>粗体</strong> 和 <em>斜体</em>。</p><h2 id="链接和图片示例">链接和图片示例</h2><h3 id="链接">链接</h3><p>这是一个<a href="https://www.example.com/">链接</a>。</p><p>可以给链接加上标题：</p><p>这是一个<a href="https://www.example.com/" title="示例链接">链接</a>。</p><h3 id="图片">图片</h3><p>这是一个图片：</p><p><img src="/img/test.png" alt="图片描述"></p><p>也可以给图片加上标题：</p><p><img src="/img/test_profile.png" alt="图片描述" title="示例图片"></p><h2 id="代码块和公式块示例">代码块和公式块示例</h2><p>这是一个代码块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hello</span>():</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;Hello World!&quot;</span>)</span><br></pre></td></tr></table></figure><p>也可以使用单行代码块： <code>print(&quot;Hello World!&quot;)</code></p><p>这是一个公式块：<br>$$<br>f(x) = \frac{1}{\sqrt{2\pi}\sigma}e<sup>{-\frac{(x-\mu)</sup>2}{2\sigma^2}}<br>$$</p><h2 id="分隔线示例">分隔线示例</h2><p>这是一条分隔线：</p><hr><h2 id="表格示例">表格示例</h2><table><thead><tr><th>名称</th><th>价格</th></tr></thead><tbody><tr><td>商品 A</td><td>$20</td></tr><tr><td>商品 B</td><td>$30</td></tr><tr><td>商品 C</td><td>$40</td></tr></tbody></table><h2 id="文内链接">文内链接</h2><p>这是一个 <a href="#%E6%A0%87%E9%A2%98%E7%A4%BA%E4%BE%8B">内部链接</a> 到标题示例。</p><h2 id="目录示例">目录示例</h2><p>可以使用 <code>[toc]</code> 来生成目录，需要使用一些 Markdown 工具来渲染生成的目录。</p><p>[toc]</p><h2 id="表情符号示例">表情符号示例</h2><p>可以使用表情符号来增加一些个性化的元素：</p><p>👍 ✨ 🐫 🎉 🚀 🤘 :octocat:</p><h2 id="HTML-语法示例">HTML 语法示例</h2><p>Markdown 还支持 HTML 语法，如下面的加粗文字：</p><p><b>这是一段加粗的文字</b></p>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello world</title>
      <link href="/others/hello-world-1/"/>
      <url>/others/hello-world-1/</url>
      
        <content type="html"><![CDATA[<!-- Banner Image --><div class="banner">    <img src="/img/banner.png" alt="Banner Image">    <div class="banner-text">        <h1>Hello World</h1>        <p>A warm welcome to my blog!</p>    </div></div><!-- Introduction --><div class="container">    <div class="row">        <div class="col-md-12">            <h2>Introduction</h2>            <p>Welcome to my blog! My name is YUX and I am passionate about NOTHING. This blog is my platform to share my thoughts and experiences with you.</p>        </div>    </div></div><!-- About Me --><div class="container">    <div class="row">        <div class="col-md-12">            <h2>About Me</h2>        </div>    </div>    <div class="row">        <div class="col-md-4">            <img src="/img/profile.png" alt="Profile Image">        </div>        <div class="col-md-8">            <p>Hi, I am YUX and I am passionate about NOTHING. </p>        </div>    </div></div>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>network-homework-5</title>
      <link href="/homework/network/network5/"/>
      <url>/homework/network/network5/</url>
      
        <content type="html"><![CDATA[<h1>网原第五次作业</h1><p>郭高旭 2021010803 <a href="mailto:ggx21@mails.tsinghua.edu.cn">ggx21@mails.tsinghua.edu.cn</a></p><h3 id="1-地球与一个遥远行星通信">1.地球与一个遥远行星通信</h3><ol><li class="lvl-3"><p>路线单向延时<br>$$<br>T=9\frac{10<sup>{10}}{3\times10</sup>8}=300s<br>$$<br>采用停等协议，利用率为<br>$$<br>32 * 1000 * 86/(32 * 1000 * 8b + 2 * 64 * 1000000bps * 300s) = 6.66\times10^{-6}<br>$$</p></li><li class="lvl-3"><p>采用滑动窗口协议：</p><p>n = 2 * 300s/(32 * 1000 * 8b/64 * 1000000bps) + 1 = 150001</p></li></ol><h3 id="2-地球同步卫星的最大信道利用率">2.地球同步卫星的最大信道利用率</h3><ol><li class="lvl-3"><p>停等式</p><p>1000/(1000 + 2 * 1000000 * 270 + 1000) = 1/542</p></li><li class="lvl-3"><p>协议5</p><p>7 * 1000/(1000 + 2 * 1000000 * 270 + 1000) = 7/542</p></li><li class="lvl-3"><p>协议6</p><p>4 * 1000/(1000 + 2 * 1000000 * 270 + 1000) = 7/542</p></li></ol><h3 id="3-卫星信道最大吞吐量">3.卫星信道最大吞吐量</h3><p>512字节占⽤信道时间为T = 512 * 86/(64 * 1000bps) = 0.064s</p><ul class="lvl-0"><li class="lvl-2"><p>窗口大小为1</p><p>512 * 86/(0.064 + 0.270 * 2) = 6781bps</p></li><li class="lvl-2"><p>窗口大小为7</p><p>7 * 512 * 86/(0.064 + 0.270 * 2) = 47467bps</p></li><li class="lvl-2"><p>窗口大小15</p><p>由于信道最多容量为n = [(0.270 * 2 + 0.064)/0.064] =9  故吞吐量为64kbps</p></li><li class="lvl-2"><p>窗口大小127</p><p>同上，吞吐量为64kbs</p></li></ul><h3 id="4-主机之间帧序号的比特数">4.主机之间帧序号的比特数</h3><p>数据帧传输时间范围：$t_{min}$=$128\times{8b/32kbps}=0.032s$ ;$t_{max}$=$512\times{8b/32kbps}=0.128s$</p><p>最小窗口大小范围<br>$$<br>l_{min}=2\times0.3s/t_{max}=6;l_{max}=2\times0.3s/t_{min}=20<br>$$<br>故帧序号最少需要5个比特</p>]]></content>
      
      
      <categories>
          
          <category> homework </category>
          
          <category> network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> homework </tag>
            
            <tag> network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello world</title>
      <link href="/notes/greece/%CE%B5%CE%BB%CE%BB%CE%B7%CE%BD%CE%B9%CE%BA%CE%AC/"/>
      <url>/notes/greece/%CE%B5%CE%BB%CE%BB%CE%B7%CE%BD%CE%B9%CE%BA%CE%AC/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>το ποτήρι 🥃</th><th>水杯</th><th>το ψωμί 🥖</th><th>面包</th></tr></thead><tbody><tr><td><s>ο δίσκος 🛸</s></td><td>碟片</td><td>το τραπέζι</td><td>桌子</td></tr><tr><td><s>το τασάκι</s></td><td>烟灰缸</td><td><s>η ζώνη</s></td><td>皮带</td></tr><tr><td>η σοκολάτα 🍫</td><td>巧克力</td><td>το παγωτό 🍦</td><td>冰淇淋</td></tr></tbody></table><p>注意在回答对方&quot;Πως λέγεται αυτό το πράγμα στα ελληνικά;&quot;时回答不需要加冠词，同时要加书名号或双引号。注意Πώς要加重音符号</p><h1>第12周（1）</h1><table><thead><tr><th>Ερώτηση</th><th>Απάντηση</th><th>Γένος</th></tr></thead><tbody><tr><td>“Ποιος είναι αυτός;”</td><td>“Αυτός είναι + ο + name.”</td><td>Αρσενικό</td></tr><tr><td>“Ποια είναι αυτή;”</td><td>“Αυτή είναι + η + name.”</td><td>Θηλυκό</td></tr><tr><td>“Ποιος/Ποια είναι αυτό/αυτή;”</td><td>“Αυτός/Αυτή είναι + name.”</td><td>Ουδέτερο</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>κτλ. / κ.τλ. ==   <a href="http://e.tc">e.tc</a></p></li><li class="lvl-2"><p>国家，国籍与语言</p><table><thead><tr><th>Χώρα</th><th>Άνδρας</th><th>Γυναίκα</th><th>Γλώσσα</th></tr></thead><tbody><tr><td><strong>Ελλάδα</strong></td><td><strong>Έλληνας</strong></td><td><strong>Ελληνίδα</strong></td><td><strong>Ελληνικά</strong></td></tr><tr><td><strong>Ιταλία</strong></td><td><strong>Ιταλός</strong></td><td><strong>Ιταλίδα</strong></td><td><strong>Ιταλικά</strong></td></tr><tr><td><strong>Αγγλία</strong></td><td><strong>Άγγλος</strong></td><td><strong>Αγγλίδα</strong></td><td><strong>Αγγλικά</strong></td></tr><tr><td><strong>Αμερική</strong></td><td><strong>Αμερικανός</strong></td><td><strong>Αμερικανίδα</strong></td><td><strong>Αγγλικά</strong></td></tr><tr><td><strong>Ρωσία</strong></td><td><strong>Ρώσος</strong></td><td><strong>Ρωσίδα</strong></td><td><strong>Ρωσικά</strong></td></tr><tr><td><strong>Γερμανία</strong></td><td><strong>Γερμανός</strong></td><td><strong>Γερμανίδα</strong></td><td><strong>Γερμανικά</strong></td></tr><tr><td><strong>Γαλλία</strong></td><td><strong>Γάλλος</strong></td><td><strong>Γαλλίδα</strong></td><td><strong>Γαλλικά</strong></td></tr><tr><td>Πολωνία</td><td>Πολωνός</td><td>Πολωνέζα</td><td>Πολωνικά</td></tr><tr><td><em>Αυστραλία</em></td><td><em>Αυστραλός</em></td><td><em>Αυστραλέζα</em></td><td><em>Αγγλικά</em></td></tr><tr><td><strong>Κίνα</strong></td><td><strong>Κινέζος</strong></td><td><strong>Κινέζα</strong></td><td><strong>Κινέζικα</strong></td></tr><tr><td><strong>Ιαπωνία</strong></td><td><strong>Γιαπωνέζος</strong></td><td><strong>Γιαπωνέζα</strong></td><td><strong>γιαπωνέζικα</strong></td></tr><tr><td><strong>Τουρκία</strong></td><td><strong>Τούρκος</strong></td><td><strong>Τουρκάλα</strong></td><td><strong>Τουρκικά</strong></td></tr></tbody></table></li></ul><h3 id="生词表">生词表</h3><table><thead><tr><th>ο φίλος /η φίλη</th><th>朋友</th><th>Ελληνικά</th><th>Κινέζικα</th></tr></thead><tbody><tr><td>δημοσιογράφος</td><td>记者</td><td></td><td></td></tr><tr><td>che</td><td></td><td>το τηλέφωνο</td><td>电话</td></tr><tr><td>αναπτήρας</td><td>打火机</td><td>το πορτοφόλι</td><td>钱包</td></tr><tr><td>μηχανή</td><td>机器</td><td>η εφημερίδα</td><td>报纸</td></tr><tr><td>το βιβλίο</td><td>书</td><td>το σπίτι</td><td>房子</td></tr><tr><td>υπολογιστής</td><td>计算机</td><td>το αυτοκίνητο</td><td>汽车</td></tr><tr><td>ομπρέλα</td><td>雨伞</td><td>το μοτοποδήλατο</td><td>摩托车</td></tr><tr><td>ρολόι</td><td>手表</td><td></td><td></td></tr><tr><td>φάκελος</td><td>文件夹</td><td></td><td></td></tr></tbody></table><table><thead><tr><th>Αρσενικό</th><th>Θηλυκό</th><th>Ουδέτερο</th><th>Κινέζικα</th></tr></thead><tbody><tr><td>-ος</td><td>-η</td><td>-ο</td><td></td></tr><tr><td>ακριβός</td><td>ακριβή</td><td>ακριβό</td><td>昂贵的</td></tr><tr><td>φτηνός</td><td>φτηνή</td><td>φτηνό</td><td>便宜的</td></tr><tr><td>μικρός</td><td>μικρή</td><td>μικρό</td><td>小的</td></tr><tr><td>μεγάλος</td><td>μεγάλη</td><td>μεγάλο</td><td>大的</td></tr><tr><td>καθαρός</td><td>καθαρή</td><td>καθαρό</td><td>干净的</td></tr><tr><td>βρόμικος</td><td>βρόμικη</td><td>βρόμικο</td><td>肮脏的</td></tr><tr><td>άσχημος</td><td>άσχημη</td><td>άσχημο</td><td>丑陋的</td></tr><tr><td>-ος</td><td>‘α’</td><td>‘ο’</td><td></td></tr><tr><td>ωραίος</td><td>ωραία</td><td>ωραίο</td><td>漂亮的</td></tr><tr><td>καινούργιος</td><td>καινούργια</td><td>καινούργιο</td><td>新的</td></tr><tr><td>παλιός</td><td>παλιά</td><td>παλιό</td><td>旧的</td></tr></tbody></table><p>形容词变格和名词是一样的，而且形容词重音不变</p><p>Αυτή η ζώνη είναι λίγο μικρός  ¨λίγο 形容词副词形式一样</p><h3 id="生词表-2">生词表</h3><table><thead><tr><th>Ελληνικά</th><th>Κινέζικα</th><th>Ελληνικά</th><th>Κινέζικα</th></tr></thead><tbody><tr><td>Δυστυχώς</td><td>不幸的是</td><td></td><td></td></tr><tr><td>αγαπάει</td><td>爱</td><td></td><td></td></tr><tr><td>Έτσι είναι η ζωή.</td><td>这就是生活</td><td></td><td></td></tr><tr><td>όμως</td><td>however</td><td></td><td></td></tr><tr><td>θέλω</td><td>想</td><td></td><td></td></tr><tr><td>ξέρω</td><td>知道</td><td></td><td></td></tr><tr><td>ερωτευμένος</td><td>迷恋</td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><h1>第13周（1）</h1><ul class="lvl-0"><li class="lvl-2"><p>how old are you</p><blockquote><p>Πόσων Χρονών είσαι;-είναι;είστε…</p></blockquote></li><li class="lvl-2"><p>I am …</p><blockquote><p>ο έτος 年</p><p>1,-Είμαι ενός  <mark>έτους</mark>单数属格</p><p>2-100-Είμαι δύο/τριών <mark>χρωνών/ετών</mark>复数属格 注意3，4等的变化</p><p>ο μήνας—月</p><p>1,-Είναι ενός  <mark>μήνα</mark>单数属格</p><p>2-12’Είναι-δύο/τριών <mark>μηνών</mark>复数属格 注意3，4等的变化</p></blockquote></li><li class="lvl-2"><p>Για την Τάνια μιλάς;</p><p>你说的是 Τάνια 吗？</p></li></ul><table><thead><tr><th>μολύβι</th><th>铅笔</th><th></th><th></th></tr></thead><tbody><tr><td>καρέκλα</td><td>椅子</td><td></td><td></td></tr><tr><td>to άγαλμα</td><td>雕像</td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>μ’ αρέσει   后加主格</p></li><li class="lvl-2"><p>Δεν μ’ αρέσει ο μικρός</p></li></ul><h3 id="口语考试">口语考试</h3><ul class="lvl-0"><li class="lvl-2"><p>Πώς σε λένε;——你叫什么？</p></li><li class="lvl-2"><p>Από πού είσαι;——你来自哪里？</p></li><li class="lvl-2"><p>Πού μένεις;——你住哪？</p></li><li class="lvl-2"><p>Ποιο είναι το κινητό σου;——你的手机号码是？</p></li><li class="lvl-2"><p>Τι δουλειά κάνεις;——你的工作是？</p></li><li class="lvl-2"><p>Πόσω χρονών είσαι;——你多大了</p></li><li class="lvl-2"><p>Είσαι παντρεμένος ή ελεύθερος:——你结婚了还是单身</p></li><li class="lvl-2"><p>Έχεις παιδιά;——你有孩子吗？</p></li><li class="lvl-2"><p>Πόσω χρονών είναι;——他多大了？</p></li><li class="lvl-2"><p>Μιλάς ελληνικά; Άλλη γλώσσα;——你说希腊语吗？其他语言呢？</p></li><li class="lvl-2"><p>Σ’ αρέσει η Ελλάδα;  ——你喜欢希腊吗?</p></li></ul><ol><li class="lvl-3"><p>问答</p></li><li class="lvl-3"><p>朗读新文章</p></li><li class="lvl-3"><p>给一个主题，持续说2分钟</p></li></ol><h2 id="第13周（1）">第13周（1）</h2><ul class="lvl-0"><li class="lvl-2"><p>Πάω (στο) σπίτι 只有很少的搭配中στο可以省去</p></li><li class="lvl-2"><p>Πάω σε + place : go somewhere</p></li><li class="lvl-2"><p>Τα λέμε : see you</p></li></ul><h3 id="被动性动词：">被动性动词：</h3><p>形式上是被动，但不一定表示被动涵义</p><ol><li class="lvl-3"><p>表被动</p></li><li class="lvl-3"><p>发出的动作作用于自己</p></li><li class="lvl-3"><p>互相</p></li><li class="lvl-3"><p>没有主动形式</p></li></ol><h2 id="what-time-is">what time is ?</h2><ul class="lvl-0"><li class="lvl-2"><p>Τι ώρα είναι / έχετε/έχεις</p></li><li class="lvl-2"><p>Είναι η ώρα μία/δύο/τρεις κτλ. ή Είναι μία/δύο/τρεις κτλ. η ώρα</p></li><li class="lvl-2"></li><li class="lvl-2"><table><thead><tr><th></th><th>我</th><th>你</th><th>他/她/它</th><th>我们</th><th>你们</th><th>他们/她们/它们</th></tr></thead><tbody><tr><td>πάω</td><td>πάω</td><td>πας</td><td>πάει</td><td>πάμε</td><td>πάτε</td><td>πάνε</td></tr><tr><td>λέω</td><td>λέω</td><td>λες</td><td>λέει</td><td>λέμε</td><td>λέτε</td><td>λένε</td></tr><tr><td>τρώω</td><td>τρώω</td><td>τρως</td><td>τρώει</td><td>τρώμε</td><td>τρώτε</td><td>τρώνε</td></tr><tr><td>ακούω</td><td>ακούω</td><td>ακούς</td><td>ακούει</td><td>ακούμε</td><td>ακούτε</td><td>ακούνε</td></tr><tr><td>έρχομαι</td><td>έρχομαι</td><td>έρχεσαι</td><td>έρχεται</td><td>έρχόμαστε</td><td>έρχεστε</td><td>έρχονται</td></tr><tr><td>γίνομαι</td><td>γίνομαι</td><td>γίνεσαι</td><td>γίνεται</td><td>γινόμαστε</td><td>γίνεστε</td><td>γίνονται</td></tr><tr><td>σκέφτομαι</td><td>σκέφτομαι</td><td>σκέφτεσαι</td><td>σκέφτεται</td><td>σκεφτόμαστε</td><td>σκέφτεστε</td><td>σκέφτονται</td></tr><tr><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></li></ul><h2 id="Τι-ώρα-είναι">Τι ώρα είναι;</h2><p>Άννα Βρε Μάρθα, τι μέρα είναι σήμερα;<br>Μάρθα Παρασκευή.<br>Άννα Παρασκευή; Πόπο, έχω ραντεβού με τον Βασίλη. Και δε θυμάμαι τι ώρα.<br>Πού είναι η ατζέντα μου; Λοιπόν… Παρασκευή… Βασίλης… στις δέκα και μισή.<br>Μήπως ξέρεις τι ώρα είναι τώρα;<br>Μάρθα Δέκα και δέκα ακριβώς.<br>Άννα Φεύγω.<br>Μάρθα Καλά, πού είναι το ραντεβού σου;<br>Άννα Στο Μουσείο. Έρχεσαι μαζί μου;<br>Μάρθα Δεν μπορώ. Έχω δουλειά ακόμα. Λυπάμαι.<br>Άννα Δεν πειράζει. Έλα, γεια, εμείς τα λέμε τη Δευτέρα.<br>Μάρθα Εντάξει. Καλό σαββατοκύριακο.<br>Άννα Ευχαριστώ, επίσης</p><table><thead><tr><th>希腊语</th><th>中文</th><th></th><th></th></tr></thead><tbody><tr><td>ώρα</td><td>时间</td><td>Λυπάμαι</td><td>抱歉</td></tr><tr><td>ημέρα</td><td>天</td><td>Εντάξει</td><td>没问题&quot;</td></tr><tr><td>Παρασκευή</td><td>星期五</td><td>στις 3:00</td><td>在3点</td></tr><tr><td>ραντεβού</td><td>约会</td><td>αρχίζω</td><td>开始</td></tr><tr><td>Βασίλης</td><td>希腊男名</td><td>τελειώνω</td><td>结束</td></tr><tr><td>ατζέντα</td><td>日程</td><td>σούπερ μάρκετ</td><td>超市</td></tr><tr><td>μουσείο</td><td>博物馆</td><td>τρένο</td><td>火车</td></tr><tr><td>Δευτέρα</td><td>星期一</td><td>αεροπλάνο</td><td>飞机</td></tr><tr><td>Σαββατοκύριακο</td><td>周末</td><td>ανοίγει</td><td>开门</td></tr><tr><td></td><td></td><td>κλείνει</td><td>关门</td></tr><tr><td>μέχρι τις</td><td>直到</td><td>τράπεζα</td><td>银行</td></tr><tr><td></td><td></td><td>π.μ.</td><td>a.m</td></tr><tr><td></td><td></td><td>μ.μ.</td><td>p.m</td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>μπορώ ：can</p></li><li class="lvl-2"><p>Δεν  <mark>μπορώ να</mark> το κάνω ： i can‘t do it</p></li></ul><table><thead><tr><th>Ώρα</th><th>Ελληνικά</th><th>Κινέζικα</th></tr></thead><tbody><tr><td>3:00-12:00</td><td>πρωί</td><td>早上</td></tr><tr><td>12:00-15:00</td><td>μεσημέρι</td><td>中午</td></tr><tr><td>15:00-19:00</td><td>απόγευμα</td><td>下午</td></tr><tr><td>19:00-24:00</td><td>βράδυ</td><td>晚上</td></tr><tr><td>24:00</td><td>μεσάνυχτα</td><td>午夜</td></tr></tbody></table><h4 id="希腊语直接用宾格做时间状语。（由于全部是中性，所以和主格的形式都不变）">希腊语直接用宾格做时间状语。（由于全部是中性，所以和主格的形式都不变）</h4><ol><li class="lvl-3"><p>Το μάθημα αρχίζει στις εννιάμισι το πρωί. 这节课早上九点半开始。</p></li><li class="lvl-3"><p>Το σινεμά τελειώνει στις έντεκα το βράδυ. 电影院晚上十一点结束(关门)。</p></li><li class="lvl-3"><p>Το σούπερ μάρκετ ανοίγει στις οκτώ το πρωί. 超市早上八点开门。</p></li><li class="lvl-3"><p>Η τράπεζα κλείνει στις δύο το μεσημέρι. 银行中午两点关门。</p></li><li class="lvl-3"><p>Το τρένο φτάνει στις εννιά και τέταρτο το βράδυ. 火车晚上九点十五分到达。</p></li><li class="lvl-3"><p>Το αεροπλάνο φεύγει <mark>στη μία το μεσημέρι</mark>. 飞机中午一点起飞。</p></li><li class="lvl-3"><p>στη μία 需要加上早上或者中午</p></li><li class="lvl-3"><p><mark>τα</mark>,μεσάνυχτα 零点</p></li><li class="lvl-3"></li><li class="lvl-3"><p>7:40,7.40 π.μ.</p></li><li class="lvl-3"><p>16:00,4 μ.μ.</p></li><li class="lvl-3"><p>9:45,9.45 π.μ.</p></li><li class="lvl-3"><p>2:30 2.30 π.μ.</p></li><li class="lvl-3"><p>10:40 ,10.40 π.μ.</p></li><li class="lvl-3"><p>9:20 9.20 μ.μ</p></li><li class="lvl-3"><p>2:40 2:40 μ.μ.</p></li></ol><h3 id="希腊语的星期">希腊语的星期</h3><ul class="lvl-0"><li class="lvl-2"><p>Δευτέρα（Deftéra） - 星期一</p></li><li class="lvl-2"><p>Τρίτη（Tríti） - 星期二</p></li><li class="lvl-2"><p>Τετάρτη（Tetárti） - 星期三</p></li><li class="lvl-2"><p>Πέμπτη（Pémpti） - 星期四</p></li><li class="lvl-2"><p>Παρασκευή（Paraskeví） - 星期五</p></li><li class="lvl-2"><p>Σάββατο（Sábbato） - 星期六</p></li><li class="lvl-2"><p>Κυριακή（Kyriakí） - 星期日</p></li></ul><p>μετά:after</p><p>πριν ：before</p><table><thead><tr><th>希腊语</th><th>冠词</th><th>中文翻译</th></tr></thead><tbody><tr><td>η Δευτέρα</td><td>η (i)</td><td>星期一</td></tr><tr><td>η Τρίτη</td><td>η (i)</td><td>星期二</td></tr><tr><td>η Τετάρτη</td><td>η (i)</td><td>星期三</td></tr><tr><td>η Πέμπτη</td><td>η (i)</td><td>星期四</td></tr><tr><td>η Παρασκευή</td><td>η (i)</td><td>星期五</td></tr><tr><td>το Σάββατο</td><td>το (to)</td><td>星期六</td></tr><tr><td>η Κυριακή</td><td>η (i)</td><td>星期日</td></tr></tbody></table><p>在xx，直接换成宾格即可</p><p>την Τετάρτη :在周三</p><p>μέχρι = ώς = έως：直到</p><ol><li class="lvl-3"></li></ol>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
          <category> ελληνικά </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生词表 </tag>
            
            <tag> ελληνικά </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ελληνικά</title>
      <link href="/notes/greece/%E4%BB%A5%E4%B8%8B%E6%98%AF%E5%B8%8C%E8%85%8A%E8%AF%AD%E7%B3%BB%E5%8A%A8%E8%AF%8D%E5%92%8C%CE%B1,%20%CE%B21,%20%CE%B22%E5%9E%8B%E5%8A%A8%E8%AF%8D%E5%9C%A8%E5%85%AD%E7%A7%8D%E4%BA%BA%E7%A7%B0%E4%B8%8B%E7%9A%84%E5%8F%98%E4%BD%8D%E8%A7%84%E5%88%99%EF%BC%9A/"/>
      <url>/notes/greece/%E4%BB%A5%E4%B8%8B%E6%98%AF%E5%B8%8C%E8%85%8A%E8%AF%AD%E7%B3%BB%E5%8A%A8%E8%AF%8D%E5%92%8C%CE%B1,%20%CE%B21,%20%CE%B22%E5%9E%8B%E5%8A%A8%E8%AF%8D%E5%9C%A8%E5%85%AD%E7%A7%8D%E4%BA%BA%E7%A7%B0%E4%B8%8B%E7%9A%84%E5%8F%98%E4%BD%8D%E8%A7%84%E5%88%99%EF%BC%9A/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>数字</th><th>希腊语</th><th>数字</th><th>希腊语</th></tr></thead><tbody><tr><td>1</td><td>μία (mía)</td><td>20</td><td>είκοσι (íkosi)</td></tr><tr><td>2</td><td>δύο (dýo)</td><td>30</td><td>τριάντα (triánta)</td></tr><tr><td>3</td><td>τρία (tría)</td><td>40</td><td>σαράντα (saránta)</td></tr><tr><td>4</td><td>τέσσερα (téssera)</td><td>50</td><td>πενήντα (penínta)</td></tr><tr><td>5</td><td>πέντε (pénte)</td><td>60</td><td>εξήντα (exínta)</td></tr><tr><td>6</td><td>έξι (éxi)</td><td>70</td><td>εβδομήντα (evdomínta)</td></tr><tr><td>7</td><td>εφτά (eftá)</td><td>80</td><td>ογδόντα (ogdónta)</td></tr><tr><td>8</td><td>οχτώ (ochtó)</td><td>90</td><td>ενενήντα (enenínta)</td></tr><tr><td>9</td><td>εννιά (ennéa)</td><td>100</td><td>εκατό (ekató)</td></tr><tr><td>10</td><td>δέκα (déka)</td><td>200</td><td>διακόσια (diakósia)</td></tr><tr><td>11</td><td>έντεκα (énteka)</td><td>300</td><td>τριακόσια (triakósia)</td></tr><tr><td>12</td><td>δώδεκα (dódeka)</td><td>400</td><td>τετρακόσια (tetrakósia)</td></tr><tr><td>13</td><td>δεκατρία (dekatría)</td><td>500</td><td>πεντακόσια (pentakósia)</td></tr><tr><td>14</td><td>δεκατέσσερα (dekatéssera)</td><td>600</td><td>εξακόσια (hexakósia)</td></tr><tr><td>15</td><td>δεκαπέντε (dekarpénte)</td><td>700</td><td>εφτακόσια (eftakósia)</td></tr><tr><td>16</td><td>δεκαέξι (dekaéxi)</td><td>800</td><td>οκτακόσια (oktakósia)</td></tr><tr><td>17</td><td>δεκαεφτά (dekaeftá)</td><td>900</td><td>εννιακόσια (enniakósia)</td></tr><tr><td>18</td><td>δεκαοχτώ (dekaochtó)</td><td>1000</td><td>χίλια</td></tr><tr><td>19</td><td>δεκαεννιά (dekaennéa)</td><td>0</td><td>μηδέν</td></tr></tbody></table><h3 id="以下是希腊语系动词和α-β1-β2型动词在六种人称下的变位规则：">以下是希腊语系动词和α, β1, β2型动词在六种人称下的变位规则：</h3><h4 id="系动词-μαι">系动词 (μαι)</h4><table><thead><tr><th>人称</th><th>一</th><th>二</th><th>三</th></tr></thead><tbody><tr><td>单数</td><td>εγώ είμαι</td><td>εσύ είσαι</td><td>αυτός/αυτή/αυτό είναι</td></tr><tr><td>复数</td><td>εμείς είμαστε</td><td>εσείς είστε</td><td>αυτοί/αυτές είναι</td></tr></tbody></table><h4 id="α动词-μαθαίνω，ω结尾，重音不在其上">α动词 (μαθαίνω，ω结尾，重音不在其上)</h4><table><thead><tr><th>人称</th><th>一</th><th>二</th><th>三</th></tr></thead><tbody><tr><td>单数</td><td>μαθαίνω -ω</td><td>μαθαίνεις -εις</td><td>μαθαίνει -ει</td></tr><tr><td>复数</td><td>μαθαίνουμε -ουμε</td><td>μαθαίνετε -ετε</td><td>μαθαίνουν -ουν</td></tr></tbody></table><p>πηγαίνω(去),πειράζει(to bother),</p><h4 id="β1动词-γράφω，-άω结尾">β1动词 (γράφω，-άω结尾)</h4><table><thead><tr><th>人称</th><th>一</th><th>二</th><th>三</th></tr></thead><tbody><tr><td>单数</td><td>μιλάω -άω</td><td>μιλάς -άς</td><td>μιλάει -άει</td></tr><tr><td>复数</td><td>μιλάμε -άμε</td><td>μιλάτε -άτε</td><td>μιλάνε -άνε</td></tr></tbody></table><p>αγαπάω爱,   περνάω(spend),  ρωτάω(ask),  απαντάω(answer)</p><table><thead><tr><th>现在时动词</th><th>πάω(go)</th><th>λέω(speak)</th><th>τρώω(eat)</th><th>ακούω(listen)</th></tr></thead><tbody><tr><td>Εγώ</td><td>πάω</td><td>λέω</td><td>τρώω</td><td>ακούω</td></tr><tr><td>Εσύ</td><td>πας</td><td>λες</td><td>τρως</td><td>ακούς</td></tr><tr><td>Αυτός</td><td>πάει</td><td>λέει</td><td>τρώει</td><td>ακούει</td></tr><tr><td>Εμείς</td><td>πάμε</td><td>λέμε</td><td>τρώμε</td><td>ακούμε</td></tr><tr><td>Εσείς</td><td>πάτε</td><td>λέτε</td><td>τρώτε</td><td>ακούτε</td></tr><tr><td>Αυτοί</td><td>πάνε</td><td>λένε</td><td>τρώνε</td><td>ακούνε</td></tr></tbody></table><h4 id="β2动词">β2动词</h4><table><thead><tr><th>β2</th><th>Οδηγώ (drive)</th><th>Ζω (live)</th><th>Αργώ (be late)</th><th>Τηλεφωνώ (phone v.)</th><th>μπορώ(can)</th></tr></thead><tbody><tr><td>第一人称单数</td><td>οδηγώ</td><td>ζω</td><td>αργώ</td><td>τηλεφωνώ</td><td>μπορώ</td></tr><tr><td>第二人称单数</td><td>οδηγείς</td><td>ζεις</td><td>αργείς</td><td>τηλεφωνείς</td><td>μπορείς</td></tr><tr><td>第三人称单数</td><td>οδηγεί</td><td>ζει</td><td>αργεί</td><td>τηλεφωνεί</td><td>μπορεί</td></tr><tr><td>第一人称复数</td><td>οδηγούμε</td><td>ζούμε</td><td>αργούμε</td><td>τηλεφωνούμε</td><td>μπορούμε</td></tr><tr><td>第二人称复数</td><td>οδηγείτε</td><td>ζείτε</td><td>αργείτε</td><td>τηλεφωνείτε</td><td>μπορείτε</td></tr><tr><td>第三人称复数</td><td>οδηγούν</td><td>ζουν</td><td>αργούν</td><td>τηλεφωνούν</td><td>μπορούν(ε)</td></tr></tbody></table><h3 id="Γ类动词">Γ类动词</h3><table><thead><tr><th>Γ1</th><th>έρχομαι (come)</th><th>γίνομαι (become)</th><th>σκέφτομαι (think)</th></tr></thead><tbody><tr><td>Εγώ</td><td>έρχομαι</td><td>γίνομαι</td><td>σκέφτ<strong>ομαι</strong></td></tr><tr><td>Εσύ</td><td>έρχεσαι</td><td>γίνεσαι</td><td>σκέφτ<strong>εσαι</strong></td></tr><tr><td>Αυτός</td><td>έρχεται</td><td>γίνεται</td><td>σκέφτ<strong>εται</strong></td></tr><tr><td>Εμείς</td><td>ερχόμαστε</td><td>γινόμαστε</td><td>σκεφτ<strong>όμαστε</strong></td></tr><tr><td>Εσείς</td><td>έρχεστε</td><td>γίνεστε</td><td>σκέφτ<strong>εστε</strong></td></tr><tr><td>Αυτοί</td><td>έρχονται</td><td>γίνονται</td><td>σκέφτ<strong>ονται</strong></td></tr></tbody></table><p>τι γίνεται 固定搭配 what’s up</p><p>和α类相比，只有第二人称复数不同</p><table><thead><tr><th>Γ2</th><th>Κοιμάμαι (sleep)</th><th>Λυπάμαι (feel sorry)</th><th>Θυμάμαι (remember)</th><th>Φοβάμαι (fear)</th></tr></thead><tbody><tr><td>第一人称单数</td><td>κοιμάμαι</td><td>λυπάμαι</td><td>θυμάμαι</td><td>φοβ<strong>άμαι</strong></td></tr><tr><td>第二人称单数</td><td>κοιμάσαι</td><td>λυπάσαι</td><td>θυμάσαι</td><td>φοβ<strong>άσαι</strong></td></tr><tr><td>第三人称单数</td><td>κοιμάται</td><td>λυπάται</td><td>θυμάται</td><td>φοβ<strong>άται</strong></td></tr><tr><td>第一人称复数</td><td>κοιμόμαστε</td><td>λυπόμαστε</td><td>θυμόμαστε</td><td>φοβ<strong>όμαστε</strong></td></tr><tr><td>第二人称复数</td><td>κοιμάστε</td><td>λυπάστε</td><td>θυμάστε</td><td>φοβ<strong>άστε</strong></td></tr><tr><td>第三人称复数</td><td>κοιμούνται</td><td>λυπούνται</td><td>θυμούνται</td><td>φοβ<strong>ούνται</strong></td></tr></tbody></table><p>可以和είμαι 对比记忆，只有第三人称不同，第二人称复数有小区别.</p><h3 id="物主代词">物主代词</h3><table><thead><tr><th style="text-align:center">人称代词</th><th style="text-align:center">单数形式</th><th style="text-align:center">复数形式</th></tr></thead><tbody><tr><td style="text-align:center">第一人称</td><td style="text-align:center">μου (mou)</td><td style="text-align:center">μας (mas)</td></tr><tr><td style="text-align:center">第二人称</td><td style="text-align:center">σου (sou)</td><td style="text-align:center">σας (sas)</td></tr><tr><td style="text-align:center">第三人称</td><td style="text-align:center">του (tou)/της/του</td><td style="text-align:center">τους (tous)</td></tr></tbody></table><h3 id="希腊语问好">希腊语问好</h3><table><thead><tr><th>希腊语</th><th>中文</th><th>发音</th></tr></thead><tbody><tr><td>γεια σου</td><td>你好（单数）</td><td>yea soo</td></tr><tr><td>γεια σας</td><td>您好（复数或正式场合）</td><td>yea sas</td></tr><tr><td>καλημέρα</td><td>早上好 / 上午好</td><td>kah-lee-MER-ah</td></tr><tr><td>καλησπέρα</td><td>下午好 / 晚上好</td><td>ka-lee-SPER-ah</td></tr><tr><td>καληνύχτα</td><td>晚安</td><td>kah-lee-NEECH-tah</td></tr><tr><td>αντίο</td><td>再见</td><td></td></tr></tbody></table><h3 id="国家">国家</h3><p>国家，国籍与语言</p><table><thead><tr><th>Χώρα</th><th>Άνδρας</th><th>Γυναίκα</th><th>Γλώσσα</th></tr></thead><tbody><tr><td><strong>Ελλάδα</strong></td><td><strong>Έλληνας</strong></td><td><strong>Ελληνίδα</strong></td><td><strong>Ελληνικά</strong></td></tr><tr><td><strong>Ιταλία</strong></td><td><strong>Ιταλός</strong></td><td><strong>Ιταλίδα</strong></td><td><strong>Ιταλικά</strong></td></tr><tr><td><strong>Αγγλία</strong></td><td><strong>Άγγλος</strong></td><td><strong>Αγγλίδα</strong></td><td><strong>Αγγλικά</strong></td></tr><tr><td><strong>Αμερική</strong></td><td><strong>Αμερικανός</strong></td><td><strong>Αμερικανίδα</strong></td><td><strong>Αγγλικά</strong></td></tr><tr><td><strong>Ρωσία</strong></td><td><strong>Ρώσος</strong></td><td><strong>Ρωσίδα</strong></td><td><strong>Ρωσικά</strong></td></tr><tr><td><strong>Γερμανία</strong></td><td><strong>Γερμανός</strong></td><td><strong>Γερμανίδα</strong></td><td><strong>Γερμανικά</strong></td></tr><tr><td><strong>Γαλλία</strong></td><td><strong>Γάλλος</strong></td><td><strong>Γαλλίδα</strong></td><td><strong>Γαλλικά</strong></td></tr><tr><td>Πολωνία</td><td>Πολωνός</td><td>Πολωνέζα</td><td>Πολωνικά</td></tr><tr><td><em>Αυστραλία</em></td><td><em>Αυστραλός</em></td><td><em>Αυστραλέζα</em></td><td><em>Αγγλικά</em></td></tr><tr><td><strong>Κίνα</strong></td><td><strong>Κινέζος</strong></td><td><strong>Κινέζα</strong></td><td><strong>Κινέζικα</strong></td></tr><tr><td><strong>Ιαπωνία</strong></td><td><strong>Γιαπωνέζος</strong></td><td><strong>Γιαπωνέζα</strong></td><td><strong>γιαπωνέζικα</strong></td></tr><tr><td><strong>Τουρκία</strong></td><td><strong>Τούρκος</strong></td><td><strong>Τουρκάλα</strong></td><td><strong>Τουρκικά</strong></td></tr></tbody></table><table><thead><tr><th>亲人</th><th>单数形式</th></tr></thead><tbody><tr><td>父亲</td><td>πατέρας</td></tr><tr><td>母亲</td><td>μητέρα</td></tr><tr><td>儿子</td><td>γιος\αγόρι(男孩)</td></tr><tr><td>女儿</td><td>κόρη\Κορίτσι(女孩)</td></tr><tr><td>兄弟</td><td>αδελφός</td></tr><tr><td>姐妹</td><td>αδελφή</td></tr><tr><td>丈夫</td><td>άντρας</td></tr><tr><td>妻子</td><td>γυναίκα</td></tr></tbody></table><h3 id="生词表">生词表</h3><table><thead><tr><th style="text-align:left">Καλήμέρα (σας)</th><th></th><th>Καλησπέρα (σας)</th><th></th></tr></thead><tbody><tr><td style="text-align:left">Γεια σας</td><td></td><td>Καληνύχτα</td><td></td></tr><tr><td style="text-align:left">Χαίρετε</td><td>Hello</td><td></td><td></td></tr><tr><td style="text-align:left">Αντίο (σας)</td><td>goodbye</td><td></td><td></td></tr><tr><td style="text-align:left">τώρα</td><td>现在</td><td></td><td></td></tr><tr><td style="text-align:left">δουλεύω</td><td>工作</td><td></td><td></td></tr><tr><td style="text-align:left">μένω</td><td>住</td><td></td><td></td></tr><tr><td style="text-align:left">παντρεμένη</td><td>已婚女性</td><td></td><td></td></tr><tr><td style="text-align:left">άντρας</td><td>男人</td><td></td><td></td></tr><tr><td style="text-align:left"><strong>Από ποιο μέρος;</strong></td><td>你来自哪里？</td><td></td><td></td></tr><tr><td style="text-align:left">πως λεγεστε</td><td>你叫什么名字？</td><td></td><td></td></tr><tr><td style="text-align:left">τηλέφωνο</td><td>电话</td><td></td><td></td></tr><tr><td style="text-align:left">παρακαλώ</td><td>请</td><td></td><td></td></tr><tr><td style="text-align:left">ακριβώς</td><td>正好</td><td></td><td></td></tr><tr><td style="text-align:left">Εντάξει</td><td>好</td><td></td><td></td></tr><tr><td style="text-align:left">Επίσης λέμε:</td><td>同样也说：</td><td></td><td></td></tr><tr><td style="text-align:left">μήπως</td><td>难道</td><td></td><td></td></tr><tr><td style="text-align:left">κινητό</td><td>手机</td><td></td><td></td></tr><tr><td style="text-align:left">λεπτό</td><td>分钟</td><td></td><td></td></tr><tr><td style="text-align:left">Συγνώμη</td><td>对不起</td><td></td><td></td></tr><tr><td style="text-align:left">καθηγητής/καθηγήτρια</td><td>教授</td><td>γιατρός</td><td>医生</td></tr><tr><td style="text-align:left">πωλητής/πωλήτρια</td><td>销售员</td><td>φωτογράφος</td><td>摄影师</td></tr><tr><td style="text-align:left">δάσκαλος/δασκάλα</td><td>老师</td><td>μηχανικός</td><td>工程师</td></tr><tr><td style="text-align:left">μαθητής/μαθήτρια</td><td>学生</td><td>γραμματέας</td><td>秘书</td></tr><tr><td style="text-align:left">εργάτης/εργάτρια</td><td>工人</td><td>συνταξιούχος</td><td>退休人员</td></tr><tr><td style="text-align:left">άνεργος/άνεργη</td><td>失业人员</td><td>φωτομοντέλο (!)</td><td>时装模特儿</td></tr><tr><td style="text-align:left">φοιτητής/φοιτήτρια</td><td>大学生</td><td></td><td></td></tr><tr><td style="text-align:left">Παντρεμένος ή <strong>ελεύθερος</strong>/χωρισμένη</td><td>已婚/未婚/离异</td><td></td><td></td></tr><tr><td style="text-align:left">Λίγο.</td><td>一点点</td><td></td><td></td></tr><tr><td style="text-align:left">καθόλου.</td><td>一点也不</td><td></td><td></td></tr><tr><td style="text-align:left">δε μιλάω καθόλου αραβικά.</td><td>我一点也不会阿拉伯语。</td><td></td><td></td></tr><tr><td style="text-align:left"><strong>διεύθυνσή</strong> τούς.</td><td>他们的地址</td><td></td><td></td></tr><tr><td style="text-align:left">νοσοκομείο.</td><td>医院</td><td></td><td></td></tr><tr><td style="text-align:left">καταλαωαίνει.</td><td>理解</td><td></td><td></td></tr><tr><td style="text-align:left">αρκετά.</td><td>相当的</td><td></td><td></td></tr><tr><td style="text-align:left">ακόμα.</td><td>还是</td><td></td><td></td></tr><tr><td style="text-align:left">φούρνος</td><td>面包店（原义为烤箱）</td><td></td><td></td></tr><tr><td style="text-align:left"></td><td></td><td></td><td></td></tr><tr><td style="text-align:left"></td><td></td><td></td><td></td></tr><tr><td style="text-align:left"></td><td></td><td></td><td></td></tr></tbody></table><ul class="lvl-0"><li class="lvl-2"><p>yu语法</p><ul class="lvl-2"><li class="lvl-4"><p>σε+την=στην</p></li><li class="lvl-4"><p>p53:路名：η οδός,η λε</p></li><li class="lvl-4"><p>+ = συν / και</p><p>— = πλην</p></li><li class="lvl-4"><p>Το τηλέφωνό μου στο σπίτι είναι 210 9511203 调和音节（如果一个名词的重音位置在倒数第三音节，且其后是表示所属的物主代词）</p><ul class="lvl-4"><li class="lvl-6">(καθηγήτριά σού)</li><li class="lvl-6">διεύθνσή τούς</li></ul></li><li class="lvl-4"><p>-ι结尾变复数：加α</p><table><thead><tr><th>ένα παιδί</th><th>δύο/τρία… παιδιά</th></tr></thead><tbody><tr><td>ένα κορίτσι</td><td>δύο/τρία… κορίτσια</td></tr></tbody></table></li></ul></li><li class="lvl-2"><p>例句</p><ol><li class="lvl-5">Η Κάρεν είναι από την Αγγλία;</li><li class="lvl-5">Μιλάει ελληνικά;</li><li class="lvl-5">Τι δουλειά κάνει;</li><li class="lvl-5">Πού δουλεύει τώρα;</li><li class="lvl-5">Ο Γιώργος είναι καθηγητής;</li><li class="lvl-5">Πού μένειη Κάρεν τώρα;</li><li class="lvl-5">Είναι παντρεμένη;</li><li class="lvl-5">Έχει παιδιά;</li><li class="lvl-5">Πού είναι ο άντρας της;</li><li class="lvl-6">Είναι παντρεμένη με τον Χουάν κι έχουν δύο παιδιά,ένα κορίτσι , την Ντολόρες , κι ένα αγόρι, τον<br>Αντόνιο.</li></ol></li></ul><p>你好，我是peter。我来自中国，北京。现在住在希腊，雅典，xx路xx号。我是一名大学生。我目前单身。但是我有一个姐姐，她的名字是海伦，她已婚，有两个孩子，一个儿子，一个女儿。我姐姐的工作是医生。我会说希腊语，我的中文说得很好。但是我的英语很糟糕，我能理解英语但是我不会说。我和我的妈妈住在一起。我们的家庭电话号码是xxxxx。我也有手机，它的号码是xxxx。</p><p>Γεια σου, είμαι ο Peter. Είμαι από την Κίνα, το Πεκίνο. Τώρα μένω στην Αθήνα, στη διεύθυνση xx, στην οδό xx. Είμαι φοιτητής. Παρόλα αυτά, είμαι ανύπαντρος. Έχω όμως μια αδελφή, την Ελένη. Είναι παντρεμένη και έχει δύο παιδιά, ένα γιο και μια κόρη. Η δουλειά της είναι γιατρός. Μιλάω Ελληνικά, ενώ τα Κινέζικά μου είναι πολύ καλά. Ωστόσο, τα Αγγλικά μου είναι πολύ άσχημα και δεν μπορώ να μιλήσω καθόλου. Ζω με τη μητέρα μου. Ο οικιακός τηλέφωνός μας είναι xxxx και έχω επίσης ένα κινητό τηλέφωνο με τον αριθμό xxxx.</p><table><thead><tr><th>希λληνικά</th><th>通常与之配合的介词</th><th>中文</th></tr></thead><tbody><tr><td>μπροστά</td><td>από, σε</td><td>前面</td></tr><tr><td>απέναντι</td><td>από, σε</td><td>对面</td></tr><tr><td>πίσω</td><td>από</td><td>后面</td></tr><tr><td>μακριά</td><td>από</td><td>away</td></tr><tr><td>κοντά</td><td>σε</td><td>near</td></tr><tr><td>δίπλα</td><td>σε</td><td>旁边</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
          <category> ελληνικά </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ελληνικά </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>README</title>
      <link href="/README/"/>
      <url>/README/</url>
      
        <content type="html"><![CDATA[<h1>README</h1><h3 id="我为什么在这里">我为什么在这里</h3><p>也许这里以后会补上我创建这个博客的原因</p><h3 id="你为什么在这里">你为什么在这里</h3><p>等待戈多</p><h3 id="其他">其他</h3><p>我从来都是白底界面亮度拉满。这次为什么是黑色的主题呢？其实它也提供了白色主题。</p><p>文章创建日期是可以随便改的&gt;&gt;&gt;</p><!-- About Me --><div class="container">    <div class="row">        <div class="col-md-12">            <h2>About Me</h2>        </div>    </div>    <div class="row">        <div class="col-md-4">            <img src="/img/profile.png" alt="Profile Image">        </div>        <div class="col-md-8">            <p>Hi, I am YUX and I am passionate about NOTHING. </p>        </div>    </div></div><div class="danger"><p>时间紧，任务重，I’m f**ked up</p></div><div class="warning"><p>时间不多了,under pressure</p></div><div class="tips"><p>时间还早,totally under control</p></div><div class="success"><p>写完了😄</p></div>]]></content>
      
      
      <categories>
          
          <category> others </category>
          
      </categories>
      
      
        <tags>
            
            <tag> README </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
